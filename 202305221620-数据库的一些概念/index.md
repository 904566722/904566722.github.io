# 数据库的一些概念

<!--more-->
#

## ACID

- [A]^(Atomicity)：原子性，事务要么全部成功，要么全部失败
- [C]^(Consistency)：一致性，数据库的状态总是在一致性状态之间转换
- [I]^(Isolation)：隔离性，一个事务的操作对其他事务是不可见的
- [D]^(Durability)：持久性，事务一旦提交，产生的变化是持久的

![](images/posts/Pasted%20image%2020230522165107.png)

他们是如何得到保证的？
- 原子性：undo log
- 一致性：代码层面
- 隔离性：锁、MVCC（多版本并发控制）
- 持久性：内存 + redo log

{{< admonition type=quote title="redo log" open=false >}}
redo log（重做日志）是数据库中的一种机制，用于记录数据库中的修改操作。它主要用于保证事务的持久性和恢复能力。

具体来说，当一个事务对数据库进行修改时，系统会将这些修改操作记录到redo log中，而不是直接写入磁盘上的数据文件。这样可以避免频繁地写入磁盘，提高数据库的性能。同时，redo log还可以用于在系统崩溃或断电等异常情况下，恢复数据库中未提交的修改操作。

当系统重新启动时，它会读取redo log中的记录，并将其中的修改操作重新应用到数据库中，从而恢复数据库的状态。如果某个事务已经提交，那么它对应的redo log记录就可以被删除，因为这些修改操作已经被写入了磁盘上的数据文件中。

总之，redo log是数据库中的一种机制，用于记录数据库中的修改操作，以保证事务的持久性和恢复能力。
{{< /admonition >}}


## 并发计算中的一致性问题

- **丢失修改**：两个事务对一个数据修改，其中一个被覆盖了
- **读脏数据**（为什么叫脏数据？因为这个数据是不应该存在的，或者叫做垃圾）：A修改后回滚了，B读到了A修改后的值
- **不可重复度**：B两次读操作中间，A对数据进行了修改
- **幻影读**：指在同一事务中，多次查询时，由于其他事务插入或删除了数据，导致查询结果出现了新的行或者少了原有的行


丢失修改和读脏数据：
![](images/posts/Pasted%20image%2020230522170900.png)
不可重复读：
![](images/posts/Pasted%20image%2020230522172132.png)

## 事务隔离级别跟一致性问题之间的关系

下表列出了不同的事务隔离级别和它们可能导致的数据库一致性问题：

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| --- | --- | --- | --- |
| 读未提交（Read Uncommitted） | 可能发生 | 可能发生 | 可能发生 |
| 读已提交（Read Committed） | 不会发生 | 可能发生 | 可能发生 |
| 可重复读（Repeatable Read） | 不会发生 | 不会发生 | 可能发生 |
| 串行化（Serializable） | 不会发生 | 不会发生 | 不会发生 |

总之，**隔离级别越高，数据库的一致性就越好，但是并发性能也会降低**。因此，在实际应用中，需要根据具体情况选择合适的隔离级别来平衡一致性和性能的需求。
