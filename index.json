[{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"KMP 算法用途 在主串 S 中查找模式串 pattern ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#kmp-算法用途"},{"categories":["数据结构与算法"],"content":"算法流程","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#算法流程"},{"categories":["数据结构与算法"],"content":"举例说明1：S=“aabaabaac”, pattern=“aabaac”主串中存在模式串，应该返回起始下标 -3 ![[Pasted image 20230426211149.png]] ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#举例说明1saabaabaac-patternaabaac"},{"categories":["数据结构与算法"],"content":"step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） ![[Pasted image 20230426211316.png]] ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step1-首先定义两个下标-i-和-j分别指向-s-和-pattern-中待比较的字符"},{"categories":["数据结构与算法"],"content":"step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较![[Pasted image 20230426211447.png]] ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:2","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step2-当-si--patternjij-均右移继续往下比较"},{"categories":["数据结构与算法"],"content":"step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移（[[202304262152 KMP 算法之-获取 next 数组]]），具体见下面的场景：![[Pasted image 20230426211653.png]] （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 ![[Pasted image 20230426213140.png]] ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:3","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step3-当-si--patternji-不动j-以一定的模式进行转移202304262152-kmp-算法之-获取-next-数组具体见下面的场景"},{"categories":["数据结构与算法"],"content":"step4 进而继续往下比较![[Pasted image 20230426213209.png]] 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:4","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step4-进而继续往下比较"},{"categories":["数据结构与算法"],"content":"具体实现 func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { // 不想等需要根据前面得到的 next，更新 l // 直到相等或者 l == 0 for l \u003e 0 \u0026\u0026 pat[l] != pat[cur] {l = next[l-1]} if pat[cur] == pat[l] { l++ } next[cur] = l } return next } func KMP(s, pat string) int { n, m := len(s), len(pat) next := getNext(pat) i, j := 0, 0 for i \u003c n \u0026\u0026 j \u003c m { for j \u003e 0 \u0026\u0026 pat[j] != s[i] {j = next[j-1]} if s[i] == pat[j] { j++ } i++ } if j == m { return i - m } else { return -1 } } ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#具体实现"},{"categories":["数据结构与算法"],"content":"一些习题 https://leetcode.cn/problems/repeated-substring-pattern/ 知乎专栏. 《KMP 算法详解》. 见于 2023年4月26日. https://zhuanlan.zhihu.com/p/83334559. 《KMP算法》. 收入 维基百科，自由的百科全书, 2022年7月8日. https://zh.wikipedia.org/w/index.php?title=KMP%E7%AE%97%E6%B3%95\u0026oldid=72556055. ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#一些习题"},{"categories":["数据结构与算法"],"content":"#算法 KMP 算法中 j 的转移是通过一个保存 j 转移信息的数组 next 来实现的，那么如何获得这个数组是 KMP 算法的关键 首先根据 KMP 的工作流程可知，next 中保存的其实是最长公共前后缀的长度，也可以理解为最长公共前后缀中前缀的下一个下标 next[i] 保存了 pattern[0,i] 这个字符串最长公共前后缀的长度 举个例子说明：pattern = “aabaac” ![[Pasted image 20230426220927.png]] 推导过程： 子串 最长公共前后缀 next a 无(长度为1没有前缀与后缀) 0 aa a 1 aab 无 0 aaba a 1 aabaa aa 2 aabaac 无 0 如何在 O(M) 的时间复杂度内获得这个 next 数组？ 使用两个指针，从头开始遍历 pattern： len：记录了最长公共前后缀的长度（初始 0） cur：子串结尾（初始 1） 首先初始化 next[0] = 0，所有的模式串都符合 ![[Pasted image 20230426223405.png]] 判断 pattern[cur] == pattern[len]； 说明存在相同前后缀，那么将 len++，next[cur] = len（说明子串 pattern[0, cur] 的最长公共前缀长度为 len） 再将 cur++，继续判断下一个子串 ![[Pasted image 20230426223414.png]] 当 pattern[cur] != pattern[len] 说明当前的子串是不存在公共前后缀的，那么将 len 重置 len = next[len-1]（找子串[0, len-1]的最大相同前后缀，直到首字符的位置 或者 pattern[len] == pattern[cur]）， end 继续右移动 这个步骤往往是容易出错的，看下面的一个例子 ![[Pasted image 20230426232305.png]] 重复以上过程，直到获取整个 next 数组 ![[Pasted image 20230426223513.png]] 一个错误例子： func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { if pat[cur] == pat[l] { l++ } else { // error l = 0 } next[cur] = l } return next } 测试例： pat=“afdabeafdaf” getNext() = [0 0 0 1 0 0 1 2 3 4 0], want [0 0 0 1 0 0 1 2 3 4 2] 正确实现： func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { // 不相等需要根据前面得到的 next，更新 l // 直到相等或者 l == 0 for l \u003e 0 \u0026\u0026 pat[l] != pat[cur] {l = next[l-1]} if pat[cur] == pat[l] { l++ } next[cur] = l } return next } ","date":"2023-05-09","objectID":"/202304262152-kmp-%E7%AE%97%E6%B3%95%E4%B9%8B-%E8%8E%B7%E5%8F%96-next-%E6%95%B0%E7%BB%84/:0:0","series":["算法"],"tags":[],"title":"KMP算法之-获取next数组","uri":"/202304262152-kmp-%E7%AE%97%E6%B3%95%E4%B9%8B-%E8%8E%B7%E5%8F%96-next-%E6%95%B0%E7%BB%84/#"},{"categories":["数据结构与算法"],"content":"一些题目记录一下","date":"2023-05-09","objectID":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","series":[],"tags":["leetcode"],"title":"leetcode 做题记录 ","uri":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["数据结构与算法"],"content":"#算法 记录一些比较有意义的题目 题目 备注 2023.04.18 119 滚动数组 121 169 map的使用，数组中元素的计数 219 滑动窗口 283 双指针 303 在初始化方法中做预处理操作，减少频繁调用的方法中所做的工作量 414 使用了前面双指针的思路；也可以使用类似滑动窗口的思路，维护一个大小为3的有序集合 488 dfs 2023.04.19 496-下一个更大元素I 单调栈，（Go本身没有栈的库，但是通过数组很方便实现[[202304201957 栈]]） 2023.04.20 506-相对名次 深拷贝[[202304201947 深浅拷贝]]、go基本元素类型的降序排序 561-数组拆分 在于题目的分析，用贪心的方式来分析 556-重塑矩阵 二维数组的一维表示（m*n矩阵的第x个元素坐标：x/n，x%n） 594-最长和谐子序 错太多次了；移动窗口；数组计数，联想下标计数法 2023.04.21 674-最长连续递增序列 滑动窗口 744-寻找比目标字母大的最小字母 二分查找[[202304212107 二分查找]] 746-爬楼梯 动态规划 747 求数组的第一第二大的数 2023.04.22 1027-最长等差数列 动态规划[todo] 2023.04.23 1105-填充书架 动态规划 942-增减字符串匹配 贪心算法 914-卡牌分组 最大公约数 2023.04.24 1163 按字典序排在最后的子串【难】 后缀数组、sa-is算法（[[202304241453 后缀数组与SA-IS算法]]） 2023.04.25 125-验证回文 168-Excel表名称 26进制 2023.04.26 1031-两个非重叠子数组的最大和 动态规划+滑动窗口 综合题目 392-判断子序列 动态规划 459-重复的子字符串 KMP算法 680-验证回文 贪心 2023.04.29 剑指 Offer II 083. 没有重复元素集合的全排列 字典序 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 总结一些分类出来 数组计数 数组找第几 位运算 ","date":"2023-05-09","objectID":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:0:0","series":[],"tags":["leetcode"],"title":"leetcode 做题记录 ","uri":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/#"},{"categories":["数据结构与算法"],"content":"#算法 希望能有成长，在此记录 ","date":"2023-05-09","objectID":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/:0:0","series":["算法"],"tags":[],"title":"Leetcode 周赛记录","uri":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/#"},{"categories":["数据结构与算法"],"content":"我的第一场周赛![[Pasted image 20230430120028.png]] 本着就做两题的心态来的，结果也算是完成了两题，不过过程还是不尽人意，第一道简单题就wa了五次，还是有点小紧张 第二道题思考的有点久，其实就是要在一个乱序的二维数组中快速找到一个数在第几行第几列的需求，如果这些数被保证在一个不大的范围内，那么可以直接做num2Idx[数字]=下标 这样的一个映射，就能快速找到对应数字在二维数组中的下标了 不过结果也还算是符合预期了，再接再厉吧 ","date":"2023-05-09","objectID":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/:0:0","series":["算法"],"tags":[],"title":"Leetcode 周赛记录","uri":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/#我的第一场周赛"},{"categories":["容器"],"content":"#k8s ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#"},{"categories":["容器"],"content":"一、概述operator 对于 k8s 来说，是一种扩展机制，开发人员可以通过 CRD，来扩展 k8s API operator 通过监视和管理 CRD，来执行一系列被预定的操作，这些操作被编写在 reconcile 逻辑里面，通过 CRD 的增加、删除、更新，可以触发不同的逻辑，在这些逻辑里面也可以对 k8s 原有的资源进行操作，比如 pod、configmap、service 等等 对于运维人员来说，operator 也是相当有用的，operator 可以负责用来做一些更高级的操作，比如扩缩容、集群的备份、恢复等操作，可以减轻运维人员的压力 ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#一概述"},{"categories":["容器"],"content":"二、名词解释、Operator 的工作流程","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#二名词解释operator-的工作流程"},{"categories":["容器"],"content":"2.1 名词解释 GroupVersionKind ![[Pasted image 20230508102917.png]] GVK 是用来描述一个 kubernetes api 对象的标准 将 GroupVersionKind 拆分成三个部分来理解： Group Version Kind 在 Kubernetes 环境中可以通过命令查看： kubectl api-resources kubectl explain [kind] ![[Pasted image 20230508103207.png]] ![[Pasted image 20230508103226.png]] GroupVersionResource `GroupVersionResource`和`GroupVersionKind`都是KubernetesAPI中用于标识资源的数据结构，它们之间有一定的关系。`GroupVersionResource`由三个部分组成：`group`、`version`和`resource`。它用于唯一地标识KubernetesAPI中的一个资源，并指定客户端对该资源执行CRUD操作的方式。`GroupVersionKind`也由三个部分组成：`group`、`version`和`kind`。它用于描述KubernetesAPI中的一个对象，其中`kind`表示对象的类型，例如`Pod`、`Service`或`Deployment`。可以看出，`GroupVersionResource`和`GroupVersionKind`的区别在于最后一个部分。`GroupVersionResource`的最后一个部分是资源的名称，而`GroupVersionKind`的最后一个部分是对象的类型。但是，它们都包含了相同的前两个部分：`group`和`version`。这意味着，通过`GroupVersionKind`可以推断出对应的`GroupVersionResource`，反之亦然。因此，`GroupVersionResource`和`GroupVersionKind`是紧密相关的概念，它们都是KubernetesAPI中用于标识资源和对象的重要数据结构。 scheme scheme 提供了 kubernetes api 对象的序列化、反序列化的功能 在 operator 中，scheme 提供了向 kubernetes api 注册自定义对象的功能 所以每个 operator 都需要 scheme，提供了 go type 与 Kind 的映射，operator 才能与kubernetes api 更好的交互 Manager ![[Pasted image 20230508105710.png]] Cache、informer ![[Pasted image 20230508110457.png]] cache负责： 缓存 kubernetes api 对象 版本控制 索引 informer负责： 监听 kubernetes api 中的事件 当 controller 想要访问某个 api 资源，首先查找 cache 中是否存在，如果不存在再往 kuberntes api 中查找，cache 能够减少访问 kuberntes api 的次数，减轻 io 压力 为了保证缓存中的资源与 kuberntes api 中的资源保持一致，informer 需要监听 kubernetes api 中的事件，如果 kuberntes api 中的资源发生改变，cache 中也要同步变化，保证数据一致性 cache 还提供了对象的索引，提高查找效率。由于api 资源对象是具备版本的，因此 cache 也需要提供版本控制的功能，保证与 kuberntes api 中的资源是同一个版本 informer 是基于 cache 完成的一个高级组件，两者相互协作，都是为了让客户端更好的访问api 对象资源，cache主要用来做缓存、版本控制、索引的功能，informer 主要监听 kuberntes api 中的事件，更新缓存中的资源 aa 这边顺便了解一下 ListAndWatch 机制： 与 Informer 类似，ListAndWatch 的作用也是为了让客户端或者控制器更好的获取 k8s 资源，它的大致工作流程如下： 使用 List 操作，从 Kubernetes API 获取全部的资源对象并保存 然后监听 kuberntes api 中的事件，如果对象发生更新，则对自己保存的对象也做相应更新 ","date":"2023-05-09","objectID":"/202305080937-operator/:1:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#21-名词解释"},{"categories":["容器"],"content":"2.2 operator 工作流程例如当一个 CRD 创建，会经过什么样的流程 一个 crd 资源创建，首先 kubernetes api 会监听到这个资源的创建，informer 会从 kuberntes api 收到这个事件，并获取对应的 crd 资源，将这个资源反序列化成对应的 go type，然后触发控制器中的 reconcile 逻辑，完成预定的操作 ![[Pasted image 20230508120012.png]] 动画演示见文尾 crd 创建请求发送到 API Server API Server 校验请求是否合法，是否有创建这个资源的权限 通过 API Server 后，到达准入控制器（Admission Controller），根据 crd 对应的校验规则进行 crd 资源的校验。此外 Admission Controller 还可能对资源进行修改操作 至此，crd 的创建已经被允许，一个 crd 实例被创建，并保存到 etcd 中 Controller Manager 启动对应的 Controller Controller 执行相应的 reconcile 逻辑，会监听 crd 的变化，并执行相应的逻辑 ","date":"2023-05-09","objectID":"/202305080937-operator/:2:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#22-operator-工作流程"},{"categories":["容器"],"content":"三、实践 创建 operator 项目的两个脚手架： kubebuilder OperatorSDK 该实践使用 kubebuilder 来完成，可参考： kubebuilder quick start 环境信息： go1.17.10 kubelet v1.19.4 docker 20.10.12 kubebuilder 3.4.0 kustomize v4.5.4 初始化项目 kubebuilder init --domain example.com --repo demo.domain/demo-operator kubebuilder create api --group demo --version v1 --kind Demo 修改api/v1/xxx_types.go make manifests 会生成对应的 crd yaml 文件 ./ ├── ... ├── config .. ├── crd ├── bases └── demo.example.com_demoes.yaml ![[image-20220531151549217.png]] 构建 operator 镜像 docker build -t 904566722/kubebuilder-demo-operator:1.0.0 . docker push 904566722/kubebuilder-demo-operator:1.0.0 部署 crd make install # $(KUSTOMIZE) build config/crd | kubectl apply -f - 部署 rbac 相关 yaml kubectl apply -f config/rbac/ 创建 manager controller 修改 image 为上面制作的 operator 镜像 kubectl apply -f config/manager/manager.yaml pod 成功运行之后，创建 cr 实例 apiVersion:demo.example.com/v1kind:Demometadata:name:demo-samplespec:size:19type:democonfig_map_name:demo kubectl apply -f config/samples/demo_v1_demo.yaml operator 监听到 Demo kind 资源的创建，出发 reconcile： ![[image-20220531165746637.png]] ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#三实践"},{"categories":["容器"],"content":"参考资料 Kubernetes Operator 开发教程 kustomization管理k8s对象 ![[GIF 2023-5-8 12-12-36.gif]] ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#参考资料"},{"categories":["数据结构与算法"],"content":"#算法 二叉搜索树：左子树所有节点的值 \u003c 根节点 \u003c 右子树所有节点的值 二叉搜索树的相关操作： 构建 判断 删除节点 增加节点 ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":"判断是否是二叉搜索树递归实现 // 递归实现 // 从二叉搜索树当前节点的值可以推出左右节点的取值区间，递归判断每个节点即可 func isValidBST(root *TreeNode) bool { if root == nil { return true } return jud(root, math.MinInt, math.MaxInt) } func jud(root *TreeNode, start, end int) bool { if root == nil { return true } if root.Val \u003c= start || root.Val \u003e= end { return false } return jud(root.Left, start, root.Val) \u0026\u0026 jud(root.Right, root.Val, end) } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#判断是否是二叉搜索树"},{"categories":["数据结构与算法"],"content":"插入节点递归实现 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } if val \u003c root.Val { root.Left = insertIntoBST(root.Left, val) } else { root.Right = insertIntoBST(root.Right, val) } return root } 非递归实现 func insertIntoBST2(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } pre := root tmpRoot := root for tmpRoot != nil { if val \u003c tmpRoot.Val { pre = tmpRoot tmpRoot = tmpRoot.Left } else { pre = tmpRoot tmpRoot = tmpRoot.Right } } newNode := \u0026TreeNode{Val: val} if val \u003c pre.Val { pre.Left = newNode } else { pre.Right = newNode } return root } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#插入节点"},{"categories":["数据结构与算法"],"content":"删除节点 // 如果找到该节点，有四种情况： // 没有左节点，直接将右子树代替该节点的位置 // 没有右节点，直接将左子树代替该节点的位置 // 均有左右节点，根据中序节点的性质，当前的序列为：左子树、当前节点、右子树的最左节点 // 删除当前节点之后，为了保持中序，需要将左子树嫁接到右子树的最左节点的左节点，然后将右子树的根节点替换当前节点的位置 // 均没有左右节点（叶子节点），直接删除该节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } var curParent *TreeNode = nil cur := root for cur != nil \u0026\u0026 cur.Val != key { curParent = cur if key \u003c cur.Val { cur = cur.Left } else { cur = cur.Right } } // not found if cur == nil { return root } if cur.Left != nil \u0026\u0026 cur.Right != nil { rightMinNode := cur.Right for rightMinNode.Left != nil { rightMinNode = rightMinNode.Left } rightMinNode.Left = cur.Left cur = cur.Right } else if cur.Left != nil { cur = cur.Left } else if cur.Right != nil { cur = cur.Right } else { cur = nil } if curParent == nil { return cur } if curParent.Left != nil \u0026\u0026 curParent.Left.Val == key { curParent.Left = cur } else { curParent.Right = cur } return root } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#删除节点"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"后缀数组概念：将 s 的所有后缀排序后的数组 见下面的一个例子： ![[Pasted image 20230424145648.png]] ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#后缀数组"},{"categories":["数据结构与算法"],"content":"从 Go 中获得后缀数组的方法 type Index struct { _ []byte sa []int32 } func lastSubstring3(s string) string { index := suffixarray.New([]byte(s)) idx := (*Index)(unsafe.Pointer(index)) fmt.Println(idx.sa) // s=\"aabaaaab\" output:[3 4 5 0 6 1 7 2] return \"\" } 思考： unsafe.Pointer 的使用 [[202304241708 unsafe.Pointer 的六种使用场景]] 为什么是 (*Index) 这样的写法？ ![[Pasted image 20230424165450.png]] 顺便复习下 struct 结构体（[[202304241633 struct]]） ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#从-go-中获得后缀数组的方法"},{"categories":["数据结构与算法"],"content":"SA-IS 算法概念：（Suffix Array Induce Sort；SA-IS） 参考资料： 《诱导排序与SA-IS算法 - riteme.site》. 见于 2023年4月24日. https://riteme.site/blog/2016-6-19/sais.html. 第一次接触到后缀数组以及SA-IS算法是在leetcode每日一题（1163.按字典序排在最后的字串）中 ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#sa-is-算法"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:0:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#"},{"categories":["数据结构与算法"],"content":"一、基本概念定义：G = (V, E) 图的分类 边是否有方向： 有向图 无向图 图中是否有环： 有环图 无环图 连通图和非连通图 连通图 非连通图 ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:0:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#一基本概念"},{"categories":["数据结构与算法"],"content":"二、图的存储 顺序 链式 五种树的存储方式的比较： 操作 邻接矩阵 边集数组 邻接表 链式前向星 哈希表实现邻接表 图的初始化 n^2 m n+m n+m 查某条边是否存在 1 m TD(vi) TD(vi) 遍历某个点的所有边 n m TD(vi) TD(vi) 遍历整张图 n^2 nm n+m n+m 空间复杂度 n m n+m n+m ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:0:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#二图的存储"},{"categories":["数据结构与算法"],"content":"2.1 邻接矩阵（ 二维数组）","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:1:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#21-邻接矩阵-二维数组"},{"categories":["数据结构与算法"],"content":"2.2 边集数组","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#22-边集数组"},{"categories":["数据结构与算法"],"content":"2.3 邻接表（数组+链式结构） // 邻接点 type AdjNode struct { AdjN int // 邻接点标号 Weight int //顶点到该邻接点的权重 Next *AdjNode } // 顶点 type VNode struct { Val int FirstAdjNode *AdjNode } type Graph struct { VNum int ENum int VNodes []VNode } type Edge struct { V1, V2 int Weight int } func InitGraph(VertexNum int) *Graph { g := \u0026Graph{ VNum: VertexNum, ENum: 0, VNodes: make([]VNode, VertexNum), } //for _, vnode := range g.VNodes { //vnode.Val = //} return g } func InsertEdge(graph *Graph, e *Edge) { v1VNode := graph.VNodes[e.V1-1] // 假设 v1 节点存储在下标 0 的位置 // 新建一个 v2 的邻接点 v2Adj := \u0026AdjNode{ AdjN: e.V2, Weight: e.Weight, Next: v1VNode.FirstAdjNode, } v1VNode.FirstAdjNode = v2Adj // 如果是无向图，还需要添加从 v2 到 v1 的连接 v2VNode := graph.VNodes[e.V2-1] v1Adj := \u0026AdjNode{ AdjN: e.V1, Weight: e.Weight, Next: v2VNode.FirstAdjNode, } v2VNode.FirstAdjNode = v1Adj } func BuildGraph(vnum int, v1s, v2s []int, weight []int) *Graph { graph := InitGraph(vnum) for i := 0; i \u003c len(v1s); i++ { e := \u0026Edge{ V1: v1s[i], V2: v2s[i], Weight: weight[i], } InsertEdge(graph, e) } return graph } func test1() { vnum := 4 v1s := []int{1,1,3,1} v2s := []int{2,3,4,4} weights := []int{1,2,3,4} graph := BuildGraph(vnum, v1s, v2s, weights) for i, vnode := range graph.VNodes { adj := vnode.FirstAdjNode for adj != nil { fmt.Printf(\"(%d,%d) 权重 %d \\n\",i+1, adj.AdjN, adj.Weight) adj = adj.Next } } } ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#23-邻接表数组链式结构"},{"categories":["数据结构与算法"],"content":"2.4 链式前向星（数组+静态链表）","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:4:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#24-链式前向星数组静态链表"},{"categories":["数据结构与算法"],"content":"2.5 哈希表实现邻接表","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:5:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#25-哈希表实现邻接表"},{"categories":["数据结构与算法"],"content":"三、图的遍历","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:0:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#三图的遍历"},{"categories":["数据结构与算法"],"content":"3.1 DFS","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:1:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#31-dfs"},{"categories":["数据结构与算法"],"content":"3.2 BFS","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#32-bfs"},{"categories":["容器"],"content":"#k8s ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:0:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#"},{"categories":["容器"],"content":"一、环境准备 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 关闭 selinux sed -i 's/enforcing/disabled/' /etc/selinux/config 关闭 swap sed -ri 's/.*swap.*/#\u0026/' /etc/fstab 添加 hosts cat \u003e\u003e /etc/hosts \u003c\u003c EOF 192.168.108.132 centos7-master 192.168.108.130 centos7-node1 EOF 设置网桥参数 cat \u003e /etc/sysctl.d/k8s.conf \u003c\u003c EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system # 生效 时间同步 yum install ntpdate -y # 没有的 ntpdate 则安装 ntpdate time.windows.com # 同步时间 ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:0:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#一环境准备"},{"categories":["容器"],"content":"二、安装 安装 Docker、kubeadm、kubelet、kubectl Docker 安装 wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo # 更新 docker 的 yum 源 yum install docker-ce-19.03.13 -y 配置镜像 mkdir /etc/docker cat \u003c\u003c EOF \u003e /etc/docker/daemon.json { \"registry-mirrors\": [\"https://kfwkfulq.mirror.aliyuncs.com\"] } EOF systemctl enable docker.service 添加 k8s 的yum源 cat \u003e /etc/yum.repos.d/kubernetes.repo \u003c\u003c EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 安装 kubeadm、kubelet、kubectl yum install kubelet-1.19.4 kubeadm-1.19.4 kubectl-1.19.4 -y systemctl enable kubelet.service # 开启服务 重启 centos 部署 master 节点 kubeadm init --apiserver-advertise-address=【master服务器ip地址】 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.19.4 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 添加 node 节点 kubeadm join 192.168.108.132:6443 --token d99d8g.3wr8skktnv3m9e46 \\ --discovery-token-ca-cert-hash sha256:0ba36403007aa7ef77b174a65a8e3de27bcbcac9fbb5b2bb31c337a565d4e16 部署网络插件 wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl apply -f kube-flannel.yml ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:0:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#二安装"},{"categories":["数据结构与算法"],"content":"#算法 复习一下基本的排序算法 有几种基本的排序算法： 冒泡排序 选择排序 插入排序 希尔排序（递减增量的排序；插入排序的改进版本） 归并排序 快速排序 桶排序 堆排序 计数排序 基数排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"冒泡步骤： 一直往前走，比较相邻两个数，大数往后放 ![[bubbleSort.gif]] func bubbleSort(nums []int) { if len(nums) \u003c= 1 { return } // nums: 6 10 2 4 7 3 2 1 2 // loop1 j (loop2每进行一轮往前移，直到1) // loop2 i for j := len(nums)-1; j \u003e= 1; j--{ for i := 0; i \u003c j; i++ { if nums[i] \u003e nums[i+1] { swap(\u0026nums[i], \u0026nums[i+1]) } } } } 时间复杂度分析：O(n^2) 第一轮比较 n-1 次 第二轮比较 n-2 次 …. 第n-1轮比较 1 次 1 + 2 + … + (n-1) = n (n-1 + 1) / 2 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#冒泡"},{"categories":["数据结构与算法"],"content":"选择排序步骤： 每次从未排序找最小 ![[selectionSort.gif]] func selectSort(nums []int) { for i := 0; i \u003c len(nums)-1; i++ { minIdx := i for j := i+1; j \u003c len(nums); j++ { if nums[j] \u003c nums[i] { minIdx = j } } swap(\u0026nums[i], \u0026nums[minIdx]) } } 时间复杂度也是 O(n^2) ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序"},{"categories":["数据结构与算法"],"content":"插入排序步骤： 从已排序找合适的位置 ![[insertionSort.gif]] func insertSort(nums []int) { // nums 1 2 5 3 4 // i (i极其右边为一个 未排序的序列) // j=i-1 (j 负责往前找大于等于cur的值) for i := 1; i \u003c len(nums); i++ { cur := nums[i] j := i-1 for ; j\u003e=0 \u0026\u0026 nums[j]\u003ecur; j-- { nums[j+1] = nums[j] } // 由于 j 当前的位置小于或者等于cur or 越界 // 故把前面一个位置，给到cur（前面的数已经往前前的位置移动） nums[j+1] = cur } } ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序"},{"categories":["数据结构与算法"],"content":"归并排序[[202304300231 归并排序]] ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#归并排序"},{"categories":["数据结构与算法"],"content":"快速排序[[202304300312 快速排序]] ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#快速排序"},{"categories":["数据结构与算法"],"content":"#算法 用途：给定一个数组，返回基于字典序的下一个数组排列 四个步骤： 找上坡 找大于且最小 交换 倒序 Go 实现： func nextDicArr(nums []int) []int { if len(nums) \u003c= 1 { return } pos := -1 for i := len(nums)-2; i \u003e= 0; i-- { if nums[i] \u003c nums[i+1] { pos = i break } } // 没找到上坡（左值小于右值），说明已经是降序排列 if pos == -1 { for i,n := 0,len(nums); i \u003c n/2; i++ { nums[i], nums[n-i-1] = nums[n-i-1], nums[i] } return nums } // 找到 pos，接着找右边大于该值的最小值（也就是第一个大于标记的值） biggerThanPos := -1 for i := len(nums)-1; i \u003e= pos+1; i-- { if nums[i] \u003e nums[pos] { biggerThanPos = i break } } nums[pos], nums[biggerThanPos] = nums[biggerThanPos], nums[pos] // 剩下的倒序 for i,n,cnt := pos+1, len(nums),0; i \u003c (n + pos+1)/2; i++ { nums[i], nums[n-cnt-1] = nums[n-cnt-1], nums[i] cnt++ } return nums } 习题练习： https://leetcode.cn/problems/VvJkup/ 《字典序算法详解_HappyRocking的博客-CSDN博客》. 见于 2023年4月29日. https://blog.csdn.net/HappyRocking/article/details/83619392. ","date":"2023-05-09","objectID":"/202304290644-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"字典序算法","uri":"/202304290644-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#"},{"categories":["数据结构与算法"],"content":"归并排序的思想归并排序是一种采用了递归思想的排序，采用递归[[202304300007 递归]]的思想来分析就是： 原问题 \u0026 解决方法 原问题：将 nums 排序 解决办法：将数组 nums 分成两个序列 nums1、nums2，将 nums1、nums2 排序后合并 子问题 \u0026 解决方法 子问题：将 nums1、nums2 排序 解决办法：两个子数组都能够通过原问题的解决办法解决 结束条件：当数组不能再划分（长度=1） 时间复杂度： 合并的平均时间复杂度O(n) x 拆分的深度 logn = O(nlogn) ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#归并排序的思想"},{"categories":["数据结构与算法"],"content":"实现Golang： // 1. 定义方法：将左右两个已经有序的序列合并成一个序列（原问题得解：原数组有序） // 2. 子问题：左右的数组需要有序，与原问题解决方法相同 // 3. 结束条件：数组的长度为 1 func mergeSort(nums []int) []int { // 结束条件 if len(nums) \u003c= 1 { return nums } // 子问题关系 mid := len(nums) / 2 left := mergeSort(nums[:mid]) right := mergeSort(nums[mid:]) // 方法定义 return merge(left, right) } // 将两个有序数组合并 func merge(nums1, nums2 []int) []int { n1, n2 := len(nums1), len(nums2) nums := make([]int, n1 + n2) i, j, idx := 0, 0, 0 for i \u003c n1 \u0026\u0026 j \u003c n2 { if nums1[i] \u003c nums2[j] { nums[idx] = nums1[i] i++ } else { nums[idx] = nums2[j] j++ } idx++ } for ; i \u003c n1; i++ { nums[idx] = nums1[i] idx++ } for ; j \u003c n2; j++ { nums[idx] = nums2[j] idx++ } return nums } 1.《图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园》. 见于 2023年4月30日. https://www.cnblogs.com/chengxiao/p/6194356.html. ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#实现"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#"},{"categories":["数据结构与算法"],"content":"快速排序的思想快速排序采用了分治的思想，可以通过递归来实现 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的思想"},{"categories":["数据结构与算法"],"content":"步骤 原问题 \u0026 解决办法 原问题：nums 数组排序 解决办法：选一个元素作为基准，将小于基准的数放到左边，大于基准的数放到右边（分区间） 子问题 \u0026 解决办法 子问题：左右区间的排序 解决办法：同原问题 结束条件：数组只有一个元素 ![[微信图片_20230430032831.jpg]] ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#步骤"},{"categories":["数据结构与算法"],"content":"实现 // nums 数组排序 func quickSort(nums []int, start, end int) { // 结束条件 if start \u003e= end { return } // 子问题关系 pivot := partition(nums, start, end) quickSort(nums, start, pivot) quickSort(nums, pivot+1, end) return } func partition(nums []int, start, end int) int { if start == end { } pivot := start idx := start + 1 for i := start+1; i \u003c= end; i++ { if nums[i] \u003c nums[pivot] { swap(\u0026nums[i], \u0026nums[idx]) idx++ } } swap(\u0026nums[pivot], \u0026nums[idx-1]) return idx-1 } 《1.6 快速排序 | 菜鸟教程》. 见于 2023年4月30日. https://www.runoob.com/w3cnote/quick-sort-2.html. ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#实现"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":"一些基本概念https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/ 树四度： 度 节点的度：节点拥有的子节点数量 树的度：节点的度的最大值 深度：根节点到当前节点的距离 高度：根节点到最低节点的距离 树的实际应用： 帮助分析时间复杂度 搜索 排序 路径查找 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#一些基本概念"},{"categories":["数据结构与算法"],"content":"几种常见的树 二叉树 满二叉树 完全二叉树 二叉搜索树 [[202305040442 二叉搜索树]] 平衡二叉搜索树 线段树 平衡树 B 树 红黑树 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#几种常见的树"},{"categories":["数据结构与算法"],"content":"树的遍历方式深度：前序（DLR）、中序（LDR）、后序（LRD） 广度：层序遍历 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#树的遍历方式"},{"categories":["数据结构与算法"],"content":"前序遍历用递归的思想可以将问题看作： 访问跟节点 前序遍历左节点 前序遍历右节点 // 前序遍历: 访问根节点，以前序遍历的方式访问左节点，以前序遍历的方式访问右节点 func pOrder(root *treeNode) { // end if root == nil { return } fmt.Printf(\"%d \", root.val) pOrder(root.left) pOrder(root.right) return } 使用栈实现： 将根节点入栈 出栈，加入右节点跟左节点 重复以上操作，直到栈空 func pOrderStack(root *treeNode) { if root == nil { return } var st []*treeNode st = append(st, root) var pnt []int for len(st) \u003e 0 { // pop cur := st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, cur.val) // judge left\\right if cur.right != nil { st = append(st, cur.right) } if cur.left != nil { st = append(st, cur.left) } } fmt.Println(pnt) } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:1:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#前序遍历"},{"categories":["数据结构与算法"],"content":"中序遍历递归实现： // 按中序遍历访问左节点，访问节点元素，按中序遍历访问右节点 func ldrOrder(root *treeNode) { if root == nil { return } ldrOrder(root.left) fmt.Printf(\"%d \", root.val) ldrOrder(root.right) return } 栈实现： 从根节点开始入栈，一直往左，直到最左叶子节点 出栈，访问节点 将右节点当作步骤1的根节点（若存在） func ldrOrderStack(root *treeNode) { if root == nil { return } var st []*treeNode cur := root // 找到最左叶子节点 for cur != nil { st = append(st, cur) cur = cur.left } // 出栈，访问元素 // 如果存在右节点，继续入栈，直到最左叶子节点 var pnt []int for len(st) \u003e 0 { cur := st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, cur.val) tmp := cur.right for tmp != nil { st = append(st, tmp) tmp = tmp.left } } return } // 代码优化 func ldrOrderStack2(root *treeNode) { if root == nil { return } var st []*treeNode // 出栈，访问元素 // 如果存在右节点，继续入栈，直到最左叶子节点 var pnt []int tmp := root for len(st) \u003e 0 || tmp != nil { // 入栈直到最左节点 for tmp != nil { st = append(st, tmp) tmp = tmp.left } // 出栈，访问节点元素 tmp = st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, tmp.val) // 继续找右节点的最左叶子节点 tmp = tmp.right } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:2:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#中序遍历"},{"categories":["数据结构与算法"],"content":"后续遍历递归实现： func lrdOrder(root *treeNode) { if root == nil { return } lrdOrder(root.left) lrdOrder(root.right) fmt.Printf(\"%d \", root.val) return } 栈实现： 从根节点开始入栈，直到最左节点 获取栈顶，判断右节点 右节点不存在：访问该节点，出栈 右节点已经访问过：访问该节点，出栈 右节点未访问，进入步骤3 将该右节点当作步骤1的根节点 func lrdOrderStack(root *treeNode) { var st []*treeNode tmpRoot := root pre := root for len(st) \u003e 0 || tmpRoot != nil { for tmpRoot != nil { st = append(st, tmpRoot) tmpRoot = tmpRoot.left } tmpRoot = st[len(st)-1] // 当节点右节点为空 或者 右子树已经访问过的情况下，访问根节点 if tmpRoot.right == nil || tmpRoot.right == pre { fmt.Printf(\"%d \", tmpRoot.val) pre = tmpRoot tmpRoot = nil // 将当前节点标记为空，避免下一个循环又将该节点入栈 st = st[:len(st)-1] } else { // 右节点还没访问，后序遍历右节点 tmpRoot = tmpRoot.right } } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#后续遍历"},{"categories":["数据结构与算法"],"content":"层序遍历层序遍历使用队列实现： func levelOrder(root *treeNode) { if root == nil { return } var queue []*treeNode queue = append(queue, root) for len(queue) \u003e 0 { cur := queue[0] queue = queue[1:] fmt.Printf(\"%d \", cur.val) if cur.left != nil { queue = append(queue, cur.left) } if cur.right != nil { queue = append(queue, cur.right) } } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:4:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#层序遍历"},{"categories":["数据结构与算法"],"content":"遍历的复杂度 遍历 时间复杂度 空间复杂度 先序 O(n) 递归调用的时间复杂度为O(1)，递归调用的次数为数中节点的数量n 栈实现的空间复杂度为：O(h) h为数的高度 在较差的情况下，h = n；如果是平衡二叉树，h = logn 中序 O(n) 同上 后序 O(n) 同上 层序 O(n) O(w) w 为树的宽度 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:5:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#遍历的复杂度"},{"categories":["数据结构与算法"],"content":"树的一些常见问题[[202305021918 树问题-路径求和]] 《02.二叉树的遍历知识》. 见于 2023年4月30日. https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/. ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#树的一些常见问题"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:0:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":"方法1. 递归子问题是：判断左右子树是否会等于预期的子树（判断左右子树是否相等的问题也可以递归来实现） // 判断根节点为起始的树与目标树是否相同 // 如果不相同，递归判断左子树和右子树 func isSubtree(root *TreeNode, subRoot *TreeNode) bool { if root == nil \u0026\u0026 subRoot == nil { return true } if root == nil { return false } if isSameTree(root, subRoot) { return true } return isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot) } func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026\u0026 q == nil { return true } if p == nil || q == nil { return false } if p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026\u0026 isSameTree(p.Right, q.Right) } ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:0:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#方法1-递归"},{"categories":["数据结构与算法"],"content":"方法2. dfs（先序） + kmp[[202304262036 KMP 算法]]设主树s，子树t，主树的先序序列 ss，子树的先序序列 tt 利用先序序列的性质： 如果A.【 t 是 s 的子树】 那么B.【ss 中 包含 tt】 可以知道 B 是 A 的必要条件，是没有办法从 B 推出 A 的，原因是什么呢，假设主树：[4, 5]，子树：[4, nil, 5]，这种情况下的先序序列都是 4 5，但是两颗树是不一样的 但是我们可以通过补充两个代表空的左右节点来解决这个问题 // 通过树的先序遍历 // 补充树的每个节点，让度为2，输出树的先序遍历 // 判断主树的序列包含子树的序列 func isSubtree2(root *TreeNode, subRoot *TreeNode) bool { nums1 := dlrNums(root) nums2 := dlrNums(subRoot) return kmpSearch(nums1, nums2) } const lrNilVal = -10001 var leftNilNode = TreeNode{ Val: lrNilVal, } var rightNilNode = TreeNode{ Val: lrNilVal, } func dlrNums(root *TreeNode) []int { var nums []int if root == nil { return nums } var st []*TreeNode st = append(st, root) tmpRoot := root for len(st) \u003e 0 { // pop tmpRoot = st[len(st) - 1] st = st[:len(st) - 1] // visit nums = append(nums, tmpRoot.Val) if tmpRoot.Val != lrNilVal \u0026\u0026 tmpRoot.Left == nil { tmpRoot.Left = \u0026leftNilNode } if tmpRoot.Val != lrNilVal \u0026\u0026 tmpRoot.Right == nil { tmpRoot.Right = \u0026rightNilNode } if tmpRoot.Right != nil { st = append(st, tmpRoot.Right) } if tmpRoot.Left != nil { st = append(st, tmpRoot.Left) } } return nums } // i // nums a a b a a b a a c // pat // j func kmpSearch(nums, pat []int) bool { next := getNext(pat) j := 0 for i := 0; j \u003c len(pat) \u0026\u0026 i \u003c len(nums); i++ { for ; j \u003e 0 \u0026\u0026 nums[i] != pat[j]; j = next[j-1]{} if nums[i] == pat[j] { j++ } } return j == len(pat) } func getNext(pat []int) []int { next := make([]int, len(pat)) next[0] = 0 for l, j := 0, 1 ; j \u003c len(pat); j++ { for l \u003e 0 \u0026\u0026 pat[l] != pat[j] {l = next[l-1]} if pat[l] == pat[j] { l++ } next[j] = l } return next } ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:0:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#方法2-dfs先序--kmp202304262036-kmp-算法"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:0:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#"},{"categories":["数据结构与算法"],"content":"方法一、使用广度优先搜索（层次遍历）思路： 二叉树的层次遍历使用一个队列来保存每一层的节点，再增加一个队列，用来保存从根节点到当前节点的路径上的和 ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:0:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#方法一使用广度优先搜索层次遍历"},{"categories":["数据结构与算法"],"content":"方法二、递归思路： 原问题：是否存在从当前节点（根节点）到叶子节点的路径，和为 sum 子问题：是否存在从当前节点（根节点的子节点）到叶子节点的路径，和为 sum - val（父节点的值） 结束条件：当前节点为叶子节点 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } return havePathToLeaf(root, targetSum) } func havePathToLeaf(root *TreeNode, tgtSum int) bool { // end if root.Left == nil \u0026\u0026 root.Right == nil { return root.Val == tgtSum } have1, have2 := false, false if root.Left != nil { have1 = havePathToLeaf(root.Left, tgtSum - root.Val) } if root.Right != nil { have2 = havePathToLeaf(root.Right, tgtSum - root.Val) } return have1 || have2 } ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:0:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#方法二递归"},{"categories":["测试"],"content":"标题1一张图片 ","date":"2023-05-09","objectID":"/test.md/:1:0","series":[],"tags":[],"title":"测试-图片资源","uri":"/test.md/#标题1"},{"categories":["测试"],"content":"标题2引用一个文档： test2.md ","date":"2023-05-09","objectID":"/test.md/:2:0","series":[],"tags":[],"title":"测试-图片资源","uri":"/test.md/#标题2"},{"categories":["数据结构与算法"],"content":"#算法 递归能够解决的问题的特点： 原问题能够分解成一个更小的与原问题解决思路相同的子问题 递归的步骤： 拆分问题，找使用子问题解决原问题的方法（原问题与子问题的关系） 找子问题的解决方法，当与原问题的解决方法一致，便能够递归 结束的条件 时间复杂度 可以将编码的过程总结为： 1. 定义方法 2. 写明结束条件 3. 根据原问题、子问题之间的逻辑关系写主要的递归逻辑 递归存在的问题： 栈溢出 重复计算 递归练习题： ","date":"2023-05-09","objectID":"/202304300007-%E9%80%92%E5%BD%92/:0:0","series":["算法"],"tags":[],"title":"递归","uri":"/202304300007-%E9%80%92%E5%BD%92/#"},{"categories":["容器"],"content":"#k8s #问题定位 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:0:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#"},{"categories":["容器"],"content":"问题现场![[Untitled-16527874479231.png]] kubectl -n product-ebs get pod -o wide | grep vtype-xxx 扎到了一个状态为 Evicted 的 pod ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:0:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#问题现场"},{"categories":["容器"],"content":"问题分析通过现场可以看到 pod 原先的节点，所以可以查看一下节点的日志 ![[Untitled 1-16527874479242.png]] 接着就发现了节点有磁盘压力，kubelet 主动终止 pod 以回收节点上的资源，以此来保证节点的稳定 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:0:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#问题分析"},{"categories":["容器"],"content":"学习","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:0:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#学习"},{"categories":["容器"],"content":"可能导致节点压力的因素有什么cpu、内存、磁盘空间… ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:1:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#可能导致节点压力的因素有什么"},{"categories":["容器"],"content":"kubelet 是如何做出驱逐的决定的openai: 1. 分析这个问题的步骤： 回答这个问题需要了解 Kubernetes 中 kubelet 组件以及 Eviction API，再结合节点资源使用情况等因素来判断是否要驱逐 Pod。具体的分析步骤如下： - 了解 Kubernetes 中 kubelet 组件和 Eviction API 的作用和原理。 - 确认 kubelet 是否开启了 Eviction 功能。 - 判断当前节点资源（如内存、CPU、磁盘空间）使用情况是否达到了预定义的阈值，若达到或超出，则根据优先级逻辑对 Pod 进行驱逐操作。 2. 产生这个问题的原因： 在 Kubernetes 下，由于各种原因（如资源紧缺，节点故障等），kubelet 可能会决定驱逐一些 Pod 以保证集群正常运转，因此了解 kubelet 决策的原因和方式对于提高 Kubernetes 集群的稳定性和安全性非常重要。 3. 这个问题的答案： kubelet 驱逐 Pod 是通过以下步骤进行的： 4. kubelet 定期与 kube-apiserver 通信，获取当前 Node 上的 Pod 列表信息。 5. kubelet 根据容器的 QoS 类别（Guaranteed \u003e Burstable \u003e BestEffort） 和优先级（pod priority/Preemption）进行排序。（Preemption 时过程中，kubelet 不会限制一些特定 Pod 从来不被驱逐。） 6. kubelet 判断当前 Node 是否处于 out of memory 或者 DiskPressure 的状态，如果是的话，则使用相应的 Eviction API 驱逐 Pod。 7. 如果还没有达到阈值，则尝试驱逐优先级最低的 Pod。如果此时节点有足够的资源可供使用，则该操作不会执行。否则，kubelet 将继续驱逐优先级下一个较低的 Pod 直到可以保证目标阈值。 8. 如果使用上述步骤无法满足 Eviction 要求（如Pod 强占资源），kubelet 可能会强制删除其他 Pod 以便为当前占用的 Pod 腾出资源。 需要注意的是，kubelet 是被动的进行驱逐操作的，即只有在当前节点资源使用情况达到或超过了预设的阈值时才会进行驱逐，而这些阈值可以通过修改 Kubernetes 集群中的参数来调整。 容器的 QoS： kubectl describe pod \u003cpod-name\u003e | grep QoS 该命令会列出 Pod 的详细信息，并在结果中搜索 QoS 相关的部分。 Kubernetes 中的 QoS (Quality of Service) 是一个特性，它用来管理节点上运行的 Pod 的资源分配和调度。在 Kubernetes 中，QoS 有三种级别： Guaranteed：这种类型的 Pod 被保证能够获得所请求的 CPU 和内存资源。如果节点上的资源不足，优先级较低的 Pod 将被暂停或驱逐。 Burstable：这种类型的 Pod 具有最小的 CPU 和内存要求，但可以在需要时进行扩展，以获得更多资源。当节点上的资源不足时，Burstable Pod 可能会受到限制，但不会被完全暂停或驱逐。 BestEffort：这种类型的 Pod 不会被保证任何资源。它们将尽力在节点上占用尽可能少的资源，并且在节点资源不足时首先被削减或删除。 QoS 主要的作用是帮助 Kubernetes 管理资源，确保相同级别的 Pod 在节点上得到公平的资源分配，并且在资源不足的情况下，根据其级别的不同，采取适当的措施以保持节点的健康状态。 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:2:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#kubelet-是如何做出驱逐的决定的"}]