# 通道使用场景

<!--more-->
#


## 采用最快回应

从多个数据源获取数据，只需采用最快的回应，并舍弃其他较慢的回应

N 个数据源，防止被舍弃的其他协程永久阻塞，通道应该是一个容量至少为 N-1 的缓冲通道

```go
func source(c chan<- int32) {
	ra, rb := rand.Int31(), rand.Intn(3) + 1
	// 睡眠1秒/2秒/3秒
	time.Sleep(time.Duration(rb) * time.Second)
	c <- ra
}

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要

	startTime := time.Now()
	c := make(chan int32, 5) // 必须用一个缓冲通道
	for i := 0; i < cap(c); i++ {
		go source(c)
	}
	rnd := <- c // 只有第一个回应被使用了
	fmt.Println(time.Since(startTime))
	fmt.Println(rnd)
}
```

阅读了下面的 `尝试机制` 后，最快回应还可以这么来实现：
```go {hl_lines=["5-8"]}
func source(c chan<- int32) {
	ra, rb := rand.Int31(), rand.Intn(3)+1
	// 休眠1秒/2秒/3秒
	time.Sleep(time.Duration(rb) * time.Second)
	select {
	case c <- ra:
	default:
	}
}

func main() {
	rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要

	c := make(chan int32, 1) // 此通道容量必须至少为1
	for i := 0; i < 5; i++ {
		go source(c)
	}
	rnd := <-c // 只采用第一个成功发送的回应数据
	fmt.Println(rnd)
}
```

## 单对单通知

```go
func main() {
	values := make([]byte, 32 * 1024 * 1024)
	if _, err := rand.Read(values); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	done := make(chan struct{}) // 也可以是缓冲的

	// 排序协程
	go func() {
		sort.Slice(values, func(i, j int) bool {
			return values[i] < values[j]
		})
		done <- struct{}{} // 通知排序已完成
	}()

	// 并发地做一些其它事情...

	<- done // 等待通知
	fmt.Println(values[0], values[len(values)-1])
}
```

通过 `done <- struct{}{}` 往 done 通道发送数据来表示协程的计算已经完成（也可以使用接收的方式来通知，不过使用的比较少）

## 多对单、单对多通知（较少使用的代码片段）

```go
type T = struct{}

func worker(id int, ready <-chan T, done chan<- T) {
	<-ready // 阻塞在此，等待通知
	log.Print("Worker#", id, "开始工作")
	// 模拟一个工作负载。
	time.Sleep(time.Second * time.Duration(id+1))
	log.Print("Worker#", id, "工作完成")
	done <- T{} // 通知主协程（N-to-1）
}

func main() {
	log.SetFlags(0)

	ready, done := make(chan T), make(chan T)
	go worker(0, ready, done)
	go worker(1, ready, done)
	go worker(2, ready, done)

	// 模拟一个初始化过程
	time.Sleep(time.Second * 3 / 2)
	// 单对多通知
	ready <- T{}; ready <- T{}; ready <- T{}
	// 等待被多对单通知
	<-done; <-done; <-done
}
```

不过多对单的通知通常会使用 `sync.WaitGroup` 来实现

## 通过关闭通道来实现群发通知

```go
...
	close(ready) // 群发通知
...
```

## 定时通知

```go
func AfterDuration(d time.Duration) <- chan struct{} {
	c := make(chan struct{}, 1)
	go func() {
		time.Sleep(d)
		c <- struct{}{}
	}()
	return c
}

func main() {
	fmt.Println("Hi!")
	<- AfterDuration(time.Second)
	fmt.Println("Hello!")
	<- AfterDuration(time.Second)
	fmt.Println("Bye!")
}
```

也就是 `<-time.After()`

## 将通道用做互斥锁（mutex）

- 效率不如 `sync` 来得高
- 通道的容量必须为 1

```go {hl_lines=[3,5,12]}
func increase1000(v *int, mutex chan struct{}) {  
   for i := 0; i < 1000; i++ {  
      mutex <- struct{}{} // 往通道发送数据获取锁，由于通道的容量为 1，其他协程发送数据的时候进入阻塞状态  
      *v++  
      <- mutex   // 释放锁  
   }  
   wg.Done()  
}  
  
func main() {  
   cnt := 0  
   mutex := make(chan struct{}, 1)  
  
   wg.Add(2)  
   go increase1000(&cnt, mutex)  
   go increase1000(&cnt, mutex)  
  
   wg.Wait()  
   fmt.Println(cnt)  
}
```

## 将通道用作计数信号量（counting semaphore）-常用来限制最大并发数

- 计数信号量可被视为多主锁
- 假设缓冲通道的容量为 `N`，那么可以将这个通道看作`同一时刻最多可以有 N 个主人`的锁

举例一个场景：一个酒吧，拥有 10 个座位，同一时刻最多只能有 10 个人在喝酒，其他人只能等待

**代码实现：**
```go {hl_lines=[3,7,14]}
func cusEvent(cusNo int, seat chan int)  {  
   log.Println("顾客#", cusNo, "进入酒吧")  
   chairNo := <- seat // 获得一张椅子  
   log.Println("\t\t顾客#", cusNo, "在", chairNo, "号椅子上开始喝酒")  
   time.Sleep(time.Second * 1)  
   log.Println("\t\t\t\t顾客#", cusNo, "离开了酒吧")  
   seat <- chairNo    // 顾客动作完成，让出椅子  
   wg.Done()  
}  
  
func main() {  
   // 创建一个 10 容量的缓冲通道，用来代表 10 个座位  
   // 通道的值 -- 椅子的编号  
   seat := make(chan int, 10)  
   for i := 0; i < cap(seat); i++ {  
      seat <- i + 1  
   }  
  
   // 模拟有 50 个客人进入酒吧  
   for i := 0; i < 30; i++ {  
      wg.Add(1)  
      go cusEvent(i+1, seat)  
   }  
   wg.Wait()  
}
```

上面程序的输出可能为：
```txt
2023/05/20 18:25:32 顾客# 1 进入酒吧
2023/05/20 18:25:32 		顾客# 1 在 1 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 2 进入酒吧
2023/05/20 18:25:32 顾客# 11 进入酒吧
2023/05/20 18:25:32 		顾客# 11 在 3 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 4 进入酒吧
2023/05/20 18:25:32 		顾客# 4 在 4 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 5 进入酒吧
2023/05/20 18:25:32 		顾客# 5 在 5 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 6 进入酒吧
2023/05/20 18:25:32 		顾客# 6 在 6 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 7 进入酒吧
2023/05/20 18:25:32 		顾客# 7 在 7 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 8 进入酒吧
2023/05/20 18:25:32 		顾客# 8 在 8 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 9 进入酒吧
2023/05/20 18:25:32 		顾客# 9 在 9 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 10 进入酒吧
2023/05/20 18:25:32 		顾客# 10 在 10 号椅子上开始喝酒
2023/05/20 18:25:32 顾客# 17 进入酒吧
2023/05/20 18:25:32 顾客# 12 进入酒吧
2023/05/20 18:25:32 顾客# 13 进入酒吧
2023/05/20 18:25:32 顾客# 14 进入酒吧
2023/05/20 18:25:32 顾客# 15 进入酒吧
2023/05/20 18:25:32 顾客# 16 进入酒吧
2023/05/20 18:25:32 顾客# 20 进入酒吧
2023/05/20 18:25:32 顾客# 18 进入酒吧
2023/05/20 18:25:32 顾客# 19 进入酒吧
2023/05/20 18:25:32 顾客# 22 进入酒吧
2023/05/20 18:25:32 顾客# 21 进入酒吧
2023/05/20 18:25:32 顾客# 24 进入酒吧
2023/05/20 18:25:32 顾客# 23 进入酒吧
2023/05/20 18:25:32 顾客# 25 进入酒吧
2023/05/20 18:25:32 顾客# 26 进入酒吧
2023/05/20 18:25:32 顾客# 3 进入酒吧
2023/05/20 18:25:32 顾客# 27 进入酒吧
2023/05/20 18:25:32 顾客# 28 进入酒吧
2023/05/20 18:25:32 顾客# 29 进入酒吧
2023/05/20 18:25:32 顾客# 30 进入酒吧
2023/05/20 18:25:32 		顾客# 2 在 2 号椅子上开始喝酒
2023/05/20 18:25:33 				顾客# 2 离开了酒吧
2023/05/20 18:25:33 				顾客# 11 离开了酒吧
2023/05/20 18:25:33 				顾客# 9 离开了酒吧
2023/05/20 18:25:33 				顾客# 7 离开了酒吧
2023/05/20 18:25:33 				顾客# 8 离开了酒吧
2023/05/20 18:25:33 				顾客# 10 离开了酒吧
2023/05/20 18:25:33 				顾客# 4 离开了酒吧
2023/05/20 18:25:33 		顾客# 17 在 2 号椅子上开始喝酒
2023/05/20 18:25:33 				顾客# 5 离开了酒吧
2023/05/20 18:25:33 				顾客# 1 离开了酒吧
2023/05/20 18:25:33 		顾客# 19 在 1 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 15 在 8 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 14 在 7 号椅子上开始喝酒
2023/05/20 18:25:33 				顾客# 6 离开了酒吧
2023/05/20 18:25:33 		顾客# 13 在 9 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 12 在 3 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 16 在 10 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 20 在 4 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 18 在 5 号椅子上开始喝酒
2023/05/20 18:25:33 		顾客# 22 在 6 号椅子上开始喝酒
2023/05/20 18:25:34 				顾客# 19 离开了酒吧
2023/05/20 18:25:34 				顾客# 20 离开了酒吧
2023/05/20 18:25:34 				顾客# 13 离开了酒吧
2023/05/20 18:25:34 		顾客# 23 在 9 号椅子上开始喝酒
2023/05/20 18:25:34 		顾客# 21 在 1 号椅子上开始喝酒
2023/05/20 18:25:34 				顾客# 15 离开了酒吧
2023/05/20 18:25:34 		顾客# 25 在 8 号椅子上开始喝酒
2023/05/20 18:25:34 				顾客# 22 离开了酒吧
2023/05/20 18:25:34 		顾客# 26 在 6 号椅子上开始喝酒
2023/05/20 18:25:34 				顾客# 18 离开了酒吧
2023/05/20 18:25:34 		顾客# 3 在 5 号椅子上开始喝酒
2023/05/20 18:25:34 				顾客# 17 离开了酒吧
2023/05/20 18:25:34 		顾客# 27 在 2 号椅子上开始喝酒
2023/05/20 18:25:34 				顾客# 14 离开了酒吧
2023/05/20 18:25:34 				顾客# 12 离开了酒吧
2023/05/20 18:25:34 				顾客# 16 离开了酒吧
2023/05/20 18:25:34 		顾客# 29 在 3 号椅子上开始喝酒
2023/05/20 18:25:34 		顾客# 30 在 10 号椅子上开始喝酒
2023/05/20 18:25:34 		顾客# 28 在 7 号椅子上开始喝酒
2023/05/20 18:25:34 		顾客# 24 在 4 号椅子上开始喝酒
2023/05/20 18:25:35 				顾客# 25 离开了酒吧
2023/05/20 18:25:35 				顾客# 30 离开了酒吧
2023/05/20 18:25:35 				顾客# 21 离开了酒吧
2023/05/20 18:25:35 				顾客# 24 离开了酒吧
2023/05/20 18:25:35 				顾客# 26 离开了酒吧
2023/05/20 18:25:35 				顾客# 28 离开了酒吧
2023/05/20 18:25:35 				顾客# 23 离开了酒吧
2023/05/20 18:25:35 				顾客# 3 离开了酒吧
2023/05/20 18:25:35 				顾客# 27 离开了酒吧
2023/05/20 18:25:35 				顾客# 29 离开了酒吧
```

上面的程序达到了预期的效果：同一时刻最多只有 10 位客人在喝酒

但是通过输出就可以直观的看出来，如果等待的人过多，**`(问题1)会创建出非常多的协程一直在阻塞状态`**

**改进代码1：**
```go {hl_lines=[3,22]}
func cusEvent(cusNo int, seat chan int, chairNo int)  {  
   log.Println("顾客#", cusNo, "进入酒吧")  
   //chairNo := <- seat   // 获得一张椅子  
   log.Println("\t\t顾客#", cusNo, "在", chairNo, "号椅子上开始喝酒")  
   time.Sleep(time.Second * 1)  
   log.Println("\t\t\t\t顾客#", cusNo, "离开了酒吧")  
   seat <- chairNo    // 顾客动作完成，让出椅子  
   wg.Done()  
}  
  
func main() {  
   // 创建一个 10 容量的缓冲通道，用来代表 10 个座位  
   // 通道的值 -- 椅子的编号  
   seat := make(chan int, 10)  
   for i := 0; i < cap(seat); i++ {  
      seat <- i + 1  
   }  
  
   // 模拟有 50 个客人进入酒吧  
   for i := 0; i < 30; i++ {  
      wg.Add(1)  
      charNo := <- seat  
      go cusEvent(i+1, seat, charNo)  
   }  
   wg.Wait()  
}
```

上面的修改解决了会有非常多的协程在等待的问题，因为只有获得通道数据后，才会创建协程，以下是上面代码的一个输出情况：
```txt
2023/05/21 12:13:19 顾客# 1 进入酒吧
2023/05/21 12:13:19 		顾客# 1 在 1 号椅子上开始喝酒
2023/05/21 12:13:19 顾客# 10 进入酒吧
2023/05/21 12:13:19 顾客# 5 进入酒吧
2023/05/21 12:13:19 		顾客# 5 在 5 号椅子上开始喝酒
2023/05/21 12:13:19 顾客# 6 进入酒吧
2023/05/21 12:13:19 		顾客# 6 在 6 号椅子上开始喝酒
2023/05/21 12:13:19 顾客# 7 进入酒吧
2023/05/21 12:13:19 顾客# 8 进入酒吧
2023/05/21 12:13:19 		顾客# 7 在 7 号椅子上开始喝酒
2023/05/21 12:13:19 顾客# 9 进入酒吧
2023/05/21 12:13:19 		顾客# 9 在 9 号椅子上开始喝酒
2023/05/21 12:13:19 		顾客# 8 在 8 号椅子上开始喝酒
2023/05/21 12:13:19 顾客# 3 进入酒吧
2023/05/21 12:13:19 		顾客# 3 在 3 号椅子上开始喝酒
2023/05/21 12:13:19 顾客# 2 进入酒吧
2023/05/21 12:13:19 顾客# 4 进入酒吧
2023/05/21 12:13:19 		顾客# 4 在 4 号椅子上开始喝酒
2023/05/21 12:13:19 		顾客# 10 在 10 号椅子上开始喝酒
2023/05/21 12:13:19 		顾客# 2 在 2 号椅子上开始喝酒
2023/05/21 12:13:20 				顾客# 10 离开了酒吧
2023/05/21 12:13:20 				顾客# 7 离开了酒吧
2023/05/21 12:13:20 				顾客# 4 离开了酒吧
2023/05/21 12:13:20 				顾客# 5 离开了酒吧
2023/05/21 12:13:20 				顾客# 9 离开了酒吧
2023/05/21 12:13:20 				顾客# 1 离开了酒吧
2023/05/21 12:13:20 				顾客# 8 离开了酒吧
2023/05/21 12:13:20 				顾客# 2 离开了酒吧
2023/05/21 12:13:20 顾客# 12 进入酒吧
2023/05/21 12:13:20 		顾客# 12 在 7 号椅子上开始喝酒
2023/05/21 12:13:20 				顾客# 3 离开了酒吧
2023/05/21 12:13:20 				顾客# 6 离开了酒吧
2023/05/21 12:13:20 顾客# 11 进入酒吧
2023/05/21 12:13:20 顾客# 16 进入酒吧
2023/05/21 12:13:20 顾客# 17 进入酒吧
2023/05/21 12:13:20 顾客# 19 进入酒吧
2023/05/21 12:13:20 		顾客# 19 在 3 号椅子上开始喝酒
2023/05/21 12:13:20 		顾客# 16 在 1 号椅子上开始喝酒
2023/05/21 12:13:20 顾客# 14 进入酒吧
2023/05/21 12:13:20 		顾客# 14 在 5 号椅子上开始喝酒
2023/05/21 12:13:20 顾客# 15 进入酒吧
2023/05/21 12:13:20 		顾客# 15 在 9 号椅子上开始喝酒
2023/05/21 12:13:20 		顾客# 11 在 10 号椅子上开始喝酒
2023/05/21 12:13:20 顾客# 20 进入酒吧
2023/05/21 12:13:20 		顾客# 20 在 6 号椅子上开始喝酒
2023/05/21 12:13:20 顾客# 18 进入酒吧
2023/05/21 12:13:20 		顾客# 18 在 2 号椅子上开始喝酒
2023/05/21 12:13:20 顾客# 13 进入酒吧
2023/05/21 12:13:20 		顾客# 13 在 4 号椅子上开始喝酒
2023/05/21 12:13:20 		顾客# 17 在 8 号椅子上开始喝酒
2023/05/21 12:13:21 				顾客# 16 离开了酒吧
2023/05/21 12:13:21 				顾客# 19 离开了酒吧
2023/05/21 12:13:21 顾客# 21 进入酒吧
2023/05/21 12:13:21 				顾客# 12 离开了酒吧
2023/05/21 12:13:21 				顾客# 17 离开了酒吧
2023/05/21 12:13:21 顾客# 23 进入酒吧
2023/05/21 12:13:21 顾客# 24 进入酒吧
2023/05/21 12:13:21 		顾客# 24 在 8 号椅子上开始喝酒
2023/05/21 12:13:21 		顾客# 23 在 7 号椅子上开始喝酒
2023/05/21 12:13:21 		顾客# 21 在 1 号椅子上开始喝酒
2023/05/21 12:13:21 顾客# 22 进入酒吧
2023/05/21 12:13:21 		顾客# 22 在 3 号椅子上开始喝酒
2023/05/21 12:13:21 				顾客# 20 离开了酒吧
2023/05/21 12:13:21 				顾客# 11 离开了酒吧
2023/05/21 12:13:21 				顾客# 15 离开了酒吧
2023/05/21 12:13:21 				顾客# 14 离开了酒吧
2023/05/21 12:13:21 				顾客# 18 离开了酒吧
2023/05/21 12:13:21 顾客# 29 进入酒吧
2023/05/21 12:13:21 顾客# 25 进入酒吧
2023/05/21 12:13:21 顾客# 26 进入酒吧
2023/05/21 12:13:21 		顾客# 25 在 6 号椅子上开始喝酒
2023/05/21 12:13:21 		顾客# 26 在 10 号椅子上开始喝酒
2023/05/21 12:13:21 顾客# 27 进入酒吧
2023/05/21 12:13:21 		顾客# 27 在 9 号椅子上开始喝酒
2023/05/21 12:13:21 		顾客# 29 在 2 号椅子上开始喝酒
2023/05/21 12:13:21 				顾客# 13 离开了酒吧
2023/05/21 12:13:21 顾客# 30 进入酒吧
2023/05/21 12:13:21 		顾客# 30 在 4 号椅子上开始喝酒
2023/05/21 12:13:21 顾客# 28 进入酒吧
2023/05/21 12:13:21 		顾客# 28 在 5 号椅子上开始喝酒
2023/05/21 12:13:22 				顾客# 28 离开了酒吧
2023/05/21 12:13:22 				顾客# 30 离开了酒吧
2023/05/21 12:13:22 				顾客# 23 离开了酒吧
2023/05/21 12:13:22 				顾客# 25 离开了酒吧
2023/05/21 12:13:22 				顾客# 27 离开了酒吧
2023/05/21 12:13:22 				顾客# 24 离开了酒吧
2023/05/21 12:13:22 				顾客# 22 离开了酒吧
2023/05/21 12:13:22 				顾客# 29 离开了酒吧
2023/05/21 12:13:22 				顾客# 26 离开了酒吧
2023/05/21 12:13:22 				顾客# 21 离开了酒吧
```

上面经过改良，减少了大量协程在阻塞的问题，但是也存在另一个问题，因为我们是针对顾客来创建协程，如果有相当多的顾客，那么就 **`(问题2)会有很多的协程被创建并摧毁`** ，那么就可以有另外一种改进方法：因为椅子的数量是固定的，可以针对椅子来创建协程，，如果有顾客进来，通知椅子，如果有空闲的椅子，就进行服务

**改进代码2：**
```go {hl_lines=[2,"21-25"]}
func chairEvent(cus chan int, seat chan int)  {  
   for c := range cus {  
      log.Println("顾客#", c, "进入酒吧")  
      chairNo := <- seat // 获得一张椅子  
      log.Println("\t\t顾客#", c, "在", chairNo, "号椅子上开始喝酒")  
      time.Sleep(time.Second * 1)  
      log.Println("\t\t\t\t顾客#", c, "离开了酒吧")  
      seat <- chairNo  
   }  
   wg.Done()  
}  
  
func main() {  
   // 创建一个 10 容量的缓冲通道，用来代表 10 个座位  
   // 通道的值 -- 椅子的编号  
   seat := make(chan int, 10)  
   for i := 0; i < cap(seat); i++ {  
      seat <- i + 1  
   }  
  
   cus := make(chan int)  
   for i := 0; i < cap(seat); i++ {  
      wg.Add(1)  
      go chairEvent(cus, seat)  
   }  
  
   time.Sleep(3 * time.Second)  
   log.Println("等待顾客进入...")  
  
   // 模拟有 30 个客人进入酒吧  
   for i := 0; i < 30; i++ {  
      cus <- i+1  
   }  
  
   close(cus)  
   wg.Wait()  
}
```

在程序的`整个生命周期，只会有 10 个协程被创建`


## 对话（乒乓）

```go
type Ball uint32  
  
func play(playerName string, table chan Ball) {  
   var lastValue Ball = 1  
   defer wg.Done()  
   for {  
      ball := <-table  
      fmt.Println(playerName, ball)  
      ball += lastValue  
      if ball < lastValue {  
         os.Exit(0)  
      }  
      lastValue = ball  
      table <- ball  
      time.Sleep(100)  
   }  
}  
  
func main() {  
   table := make(chan Ball)  
   wg.Add(2)  
   go play("player1", table)  
   go play("player2", table)  
  
   table <- 1  
   wg.Wait()  
   close(table)  
}
```

## 使当前协程永久阻塞

 使用 `select{}` 来实现是最简单的

```go
func main() {
	go ...
	go ...
	select{}
}
```

## 尝试发送和尝试接收

```go
func main() {
	type Book struct{id int}
	bookshelf := make(chan Book, 3)

	for i := 0; i < cap(bookshelf) * 2; i++ {
		select {
		case bookshelf <- Book{id: i}:
			fmt.Println("成功将书放在书架上", i)
		default:
			fmt.Println("书架已经被占满了")
		}
	}

	for i := 0; i < cap(bookshelf) * 2; i++ {
		select {
		case book := <-bookshelf:
			fmt.Println("成功从书架上取下一本书", book.id)
		default:
			fmt.Println("书架上已经没有书了")
		}
	}
}
```


## 峰值限制

结合前面提到的 `通道用作计数信号量` 和 `通道尝试（发送、接收）` ,可以实现峰值限制

峰值限制的目的是`防止过大的并发请求数`


## 超时机制

```go
func requestWithTimeout(timeout time.Duration) (int, error) {
	c := make(chan int)
	go doRequest(c) // 可能需要超出预期的时长回应

	select {
	case data := <-c:
		return data, nil
	case <-time.After(timeout):
		return 0, errors.New("超时了！")
	}
}
```

## 定时器（ticker）

## 速率限制（rate limiting）

通过 `峰值限制` 和 `定时器` 配合，实现速率限制，用来限制在一段时间内的资源使用不超标

```go
// 定义一个 Request 接口
type Request interface{}

// 处理 Request 的函数，将 Request 中的整数打印出来
func handle(r Request) {
	fmt.Println(r.(int))
}

// 限制处理请求的频率不超过 RateLimitPeriod 时间内处理 RateLimit 个请求
const RateLimitPeriod = time.Minute
const RateLimit = 200

// 处理请求的函数，传入一个 Request 类型的通道，每次从中取出一个请求处理
func handleRequests(requests <-chan Request) {
	// 用一个缓冲为 RateLimit 的时间类型通道作为额度的限制器
	quotas := make(chan time.Time, RateLimit)

	// 在 goroutine 中，每隔一段时间往限额通道中发送一个时间，限制处理请求的速度
	// 如果通道已满，则丢弃当前时间，让通道继续阻塞，等待下一个可用的时间发送
	go func() {
		tick := time.NewTicker(RateLimitPeriod / RateLimit)
		defer tick.Stop()
		for t := range tick.C {
			select {
			case quotas <- t:
			default:
			}
		}
	}()

	// 循环从 Request 通道中取出请求并处理
	for r := range requests {
		<-quotas // 等待可用的时间进行处理
		go handle(r)
	}
}

func main() {
	requests := make(chan Request) // 创建一个 Request 类型的无缓冲通道
	go handleRequests(requests)    // 开启一个 goroutine 处理通道中的请求

	// 循环向通道中发送请求，不断发送，直到程序被手动停止
	for i := 0; ; i++ {
		requests <- i
	}
	// 可以使用time.Sleep来让主进程休眠一段时间，模拟请求的发送
}
```

## todo


---
1. https://gfw.go101.org/article/channel-use-cases.html
