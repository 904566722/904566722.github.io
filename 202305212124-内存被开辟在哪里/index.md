# 内存被开辟在哪里

<!--more-->
#

{{< admonition warning "about card" false >}}
这是一个临时性的**卡片文章**，之后可能:
1. `针对该卡片进行扩展，形成文章`
2. `与已有文章关联，组织到其他文章`
3. `删除`
{{< /admonition>}}


Go 程序运行的时候，每个协程维护一个`栈`，开辟在栈上的内存块只能在此协程内部使用

每个程序有一个`堆`，堆是一个虚拟的概念，开辟在堆上的内存块所有的协程都能够访问

**如何决定开辟在栈还是堆上？**

如果编译器察觉到一个内存块可能会被多个协程访问，或者无法保证一个内存块只被一个协程访问，那么这个内存块就会被开辟在堆上，这是保守且安全的。

`栈让 Go 的运行效率更高`
- 在栈上开辟内存**更快**
- 栈上的内存块**不需要垃圾回收**（栈式内存管理：当函数被调用时，编译器会将栈帧压入栈中，当函数执行完毕后，编译器会将栈帧从栈中弹出，这样就自动释放了该函数所使用的所有内存空间）
- 对 **CPU 缓存**更友好
