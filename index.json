[{"categories":["数据结构与算法"],"content":"#leetcode 1016. 子串能表示从 1 到 N 数字的二进制串 // // 思路1. 遍历 n，每个字符串都判断是否是 s 的子串， 如果使用 kmp 算法，时间复杂度是 s 的长度 m // o(n * m) * 数字转二进制字符串的时间 // n's max = 1000000000 n * 每个数字转二进制的时间应该很长，再加上匹配的时间可能会超时 // 假设 n // 15:1111 如果是子串，那么 111、11、1 都是子串 15 7 3 1 // 14:1110 如果是子串，那么 110、10、0 都是子串 // 13:1101 如果是子串，那么 101、1 都是子串 // 12:1100 .. // 11:1011 // 10:1010 // 9:1001 // ... // 1:0001 // // 思路2. 通过上面的分析可以找到一种优化 // 从最大的数开始比较，如果这个数符合，那么持续右移(/2)，放入一个符合条件的 map， // 遍历的时候如果这个数已经被放入 map，就跳过 func queryString(s string, n int) bool { set := map[int]bool{} for num := n; num \u003e= 1; num-- { if _, ok := set[num]; ok { continue } binaryStr := strconv.FormatInt(int64(num), 2) if kmp(s, binaryStr) { tmpNum := num for tmpNum \u003e 0 { set[tmpNum] = true tmpNum /= 2 } } else { return false } } return len(set) == n } func kmp(s, pat string) bool { n, m := len(s), len(pat) i, j := 0, 0 next := getNext(pat) for i \u003c n \u0026\u0026 j \u003c m { for j \u003e 0 \u0026\u0026 pat[j] != s[i] {j = next[j-1]} if pat[j] == s[i] { j++ } i++ } return j == m } func getNext(pat string) []int { i, j, n := 1, 0, len(pat) next := make([]int, n) next[0] = 0 for i \u003c n { for j \u003e 0 \u0026\u0026 pat[j] != pat[i] {j = next[j-1]} if pat[i] == pat[j] { j++ } next[i] = j i++ } return next } ","date":"2023-05-11","objectID":"/202305111537-t1016-%E5%AD%90%E4%B8%B2%E8%83%BD%E8%A1%A8%E7%A4%BA%E4%BB%8E-1-%E5%88%B0-n-%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%B2/:0:0","series":["leetcode"],"tags":[],"title":"子串能表示从 1 到 N 数字的二进制串","uri":"/202305111537-t1016-%E5%AD%90%E4%B8%B2%E8%83%BD%E8%A1%A8%E7%A4%BA%E4%BB%8E-1-%E5%88%B0-n-%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%B2/#"},{"categories":["Tools-Method"],"content":"#个人记录 windows 环境 ","date":"2023-05-11","objectID":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/:0:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 Hugo + GitHub Pages 搭建博客记录","uri":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/#"},{"categories":["Tools-Method"],"content":" Hugo 安装依赖/版本： Go 1.20.4（不同的 hugo 依赖的 go 版本可能不同，注意分辨） Hugo v0.91.2-1798BD3F+extended Git 可以直接在 Hugo 已发布的版本 中直接下载二进制文件来运行 可以在环境变量中添加一个专门放自己二进制文件的目录： 将上面下载的 hugo 二进制文件放到上面定义的目录下，就能够直接运行这个命令了 ","date":"2023-05-11","objectID":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/:1:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 Hugo + GitHub Pages 搭建博客记录","uri":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/#hugo-安装"},{"categories":["Tools-Method"],"content":" 生成项目具体可以参考文档：https://gohugo.io/getting-started/quick-start/ hugo new site demo1 # 生成项目结构 cd demo1 git init # 将项目初始化成 git 项目 # 克隆一个主题 git submodule add git@github.com:theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \"theme = 'ananke'\" \u003e\u003e config.toml # 把主题选择写入配置文件，选择上面克隆的主题 hugo new posts/test_post.md # 写一个测试文档 hugo server --buildDrafts # 本地运行 运行之后本地访问 localhost:1313： 项目结构： $ tree -d -L 2 . |-- archetypes |-- content | `-- posts |-- data |-- gohugo-theme-ananke | |-- archetypes | |-- assets | |-- exampleSite | |-- i18n | |-- images | |-- layouts | |-- resources | `-- static |-- layouts |-- public |-- resources | `-- _gen |-- static `-- themes `-- ananke ","date":"2023-05-11","objectID":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/:2:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 Hugo + GitHub Pages 搭建博客记录","uri":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/#生成项目"},{"categories":["Tools-Method"],"content":" 选择主题 挑选喜欢的主题仓库，克隆到 themes 目录下 https://themes.gohugo.io/ 编辑 config.toml 配置文件 ... theme = '主题' 或者比较成熟的主题一般都会有自己的完善的配置文档，直接参照即可，本博客使用 Doit 主题 ","date":"2023-05-11","objectID":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/:3:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 Hugo + GitHub Pages 搭建博客记录","uri":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/#选择主题"},{"categories":["Tools-Method"],"content":" 使用 GitHub Pages 部署站点使用 hugo 命令在自己的博客根目录生成博客站点文件夹 public hugo cd public 新建一个 username.github.io 的仓库，比如我的仓库名为 904566722.github.io ，然后将上面生成的 public 文件夹的内容推送到该仓库 然后就可以使用 username.github.io 来访问该网站了 ","date":"2023-05-11","objectID":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/:4:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 Hugo + GitHub Pages 搭建博客记录","uri":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/#使用-github-pages-部署站点"},{"categories":["Tools-Method"],"content":" 注册域名为了能够使用自己的域名来访问博客，可以注册一个域名，我这边使用腾讯云的域名，购买完成后配置解析： 下一步是在 username.github.io 中配置自己的域名： 配置完成后就可以使用自己的域名来访问网站啦 ","date":"2023-05-11","objectID":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/:5:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 Hugo + GitHub Pages 搭建博客记录","uri":"/202305111342-%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/#注册域名"},{"categories":["Tools-Method"],"content":"#个人记录 ","date":"2023-05-11","objectID":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/:0:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 GitHub Action 来完成博客自动更新","uri":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/#"},{"categories":["Tools-Method"],"content":" 手动发布流程以编写一篇文档为例： 使用 obsidian 编写文档 执行命令行本地生成 hugo 页面，看看有没有报错、文档编排之类的问题 hugo server -e production --disableFastRender 如果没有问题，需要把相应内容推送到两个仓库：保存md文档的仓库A（本仓库）、保存hugo生成的静态页面的仓库B 可以先推送到仓库A，保存文章 然后执行 hugo 生成静态网页，切到 public 目录，推送内容到仓库B git add . git commit -m \"m/w. desc\" git push hugo cd public git add . git commit -m \"m/w. desc\" git push ","date":"2023-05-11","objectID":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/:1:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 GitHub Action 来完成博客自动更新","uri":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/#手动发布流程"},{"categories":["Tools-Method"],"content":" 自动发布的过程需要使用到 GitHub Action 一段描述： 使用 GitHub Actions 直接在您的存储库中自动化、自定义和执行您的软件开发工作流程。您可以发现、创建和共享操作以执行您喜欢的任何工作，包括 CI/CD，并在完全自定义的工作流中组合操作 那么就可以用来省去手动到 public 目录 commit、push 的操作，实现博客的自动发布。 设定两个事件就差不多了： 当仓库 A 有代码更新（push），执行脚本 定时执行脚本 支持手动执行 flowchart TD %% 重要性的分类 classDef important stroke:red, stroke-width:2px classDef pass stroke:grey, stroke-dasharray: 5,5 %% 流程的分类 classDef success stroke:green %% 解释 classDef stick fill:yellow, stroke:yellow classDef stickImp fill:pink, stroke:pink %% ----主要流程 begin ---- act1(手动推送代码)--\u003erepoA[源仓库] repoA--\u003e|触发GitHub Action|ga[执行源仓库中编写好的\u003cbr\u003e.github/workflow/xxx.yaml 脚本] subgraph sub1[\"GitHub Action 执行机自动完成的操作\"] ga--\u003eautoAct1[拉取源仓库到本地] autoAct1--\u003eautoAct2[执行 hugo 生成 public 目录] autoAct2--\u003eautoAct3[拉取 xxx.github.io 仓库\u003cbr\u003e并执行 git rm -r --ignore-unmatch * 删除所有文件和目录\u003cbr\u003e删除完成之后把生成的 public 目录放到 xxx.github.io] autoAct3--\u003eauto4[commit 并且 push 到 xxx.github.io 仓库] end auto4--\u003epage[GitHub Pages 生成站点] %% ---- 主要流程 end ---- %% 注意一个问题 note1[\"这里的操作会把 xxx.github.io 仓库的域名配置清空(如果有配置的话)\"] note1-.-autoAct3 subgraph sub2 fix1[生成一个 CNAME 文件到 public]--\u003ea[把 public 拷贝到 xxx.github.io] end note1-.-\u003e|如何解决|sub2 sub2-.-auto4 class note1 stickImp flowchart TD %% 重要性的分类 classDef important stroke:red, stroke-width:2px classDef pass stroke:grey, stroke-dasharray: 5,5 %% 流程的分类 classDef success stroke:green %% 解释 classDef stick fill:yellow, stroke:yellow classDef stickImp fill:pink, stroke:pink %% ----主要流程 begin ---- act1(手动推送代码)--\u003erepoA[源仓库] repoA--\u003e|触发GitHub Action|ga[执行源仓库中编写好的 .github/workflow/xxx.yaml 脚本] subgraph sub1[\"GitHub Action 执行机自动完成的操作\"] ga--\u003eautoAct1[拉取源仓库到本地] autoAct1--\u003eautoAct2[执行 hugo 生成 public 目录] autoAct2--\u003eautoAct3[拉取 xxx.github.io 仓库 并执行 git rm -r --ignore-unmatch * 删除所有文件和目录 删除完成之后把生成的 public 目录放到 xxx.github.io] autoAct3--\u003eauto4[commit 并且 push 到 xxx.github.io 仓库] end auto4--\u003epage[GitHub Pages 生成站点] %% ---- 主要流程 end ---- %% 注意一个问题 note1[\"这里的操作会把 xxx.github.io 仓库的域名配置清空(如果有配置的话)\"] note1-.-autoAct3 subgraph sub2 fix1[生成一个 CNAME 文件到 public]--\u003ea[把 public 拷贝到 xxx.github.io] end note1-.-\u003e|如何解决|sub2 sub2-.-auto4 class note1 stickImp ","date":"2023-05-11","objectID":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/:2:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 GitHub Action 来完成博客自动更新","uri":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/#自动发布的过程"},{"categories":["Tools-Method"],"content":" 具体操作 person token 在 GitHub 个人设置里面 settings/developer settings 创建一个 token，这个 token 需要勾选两个权限：repo 和 workflow 然后到源仓库 settings / Secrets and variables 中添加一个 repository variable 变量 然后在源仓库需要添加一个 yaml 脚本 目录：.github/workflows/update-blog.yaml ，脚本内容如下： name: deploy on: # 表示以下情况发生时触发 push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: '0 0 * * *' jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Set up Python uses: actions/setup-python@v2 with: python-version: 3.8 - name: Commit and push if changed run: |- git diff git config --global user.email \"action@github.com\" git config --global user.name \"GitHub Action\" git add -A git commit -m \"ci: update about page (automatically)\" || exit 0 git push - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 0.105.0 extended: true - name: Build Web #run: hugo --gc --minify run: hugo - name: Create CNAME run: echo \"honghuiqiang.com\" \u003e public/CNAME - name: Run Pagefind run: npm_config_yes=true npx pagefind --source \"public\" - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} # 上一步中仓库变量的 key EXTERNAL_REPOSITORY: 904566722/904566722.github.io PUBLISH_BRANCH: hugo PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} 其中 Create CNAME 动作是为了解决如下问题： 使用 GitHub Action 自动发布博客之后域名无法访问到页面的问题 问题现象： 使用域名 honghuiqiang.com 无法访问到页面（404） 问题产生的原因： 在 904566722.github.io 仓库中，域名的配置是作为仓库中的一个文件存在的，GitHub Action 操作中，把该仓库拉取下来之后会清空目录，这个文件会被清除掉，因此需要多运行一条命令来再次生成域名配置 - name: Create CNAME run: echo \"honghuiqiang.com\" \u003e public/CNAME 至此配置就全部完成了！ 来实际看一下一个 push 之后 github 做的动作： 在 Action 选项卡可以看到流程被触发： 进去能够看到执行机完成的命令，具体做了哪些操作 到此一个 Action 就完成了，可以到 xx.github.io 看到有一个相同 commit msg 的提交 到此就完成了博客的自动更新流程 ","date":"2023-05-11","objectID":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/:3:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"使用 GitHub Action 来完成博客自动更新","uri":"/202305110815-%E4%BD%BF%E7%94%A8-github-action-%E6%9D%A5%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/#具体操作"},{"categories":["生活记录"],"content":" 规划区 gantt dateFormat HH:mm axisFormat %H:%M tickInterval 1h title 今天大概要做 section 博客相关内容 1.梳理规划一天的方法、完成日记模板的创建:done,riji,06:00, 2h 2.完成博客的自动发布系统:done,fabu, after riji, 1h 3.总结文档《使用huog+github pages搭建博客流程》:done,after fabu, 90m 4.golang: 1h section 习惯 算法每日一题:done, 1h gantt（最后要与上面的代码同步）： gantt dateFormat HH:mm axisFormat %H:%M tickInterval 1h title 今天大概要做 section 博客相关内容 1.梳理规划一天的方法、完成日记模板的创建:done,riji,06:00, 2h 2.完成博客的自动发布系统:done,fabu, after riji, 1h 3.总结文档《使用huog+github pages搭建博客流程》:after fabu, 90m section 习惯 算法每日一题: 1h ","date":"2023-05-11","objectID":"/2023-05-11/:1:0","series":["日规划-记录"],"tags":[],"title":"2023-05-11 日记录","uri":"/2023-05-11/#规划区"},{"categories":["生活记录"],"content":" 记录区-习惯记录打卡状态： ✅ | ❌ 习惯打卡表 日期 算法 阅读 1 ✅ 2 ✅ 3 ✅ 4 ✅ 5 ✅ 6 ✅ 7 8 ✅ 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ","date":"2023-05-11","objectID":"/2023-05-11/:2:0","series":["日规划-记录"],"tags":[],"title":"2023-05-11 日记录","uri":"/2023-05-11/#记录区-习惯记录"},{"categories":["生活记录"],"content":" 记录区-事\u0026物记 重要事记 无 新事物 ","date":"2023-05-11","objectID":"/2023-05-11/:3:0","series":["日规划-记录"],"tags":[],"title":"2023-05-11 日记录","uri":"/2023-05-11/#记录区-事物记"},{"categories":["生活记录"],"content":" 记录区-随手记（挑首歌？local:202305101553 博客音乐嵌入样例 remote:202305101553 博客音乐嵌入样例） ","date":"2023-05-11","objectID":"/2023-05-11/:4:0","series":["日规划-记录"],"tags":[],"title":"2023-05-11 日记录","uri":"/2023-05-11/#记录区-随手记"},{"categories":["生活记录"],"content":" 记录区-总结心情打分： 😆 很快乐 🙂 一般快乐 😶 无明显情绪波动 🧐有疑问 😵‍💫 很混乱 😮‍💨叹气 😡 生气 输出内容： ","date":"2023-05-11","objectID":"/2023-05-11/:5:0","series":["日规划-记录"],"tags":[],"title":"2023-05-11 日记录","uri":"/2023-05-11/#记录区-总结"},{"categories":["生活记录"],"content":" 记录区-明天","date":"2023-05-11","objectID":"/2023-05-11/:6:0","series":["日规划-记录"],"tags":[],"title":"2023-05-11 日记录","uri":"/2023-05-11/#记录区-明天"},{"categories":["Tools-Method"],"content":"一天的规划用什么样的方式来规划与记录？","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/"},{"categories":["Tools-Method"],"content":"#规划 之前可能大多使用windows上便签的方式，随手记录，大概写一下内容。 这篇文章的目的是想再明确一下规划一天的流程，同时希望能够把这些内容也同步到博客 不知道这样更为复杂的方式会不会浪费时间，先试验一下再说，始：2023-05-11 这篇文章应该是需要根据每一天规划方式的改变来不断迭代、规范的 ","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/:0:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/#"},{"categories":["Tools-Method"],"content":" 记些什么东西好 ✍基于自己的习惯，对于一天的规划，不喜欢定的太详细，没有可伸缩的空间不好，先确定一些规则： 对于一天要做什么，就写一些大概性的东西，然后在一天的工作、学习过程中基于这些内容，有扩展、有伸缩 这些内容是否要规定时间？ 不写开始时间，就写持续时间（这项任务大概需要多长时间完成） 有了一些基本的规则，来确定一下：一篇日规划的文章中需要包含什么？大体分为两个区域： 规划区：当天开始的时候 | 前一天 做好大致规划，把上面讲到的大概性的东西写一些，规范今天的内容 记录区：当天事情结束的时候做记录 ","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/:1:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/#记些什么东西好-"},{"categories":["Tools-Method"],"content":" 规划区可以尝试使用 gantt 图来记录一下（先试用一下，不方便的话后面使用脑图 或者 不用图画的形式来记录也行），最近学习了 mermaid（local 202305100916 mermaid 语法-甘特图 remote 202305100916 mermaid 语法-甘特图），刚好用来练练手 ","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/:1:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/#规划区"},{"categories":["Tools-Method"],"content":" 记录区 习惯记录：每天都要去做的事情，可以用来做旧习惯的打卡，也可以来记录新习惯的养成 有没有什么月度表之类的工具？ 事\u0026物记： 重要事件：当天发生的重要的事情，可能来自新闻、一天的工作、生活上 新事物 随手记：杂记一样，可以是天马行空的想法，像写个人日记一样，想怎么记怎么记，不束缚自己的一个板块，🆒！ 总结 情绪 明天？：大概想一下明天要做什么 ","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/:1:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/#记录区"},{"categories":["Tools-Method"],"content":" 提高效率为了提高做规划、记录的效率，上面讲到的这些东西应该是要能作为一个 模板 存在的，obsidian 刚好是能够完成这项工作的。 确定日记存放的位置：content/posts/diary 创建模板 日记文件相关设置 ","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/:2:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/#提高效率"},{"categories":["Tools-Method"],"content":" 流程 flowchart LR %% 重要性的分类 classDef important stroke:red, stroke-width:2px classDef pass stroke:grey, stroke-dasharray: 5,5 %% 流程的分类 classDef success stroke:green step1[新建一篇笔记]--\u003estep2[在规划区做规划] step2--\u003eday[一天流逝...事情都完成之后] day--\u003estep3[完成记录区的内容] class step2,step3 important class day pass 点击左侧的 打开/创建今天的日记 按钮，根据模板生成对应的日记文件 ","date":"2023-05-11","objectID":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/:3:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"怎么来规划一天、做日记录","uri":"/202305110405-%E6%80%8E%E4%B9%88%E6%9D%A5%E8%A7%84%E5%88%92%E4%B8%80%E5%A4%A9%E5%81%9A%E6%97%A5%E8%AE%B0%E5%BD%95/#流程"},{"categories":["生活记录"],"content":"#博客音乐嵌入样例 ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:0:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#"},{"categories":["生活记录"],"content":" Lessang 寻找幸福 music url=\"/music/finding_happiness/finding-happiness.mp3\" name=\"행복을 찾아서 (寻找幸福)\" artist=\"Leessang (리쌍)/赵贤雅 (조현아)\" cover=\"/music/finding_happiness/lessang.png\" 回想 music url=\"/music/lessang/recall.m4a\" name=\"회상 (Feat. 백지영) (回想)\" artist=\"Leessang (리쌍)/白智英 (백지영)\" cover=\"/music/lessang/recall.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:1:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#lessang"},{"categories":["生活记录"],"content":" IU jam jam (live) music url=\"/music/iu/jamjam(live).m4a\" name=\"잼잼(JAM JAM) (Live)\" artist=\"IU (아이유)\" cover=\"/music/iu/jamjamlive.jpg\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:2:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#iu"},{"categories":["生活记录"],"content":" aurora queendom music url=\"/music/aurora/queendom.m4a\" name=\"Queendom\" artist=\"AURORA\" cover=\"/music/aurora/queendom.jpg\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:3:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#aurora"},{"categories":["生活记录"],"content":" 我的大叔 무지개는 있다 (有彩虹) (Band Ver.) music url=\"/music/myuncle/有彩虹.mp3\" name=\"무지개는 있다 (有彩虹) (Band Ver.)\" artist=\"빈센트 블루 (Vincent Blue)\" cover=\"/music/myuncle/我的大叔.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:4:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#我的大叔"},{"categories":["生活记录"],"content":" 九连真人 music url=\"/music/九连真人/北风.mp3\" name=\"北风\" artist=\"九连真人\" cover=\"/music/九连真人/jiulianzhenren.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:5:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#九连真人"},{"categories":["生活记录"],"content":" amazarashi 無題(Unplugged) music url=\"/music/amazarashi/無題(Unplugged).mp3\" name=\"無題(Unplugged)\" artist=\"amazarashi\" cover=\"/music/amazarashi/wuti.png\" 僕が死のうと思ったのは(曾经我也想过一了百了) music url=\"/music/amazarashi/僕が死のうと思ったのは(曾经我也想过一了百了).mp3\" name=\"僕が死のうと思ったのは(曾经我也想过一了百了)\" artist=\"amazarashi\" cover=\"/music/amazarashi/xuwubing.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:6:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#amazarashi"},{"categories":["生活记录"],"content":" B 热河2018相信未来不插电版 music url=\"/music/B/热河2018相信未来不插电版.mp3\" name=\"热河2018相信未来不插电版\" artist=\"B\" cover=\"/music/B/wuti.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:7:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#b"},{"categories":["生活记录"],"content":" club 8 Love in December music url=\"/music/club8/LoveinDecember.mp3\" name=\"Love in December\" artist=\"club 8\" cover=\"/music/club8/LoveinDecember.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:8:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#club-8"},{"categories":["生活记录"],"content":" Epik High TROT music url=\"/music/epik-high/trot.mp3\" name=\"trot\" artist=\"B\" cover=\"/music/epik-high/trot.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:9:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#epik-high"},{"categories":["生活记录"],"content":" Gary 고장난 선풍기 (故障的电风扇) music url=\"/music/gary/故障的电风扇.mp3\" name=\"故障的电风扇\" artist=\"MC梦 (MC몽)/Gary (개리)/孝琳 (효린)\" cover=\"/music/gary/故障的电风扇.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:10:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#gary"},{"categories":["生活记录"],"content":" 请回答1988 걱정말아요 그대 (你不要担心) music url=\"/music/请回答1988/你不要担心.mp3\" name=\"걱정말아요 그대 (你不要担心)\" artist=\"SoulJa/青山黛玛 (青山テルマ)\" cover=\"/music/请回答1988/你不要担心.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:11:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#请回答1988"},{"categories":["生活记录"],"content":" 五条人 石牌桥 music url=\"/music/五条人/石牌桥.mp3\" name=\"石牌桥\" artist=\"五条人\" cover=\"/music/五条人/石牌桥.png\" 也已晚 music url=\"/music/五条人/夜已晚.mp3\" name=\"夜已晚\" artist=\"五条人\" cover=\"/music/五条人/夜已晚.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:12:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#五条人"},{"categories":["生活记录"],"content":" 徐佳莹 耳边风 music url=\"/music/徐佳莹/耳边风.mp3\" name=\"耳边风\" artist=\"徐佳莹\" cover=\"/music/徐佳莹/耳边风.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:13:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#徐佳莹"},{"categories":["生活记录"],"content":" jay-z Empire State of Mind music url=\"/music/jay-z/EmpireStateOfMind.mp3\" name=\"Empire State of Mind\" artist=\"Jay-Z/Alicia Keys\" cover=\"/music/jay-z/EmpireStateOfMind.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:14:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#jay-z"},{"categories":["生活记录"],"content":" Rachel Platten Fight Song music url=\"/music/RachelPlatten/FightSong.mp3\" name=\"Fight Song\" artist=\"Rachel Platten\" cover=\"/music/RachelPlatten/FightSong.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:15:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#rachel-platten"},{"categories":["生活记录"],"content":" Sophie Zelmani going home music url=\"/music/SophieZelmani/going-home.mp3\" name=\"going home\" artist=\"Sophie Zelmani\" cover=\"/music/SophieZelmani/SophieZelmani.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:16:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#sophie-zelmani"},{"categories":["生活记录"],"content":" Tom Rosenthal Go Solo music url=\"/music/TomRosenthal/GoSolo.mp3\" name=\"Go Solo\" artist=\"Tom Rosenthal\" cover=\"/music/TomRosenthal/GoSolo.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:17:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#tom-rosenthal"},{"categories":["生活记录"],"content":" pure Life Story music url=\"/music/pure/LifeStory.mp3\" name=\"Life Story\" artist=\"Ólafur Arnalds/Nils Frahm\" cover=\"/music/pure/LifeStory.png\" Passionflower music url=\"/music/pure/Passionflower.mp3\" name=\"Passionflower\" artist=\"Jon Gomm\" cover=\"/music/pure/Passionflower.png\" ","date":"2023-05-10","objectID":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/:18:0","series":["音乐"],"tags":[],"title":"博客音乐嵌入样例","uri":"/202305101553-%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E5%B5%8C%E5%85%A5%E6%A0%B7%E4%BE%8B/#pure"},{"categories":["生活记录"],"content":"#游玩映像 ","date":"2023-05-10","objectID":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/:0:0","series":["影像记录"],"tags":["游玩映像"],"title":"22年的国庆广州游玩映像","uri":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/#"},{"categories":["生活记录"],"content":" Day1. 陈家祠堂、沙面、叉烧… ","date":"2023-05-10","objectID":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/:1:0","series":["影像记录"],"tags":["游玩映像"],"title":"22年的国庆广州游玩映像","uri":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/#day1-陈家祠堂沙面叉烧"},{"categories":["生活记录"],"content":" Day2. 肠粉、长隆 真的帅 ","date":"2023-05-10","objectID":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/:2:0","series":["影像记录"],"tags":["游玩映像"],"title":"22年的国庆广州游玩映像","uri":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/#day2-肠粉长隆"},{"categories":["生活记录"],"content":" Day3. 北园酒家、南越王博物院、中山纪念堂、太古仓码头、夜游珠江 ","date":"2023-05-10","objectID":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/:3:0","series":["影像记录"],"tags":["游玩映像"],"title":"22年的国庆广州游玩映像","uri":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/#day3-北园酒家南越王博物院中山纪念堂太古仓码头夜游珠江"},{"categories":["生活记录"],"content":" Day4. 动物园 ","date":"2023-05-10","objectID":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/:4:0","series":["影像记录"],"tags":["游玩映像"],"title":"22年的国庆广州游玩映像","uri":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/#day4-动物园"},{"categories":["生活记录"],"content":" Day5. 植物园、广东博物馆、石牌桥 ","date":"2023-05-10","objectID":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/:5:0","series":["影像记录"],"tags":["游玩映像"],"title":"22年的国庆广州游玩映像","uri":"/202305101458-22%E5%B9%B4%E7%9A%84%E5%9B%BD%E5%BA%86%E5%B9%BF%E5%B7%9E%E6%B8%B8%E7%8E%A9%E6%98%A0%E5%83%8F/#day5-植物园广东博物馆石牌桥"},{"categories":["生活记录"],"content":"#彩铅 ","date":"2023-05-10","objectID":"/202305101439-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E5%BD%A9%E9%93%85/:0:0","series":["画画"],"tags":["彩铅"],"title":"废了很久的爱好-彩铅","uri":"/202305101439-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E5%BD%A9%E9%93%85/#"},{"categories":["生活记录"],"content":" long long ago… ","date":"2023-05-10","objectID":"/202305101439-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E5%BD%A9%E9%93%85/:1:0","series":["画画"],"tags":["彩铅"],"title":"废了很久的爱好-彩铅","uri":"/202305101439-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E5%BD%A9%E9%93%85/#long-long-ago"},{"categories":["生活记录"],"content":"#树脂 ","date":"2023-05-10","objectID":"/202305101440-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E6%A0%91%E8%84%82%E7%94%BB/:0:0","series":["画画"],"tags":["彩铅"],"title":"废了很久的爱好-树脂画","uri":"/202305101440-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E6%A0%91%E8%84%82%E7%94%BB/#"},{"categories":["生活记录"],"content":" long long ago… ","date":"2023-05-10","objectID":"/202305101440-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E6%A0%91%E8%84%82%E7%94%BB/:1:0","series":["画画"],"tags":["彩铅"],"title":"废了很久的爱好-树脂画","uri":"/202305101440-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E6%A0%91%E8%84%82%E7%94%BB/#long-long-ago"},{"categories":["生活记录"],"content":"#素描 ","date":"2023-05-10","objectID":"/202305101436-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E7%B4%A0%E6%8F%8F/:0:0","series":["画画"],"tags":["素描"],"title":"废了很久的爱好-素描","uri":"/202305101436-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E7%B4%A0%E6%8F%8F/#"},{"categories":["生活记录"],"content":" long long ago… ","date":"2023-05-10","objectID":"/202305101436-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E7%B4%A0%E6%8F%8F/:1:0","series":["画画"],"tags":["素描"],"title":"废了很久的爱好-素描","uri":"/202305101436-%E5%BA%9F%E4%BA%86%E5%BE%88%E4%B9%85%E7%9A%84%E7%88%B1%E5%A5%BD-%E7%B4%A0%E6%8F%8F/#long-long-ago"},{"categories":["生活记录"],"content":"#宠物映像 ","date":"2023-05-10","objectID":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/:0:0","series":["影像记录"],"tags":["我的宠物朋友"],"title":"在我的大学生涯短暂陪伴过我的一只玄凤","uri":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/#"},{"categories":["生活记录"],"content":" 刚来的时候來了一段时间后的样子，长了一点羽毛，给他搞了个架子 ","date":"2023-05-10","objectID":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/:1:0","series":["影像记录"],"tags":["我的宠物朋友"],"title":"在我的大学生涯短暂陪伴过我的一只玄凤","uri":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/#刚来的时候"},{"categories":["生活记录"],"content":" 一次事故 一次意外导致左腿骨折了，还好之后顺利恢复了。 ","date":"2023-05-10","objectID":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/:2:0","series":["影像记录"],"tags":["我的宠物朋友"],"title":"在我的大学生涯短暂陪伴过我的一只玄凤","uri":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/#一次事故"},{"categories":["生活记录"],"content":" later ","date":"2023-05-10","objectID":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/:3:0","series":["影像记录"],"tags":["我的宠物朋友"],"title":"在我的大学生涯短暂陪伴过我的一只玄凤","uri":"/202305101443-%E5%9C%A8%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF%E7%9F%AD%E6%9A%82%E9%99%AA%E4%BC%B4%E8%BF%87%E6%88%91%E7%9A%84%E4%B8%80%E5%8F%AA%E7%8E%84%E5%87%A4/#later"},{"categories":["生活记录"],"content":"#听歌月记录 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:0:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#"},{"categories":["生活记录"],"content":" 2022 年度报告 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:1:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#2022-年度报告"},{"categories":["生活记录"],"content":" 2022/12 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:2:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202212"},{"categories":["生活记录"],"content":" 2022/11 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:3:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202211"},{"categories":["生活记录"],"content":" 2022/10 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:4:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202210"},{"categories":["生活记录"],"content":" 2022/09 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:5:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202209"},{"categories":["生活记录"],"content":" 2022/08 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:6:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202208"},{"categories":["生活记录"],"content":" 2022/07 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:7:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202207"},{"categories":["生活记录"],"content":" 2022/06 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:8:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202206"},{"categories":["生活记录"],"content":" 2022/05 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:9:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202205"},{"categories":["生活记录"],"content":" 2022/04 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:10:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202204"},{"categories":["生活记录"],"content":" 2022/03 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:11:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202203"},{"categories":["生活记录"],"content":" 2022/02 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:12:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202202"},{"categories":["生活记录"],"content":" 2022/01 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:13:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202201"},{"categories":["生活记录"],"content":" 2021 年度报告 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:14:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#2021-年度报告"},{"categories":["生活记录"],"content":" 2021/12 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:15:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202112"},{"categories":["生活记录"],"content":" 2021/11 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:16:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202111"},{"categories":["生活记录"],"content":" 2021/10 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:17:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202110"},{"categories":["生活记录"],"content":" 2021/09 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:18:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202109"},{"categories":["生活记录"],"content":" 2021/08 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:19:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202108"},{"categories":["生活记录"],"content":" 2021/07 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:20:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202107"},{"categories":["生活记录"],"content":" 2021/06 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:21:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202106"},{"categories":["生活记录"],"content":" 2021/05 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:22:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202105"},{"categories":["生活记录"],"content":" 2021/04 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:23:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202104"},{"categories":["生活记录"],"content":" 2021/03 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:24:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202103"},{"categories":["生活记录"],"content":" 2021/02 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:25:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202102"},{"categories":["生活记录"],"content":" 2021/01 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:26:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202101"},{"categories":["生活记录"],"content":" 2020/11 ","date":"2023-05-10","objectID":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/:27:0","series":["音乐"],"tags":["听歌月记录"],"title":"听歌月记录","uri":"/202305101357-%E5%90%AC%E6%AD%8C%E6%9C%88%E8%AE%B0%E5%BD%95/#202011"},{"categories":["Tools-Method"],"content":"#mermaid （思维导图在 obsidian v1.2.7 中还没支持） ","date":"2023-05-10","objectID":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/:0:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-思维导图","uri":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/#"},{"categories":["Tools-Method"],"content":" 基本语法思维导图主要通过 缩进 来表示其结构 再配合记住一些关键字即可： mindmap root mindmap root a aa ab b mindmap root a aa ab b ","date":"2023-05-10","objectID":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/:1:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-思维导图","uri":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/#基本语法"},{"categories":["Tools-Method"],"content":" 元素的形状跟流程图表现形状的方法类似 mindmap root((mymind)) id[1.square] id(2.rounded) id((3.circle)) id))4.explode(( id)5.cloud( id{{6.hexagon}} 7.default mindmap root((mymind)) id[1.square] id(2.rounded) id((3.circle)) id))4.explode(( id)5.cloud( id{{6.hexagon}} 7.default ","date":"2023-05-10","objectID":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/:2:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-思维导图","uri":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/#元素的形状"},{"categories":["Tools-Method"],"content":" 文字说明“`文字内容`” mindmap root((mymind)) id[\"`1.square 一些说明性的文字 可能会有换行的需求 这将使用到反单引号 这里同样可以使用表情🥵`\"] id(2.rounded) id((3.circle)) mindmap root((mymind)) id[\"`1.square 一些说明性的文字 可能会有换行的需求 这将使用到反单引号 这里同样可以使用表情🥵`\"] id(2.rounded) id((3.circle)) ","date":"2023-05-10","objectID":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/:3:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-思维导图","uri":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/#文字说明"},{"categories":["Tools-Method"],"content":" 图标::icon() mindmap root((mymind)) id[1.square] ::icon(fas fa-yen-sign) id(2.rounded) id((3.circle)) ::icon(fas fa-circle-notch) id))4.explode(( id)5.cloud( ::icon(fas fa-cloud) id{{6.hexagon}} 7.default mindmap root((mymind)) id[1.square] ::icon(fas fa-yen-sign) id(2.rounded) id((3.circle)) ::icon(fas fa-circle-notch) id))4.explode(( id)5.cloud( ::icon(fas fa-cloud) id{{6.hexagon}} 7.default 看效果感觉做的还不是很好 https://mermaid.js.org/syntax/mindmap.html ","date":"2023-05-10","objectID":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/:4:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-思维导图","uri":"/202305101117-mermaid-%E8%AF%AD%E6%B3%95-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/#图标"},{"categories":["Tools-Method"],"content":"#个人记录 ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:0:0","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#"},{"categories":["Tools-Method"],"content":" 写作","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:0","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#写作"},{"categories":["Tools-Method"],"content":" 我的写作工具 flowchart LR tp[typora]--\u003e|1|vsc[vscode] vsc--\u003etp tp--\u003e|2|nt[notion] nt--\u003etp tp--\u003e|3|ta[the archive] subgraph 支持卡片盒笔记法 ta--\u003e|4|o[\"obsidian(正在使用)\"] end Obsidian之前换过一些工具，就先不记录了，因为前段时间看了卡片盒笔记法，找了一些方便使用这个方法的软件来用，正在使用 Obsidian，记录一下一些常用设置： （为什么这个框框得点两次） 新建文件路径、图片存放位置 适配卡片盒笔记法 一个正常的笔记流程： 新建时间戳笔记 修改文件的相关描述 开始写作 ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:1","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#我的写作工具"},{"categories":["Tools-Method"],"content":" 我的写作工具 flowchart LR tp[typora]--\u003e|1|vsc[vscode] vsc--\u003etp tp--\u003e|2|nt[notion] nt--\u003etp tp--\u003e|3|ta[the archive] subgraph 支持卡片盒笔记法 ta--\u003e|4|o[\"obsidian(正在使用)\"] end Obsidian之前换过一些工具，就先不记录了，因为前段时间看了卡片盒笔记法，找了一些方便使用这个方法的软件来用，正在使用 Obsidian，记录一下一些常用设置： （为什么这个框框得点两次） 新建文件路径、图片存放位置 适配卡片盒笔记法 一个正常的笔记流程： 新建时间戳笔记 修改文件的相关描述 开始写作 ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:1","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#obsidian"},{"categories":["Tools-Method"],"content":" 图床使用 github 保存图片 编辑的时候粘贴的时候都保存到本地 themes/DoIt/assets/images/posts 文件夹中，写作的时候无需做上传图片的操作 但是需要把 ·themes/DoIt/assets/ images/posts 这段内容删除，为的是让 hugo 生成静态页面之后能找到这张图片 这样就能够同时在 博客、obsidian 中看到这张图片 ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:2","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#图床"},{"categories":["Tools-Method"],"content":" 键盘 NIZ 宁芝 84EC(S) Ble好！ 固件、编程软件下载 正常写作、工作问题定位的时候可能会用到一些重复性的输入，复杂的输入，使用编程软件编写对应的宏，提高效率 宏 首先 1.读取配置 放置直接写入覆盖掉了之前的配置，然后进行 自定义的操作，编辑完成之后把配置 写入按键，最后保存一下配置，做个备份。 看下效果： ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:3","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#键盘"},{"categories":["Tools-Method"],"content":" 键盘 NIZ 宁芝 84EC(S) Ble好！ 固件、编程软件下载 正常写作、工作问题定位的时候可能会用到一些重复性的输入，复杂的输入，使用编程软件编写对应的宏，提高效率 宏 首先 1.读取配置 放置直接写入覆盖掉了之前的配置，然后进行 自定义的操作，编辑完成之后把配置 写入按键，最后保存一下配置，做个备份。 看下效果： ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:3","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#niz-宁芝-84ecs-ble"},{"categories":["Tools-Method"],"content":" 音乐嵌入流程 把音乐放到对应的 music 文件夹 编辑调用代码 music url=\"/music/lessang/recall.m4a\" name=\"xxx\" artist=\"xxx\" cover=\"/music/lessang/xxx.png\" 示例： ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:4","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#音乐嵌入流程"},{"categories":["Tools-Method"],"content":" 画图 processon mermaid ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:5","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#画图"},{"categories":["Tools-Method"],"content":" 下载","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:0","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#下载"},{"categories":["Tools-Method"],"content":" 通常下载IDM ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:1","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#通常下载"},{"categories":["Tools-Method"],"content":" youtube 视频音频https://youtube.iiilab.com/ ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:2","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#youtube-视频音频"},{"categories":["Tools-Method"],"content":" 文档Kubernetes ","date":"2023-05-10","objectID":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/:3:0","series":["工具"],"tags":["个人记录","操作备忘"],"title":"开始记录一些我的工具、便捷操作[持续记录...]","uri":"/202305101151-%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/#文档"},{"categories":["Tools-Method"],"content":"#mermaid ","date":"2023-05-10","objectID":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/:0:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-甘特图","uri":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/#"},{"categories":["Tools-Method"],"content":" 先来看一个简单的例子 gantt title simple sample section A task1 :one, 2023-05-10, 1d task2 :two, 2023-05-10, 5h 代码大体由以下几部分组成： 大致分成： gantt 定义区 section 区 任务描述 主要的话还是关于任务信息的写法 ","date":"2023-05-10","objectID":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/:1:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-甘特图","uri":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/#先来看一个简单的例子"},{"categories":["Tools-Method"],"content":" 任务信息 任务名称，描述 :[任务性质], [是否完成], [别名], [开始时间], [持续时间|结束时间] 这些描述字段大都是可选的 属性 值 任务性质 crit - 重要任务 milestone - 里程碑任务 是否完成 active - 激活状态 done - 已完成 别名 最好不要有数字！ 开始时间 格式由 gantt 定义区的 dateFormat 属性指定，例如：dateFormat YYYY-MM-DD 持续时间 数字 + m/h/d/w 可以把一些属性放在任务区外面来写： ","date":"2023-05-10","objectID":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/:2:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-甘特图","uri":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/#任务信息"},{"categories":["Tools-Method"],"content":" gantt 定义区的内容 title 标题 dateFormat 定义输入的日期格式 支持解析的占位符列表 axisFormat x 轴显示格式 https://github.com/d3/d3-time-format/tree/v4.0.0#locale_format tickInterval x 轴刻度 /^([1-9][0-9]*)(minute|hour|day|week|month)$/; displayMode: compact 可以让 gantt 图更紧凑 --- displayMode: compact --- gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :a2, 2014-01-20, 25d Another one :a3, 2014-02-10, 20d --- displayMode: compact --- gantt ... ","date":"2023-05-10","objectID":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/:3:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-甘特图","uri":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/#gantt-定义区的内容"},{"categories":["Tools-Method"],"content":" 例子 gantt title 项目计划表 section 设计阶段 需求分析:done,a, 2022-01-01, 10d 概要设计:done,b, 2022-01-11, 10d 详细设计:c, 2022-01-21, 10d section 编码阶段 编码:crit,d, 2022-02-01, 28d section 测试阶段 单元测试:e, 2022-03-01, 10d 集成测试:f, 2022-03-11, 10d 系统测试:g, 2022-03-21, 10d gantt title 项目计划表 section 设计阶段 需求分析:done,a, 2022-01-01, 10d 概要设计:done,b, 2022-01-11, 10d 详细设计:c, 2022-01-21, 10d section 编码阶段 编码:crit,d, 2022-02-01, 28d section 测试阶段 单元测试:e, 2022-03-01, 10d 集成测试:f, 2022-03-11, 10d 系统测试:g, 2022-03-21, 10d https://mermaid.js.org/syntax/gantt.html ","date":"2023-05-10","objectID":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/:4:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-甘特图","uri":"/202305100916-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%98%E7%89%B9%E5%9B%BE/#例子"},{"categories":["Tools-Method"],"content":"#mermaid journey title My working day section study 打扫: 3: Me 学习: 3: Me 看 rm: 5: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me journey title My working day section study 打扫: 3: Me 学习: 3: Me 看 rm: 5: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me https://mermaid.js.org/syntax/userJourney.html ","date":"2023-05-10","objectID":"/202305100347-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%A8%E6%88%B7%E6%97%85%E7%A8%8B%E5%9B%BE/:0:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-用户旅程图","uri":"/202305100347-mermaid-%E8%AF%AD%E6%B3%95-%E7%94%A8%E6%88%B7%E6%97%85%E7%A8%8B%E5%9B%BE/#"},{"categories":["Tools-Method"],"content":"#mermaid pie showData title 被收养的宠物 \"Dogs\": 386 \"Cats\": 85 \"Rats\": 15 pie showData title 被收养的宠物 \"Dogs\": 386 \"Cats\": 85 \"Rats\": 15 https://mermaid.js.org/syntax/pie.html ","date":"2023-05-10","objectID":"/202305100200-mermaid-%E8%AF%AD%E6%B3%95-%E9%A5%BC%E5%9B%BE/:0:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-饼图","uri":"/202305100200-mermaid-%E8%AF%AD%E6%B3%95-%E9%A5%BC%E5%9B%BE/#"},{"categories":["Tools-Method"],"content":"#mermaid ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:0:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#"},{"categories":["Tools-Method"],"content":" 消息首先分成 实线 和 虚线 ，然后每种线都有 无箭头、有箭头、带x箭头、空心箭头（异步） 四种箭头 类型 渲染 -\u003e -» -x -) –\u003e –» –x –) ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:1:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#消息"},{"categories":["Tools-Method"],"content":" 序号autonumber sequenceDiagram autonumber rect rgb(191,233,255) a-\u003e\u003eb: hello b-\u003e\u003ec: hi rect rgb(255,106,106) b-\u003e\u003ea: i hate you end end sequenceDiagram autonumber rect rgb(191,233,255) a-\u003e\u003eb: hello b-\u003e\u003ec: hi rect rgb(205,38,38) b-\u003e\u003ea: i hate you end end ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:2:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#序号"},{"categories":["Tools-Method"],"content":" 成员 participant、actor成员可以有超链接 sequenceDiagram %% 定义成员出现的顺序 participant Alice participant Bob Alice-\u003e\u003eBob: Hi Bob Bob-\u003e\u003eAlice: Hi Alice ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:3:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#成员-participantactor"},{"categories":["Tools-Method"],"content":" 两种类型 类型 渲染 participant actor ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:3:1","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#两种类型"},{"categories":["Tools-Method"],"content":" 别名participant/actor 别名 as user01 participant A as Alice ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:3:2","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#别名"},{"categories":["Tools-Method"],"content":" 分组box … end sequenceDiagram box Group 01 actor a actor b end box Another Group actor c actor d end a-\u003eb: hi! b-\u003ec: hello! c-\u003ed: hi! d-\u003ea: so high! sequenceDiagram box Group 01 actor a actor b end box Another Group actor c actor d end a-\u003eb: hi! b-\u003ec: hello! c-\u003ed: hi! d-\u003ea: so high! ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:3:3","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#分组"},{"categories":["Tools-Method"],"content":" 激活-结束 activate … deactivate + / - sequenceDiagram actor a actor b a-\u003e\u003eb: cook activate b b-\u003e\u003ea: done! deactivate b 实现1. sequenceDiagram actor a actor b a-\u003e\u003eb: cook activate b b-\u003e\u003ea: done! deactivate b 实现2. sequenceDiagram a-\u003e\u003e+b: cook begin! b-\u003e\u003e-a: is done! 重复激活： sequenceDiagram a-\u003e\u003e+b: cook 1! a-\u003e\u003e+b: cook 2! b-\u003e\u003e-a: 1 done! b-\u003e\u003e-a: 2 done! sequenceDiagram a-\u003e\u003e+b: cook 1! a-\u003e\u003e+b: cook 2! b-\u003e\u003e-a: 1 done! b-\u003e\u003e-a: 2 done! ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:4:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#激活-结束"},{"categories":["Tools-Method"],"content":" 循环loop 频率 … end sequenceDiagram actor a actor b a-\u003e\u003eb: 你好吗? loop every secs b--\u003e\u003ea: 很好! end sequenceDiagram actor a actor b a-\u003e\u003eb: 你好吗? loop every secs b--\u003e\u003ea: 很好! end ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:5:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#循环"},{"categories":["Tools-Method"],"content":" 分支 sequenceDiagram actor a actor b a-\u003e\u003eb: 你好吗? alt 生病了，很忙... b-\u003e\u003ea: 不好 end alt 很健康 b-\u003e\u003ea: 很好 end sequenceDiagram actor a actor b a-\u003e\u003eb: 你好吗? alt 生病了，很忙... b-\u003e\u003ea: 不好 end alt 很健康 b-\u003e\u003ea: 很好 end ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:6:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#分支"},{"categories":["Tools-Method"],"content":" 并行消息par … and … end 用来表示并行的消息 显然是可以嵌套的 sequenceDiagram actor server actor client1 actor client2 par 响应用户1 server-\u003e\u003eclient1: response and 响应用户2 server-\u003e\u003eclient2: response end client1--\u003e\u003eserver: request next client2--\u003e\u003eserver: request next sequenceDiagram actor server actor client1 actor client2 par 响应用户1 server-\u003e\u003eclient1: response and 响应用户2 server-\u003e\u003eclient2: response end client1--\u003e\u003eserver: request next client2--\u003e\u003eserver: request next ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:7:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#并行消息"},{"categories":["Tools-Method"],"content":" 结果可预见的情况，列举所有情况以一个服务跟数据库建立连接为例，结果无非： 连接成功 连接超时 连接被拒绝 critical … option … option … end sequenceDiagram critical 良好的连接环境 service--\u003eDB: 连接成功 option 网络超时 service--\u003eservice: 登录失败 option 密码错误 service-\u003e\u003eDB: 登录验证 DB-\u003e\u003eservice: 验证失败 end sequenceDiagram critical 良好的连接环境 service--\u003eDB: 连接成功 option 网络超时 service--\u003eservice: 登录失败 option 密码错误 service-\u003e\u003eDB: 登录验证 DB-\u003e\u003eservice: 验证失败 end ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:8:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#结果可预见的情况列举所有情况"},{"categories":["Tools-Method"],"content":" 停止/休息break … end sequenceDiagram Consumer--\u003eAPI: Book something API--\u003eBookingService: Start booking process break when the booking process fails API--\u003eConsumer: show failure end API--\u003eBillingService: Start billing process sequenceDiagram Consumer--\u003eAPI: Book something API--\u003eBookingService: Start booking process break when the booking process fails API--\u003eConsumer: show failure end API--\u003eBillingService: Start billing process ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:9:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#停止休息"},{"categories":["Tools-Method"],"content":" 便签 Note left of Note right of Note over sequenceDiagram actor a actor b actor c Note left of a: 1. Note left of a Note right of b: 2. Note right of b Note over c: 3. Note over c Note over a,b: 4. Note over a,b Note over a: 5. Note over a a-\u003e\u003e+b: cook 1! b-\u003e\u003e-a: done! ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:10:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#便签"},{"categories":["Tools-Method"],"content":" 背景颜色 rect rgb(x,x,x) or rgba(x,x,x) sequenceDiagram rect rgb(191,233,255) a-\u003e\u003eb: hello b-\u003e\u003ec: hi rect rgb(255,106,106) b-\u003e\u003ea: i hate you end end sequenceDiagram rect rgb(191,233,255) a-\u003e\u003eb: hello b-\u003e\u003ec: hi rect rgb(255,106,106) b-\u003e\u003ea: i hate you end end https://mermaid.js.org/syntax/sequenceDiagram.html ","date":"2023-05-10","objectID":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/:11:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-时序图","uri":"/202305100218-mermaid-%E8%AF%AD%E6%B3%95-%E6%97%B6%E5%BA%8F%E5%9B%BE/#背景颜色"},{"categories":["Tools-Method"],"content":"#mermaid ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:0:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#"},{"categories":["Tools-Method"],"content":" 流程图流程图的方向： 水平：LRLeft Right、RLRight Left 垂直：TDTop Down 流程图的组成元素分成两大类： 框框 线 ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#流程图"},{"categories":["Tools-Method"],"content":" 框 A[方形] A(圆角) A{菱形} A([体育场]) A[[子程序]] A[(数据库)] A((圆)) A\u003e就这个形状] A{{六边形}} A[/平行四边形/] A[\\平行四边形\\] A[/平行四边形\\] A[\\平行四边形/] A(((双圆圈))) 框 渲染 a[方形] a(圆角) A{菱形} A([体育场]) A[[子程序]] A[(数据库)] A((圆)) A\u003e就这个形状] A{{六边形}} A[/平行四边形/] … A(((双圆圈))) 填色： %% 1. 类定义 classDef yellow fill:yellow a---b---c %% 2. 把样式给方块 class a yellow graph LR %% 1. 类定义 classDef yellow fill:yellow a---b---c %% 2. 把样式给方块 class a yellow ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:1","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#框"},{"categories":["Tools-Method"],"content":" 线 ---\u003e --- -.-\u003e ==\u003e # 厚 --o --x \u003c--\u003e -- text -- OR A----|text|B -- text --\u003e OR A----\u003e|text|B 看不见的链接：（如果想要改变框框的位置，这可能是有用的） ~~~ 线 渲染 说明 —\u003e — -.-\u003e ==\u003e 比较厚的线 –o –x \u003c–\u003e A–\u003e|text|B ~~~ 两个元素之间空白的连线 ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:2","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#线"},{"categories":["Tools-Method"],"content":" 组合同一行内可以写多个连接 a--\u003eb --\u003ec a--B\u0026c--\u003ed A \u0026 B--\u003e C \u0026 D 上面这行写法可读性可能不太好，不如写成： a --\u003e c \u0026 d b --\u003e c \u0026 d ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:3","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#组合"},{"categories":["Tools-Method"],"content":" 子图 使用 subgraph … end 来划分子图 子图之间可以画线、子图与元素之间可以画线 子图可以用 direction 指定方向(例如 direction LD，放在 subgraph 后面一行) graph TD a---c subgraph one d---c end subgraph two e---f end ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:4","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#子图"},{"categories":["Tools-Method"],"content":" 文本 文本也可以像 Markdown 一样使用星号加粗 ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:5","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#文本"},{"categories":["Tools-Method"],"content":" 注释 %% ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:6","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#注释"},{"categories":["Tools-Method"],"content":" 润色 图标： graph LR a---b[fa:fa-spinner] 类定义 %% 1. 类定义 classDef classname fill:yellow, stroke:yellow, stroke-width: 4px, storoke-dasharray: 5, 5 a---b---c %% 2. 把样式给方块 class a classname fill 用颜色填满元素 stroke 边框颜色 stroke-width 边框宽度 stroke-dasharray 虚线边框 ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:1:7","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#润色"},{"categories":["Tools-Method"],"content":" 例子 flowchart TD %% 重要性的分类 classDef important stroke:red, stroke-width:2px classDef pass stroke:grey, stroke-dasharray: 5,5 %% 流程的分类 classDef success stroke:green %% 解释 classDef stick fill:yellow, stroke:yellow classDef stickImp fill:pink, stroke:pink, color:black a[重要]---b[一般]---c[可忽略] b---d[重要] d---e[成功] f[实现类似便签的效果 对一个元素或者流程节点加以解释] f-.-d class a,d important class c pass class e success class f stickImp %% 重要性的分类 classDef important stroke:red, stroke-width:2px classDef pass stroke:grey, stroke-dasharray: 5,5 %% 流程的分类 classDef success stroke:green %% 解释 classDef stick fill:yellow, stroke:yellow classDef stickImp fill:pink, stroke:pink, color:black a[重要]---b[一般]---c[可忽略] b---d[重要] d---e[成功] f[实现类似便签的效果\u003cbr\u003e对一个元素或者流程节点加以解释] f-.-d class a,d important class c pass class e success class f stickImp https://mermaid.js.org/syntax/flowchart.html ","date":"2023-05-09","objectID":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/:2:0","series":["mermaid语法"],"tags":["画图"],"title":"mermaid 语法-流程图","uri":"/202305092142-mermaid-%E8%AF%AD%E6%B3%95-%E6%B5%81%E7%A8%8B%E5%9B%BE/#例子"},{"categories":["Tools-Method"],"content":"最近打算把自己的文档从本地放到博客上，方便自己在线查看。借这个机会好好整理一下自己的写作流","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/"},{"categories":["Tools-Method"],"content":"#myflow 前言：最近打算把自己的文档从本地放到博客上，方便自己在线查看。因此写这篇文档的目的也是想借这个机会好好整理一下自己的写作流 打算从下面几个方面来整理： 之前的一些写作习惯 针对 obsidian的特性、hugo、markdown、卡片盒笔记法这些特性来尝试养成一些新的习惯 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:0:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#"},{"categories":["Tools-Method"],"content":" 回顾一下之前的写作习惯从大学很早的时候就接触到了 Markdown 的语言，让写作真的变得很方便，可以让写作者专注于内容，而不是排版，这也帮助我养成了做记录的习惯。 （因为这次都把文档放到博客上了，之后的话，本地软件（obsidian）更加侧重来编辑，查看的话多在博客查看吧，在文档的显示风格的考虑上，更加侧重博客的渲染情况。） ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:1:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#回顾一下之前的写作习惯"},{"categories":["Tools-Method"],"content":" 文本显示 关于重点文字如何突出显示首先把内容分一下等级，这里的“内容”范围应该是一个段落，一段文字的范围之内的，而不考虑整篇文章，因为整篇文章的角度来看的话，使用 # 来做结构的切分已经很清晰了。把内容的分级就粗略分成三个等级： 重点 正常 解释说明 整体阅读的时候应该顺着“正常”的内容顺序阅读，“重点”应该能够让自己在视觉上比较好的注意到，“解释说明”作为比较不重要的能容，阅读的时候有时候可以忽略，如果可以偏灰色是最好的 自己在记录的过程中，比较在意的就是怎么让自己在之后回顾的时候比较好的看到重点，首先就是不能太花哨，其次重点需要标记出来，在 Markdown 语法中，我经常用来标记重点的方式就是用反单引号、加粗的方式，但是由于之前写作的软件换过几次，不同的软件、不同的 theme 之间，这两种方式的显示有时候不是那么明显，有时候反单引号看不太出来，有时候加粗看不太出来，所以趁着这次整理，再比较一下这两种方式。 Markdown 语法中，有以下几种方式被设计来强调内容： 粗体 x 渲染情况 obsidian hugo 斜体 x 渲染情况 obsidian hugo 见下方 这是一段包含斜体文字的文本。 删除 x 渲染情况 obsidian hugo 见下方 这是一段包含删除文字的文本。 上面几种方式的组合 删除+粗体：删除的粗体文字 但是除了上面几种方式，我在以往写作的过程中经常会使用到代码的语法（反单引号 ` 的语法）来标注重点，也就是这样的效果。因为在有的主题风格中，代码的显示效果很不错，能够很直观的注意到那段高亮文本，相比上面表现良好的粗体文本，高亮文本可能表现更好，因为在标题比较多、文字段落又比较少的情况下，文本的粗体可能会隐藏在标题的粗体中，肉眼寻找起来也是费力的。 刚好在 DoIt 风格（本博客的风格主题）中，高亮表现不错，就确定代码语法用来突出重点文字吧（虽然在 obsidian 中(我使用的主题风格是 Atom)，反单引号的显示效果并不好，但是考虑到之后阅读多在博客上阅读，就这么决定吧）顺便看一下反单引号+加粗的效果：删除的重点文字 总结：最需要注意的内容，就用反单引号来概括吧！ 关于正常文字的分类显示在一段正常的文本中，可能没有重点，但是可能会有一些不同的类别，比如参杂着一个方法名、文件/文件夹的名称、命令等，之前用来标注这些可能会用上面反单引号的方式，但是在 hugo 中太显眼了，上面已经决定用来显示重点文字了，就得考虑别的方式了。 这类文字应该跟正常文字有相同的显眼程度，感觉比较理想的显示方式应该是类似这样的，就是给文字加一个单纯的、不显眼的背景色，但是 Markdown 本身没有这样的语法，上面效果的实现方式是： \u003cfont style=\"background:#e8e9e4\"\u003e是类似这样的\u003c/font\u003e 是使用 html 的方式来实现的，但是感觉这样的书写方式已经有点违背 Markdown 诞生的初衷了，又让写作变得复杂起来，有点得不偿失，感觉目前对于这一类的文字没有比较好的方案来解决，就先暂定吧。 总结：暂定 第三种等级的解释性文字这种等级的文字段落，感觉最好的应该是灰色的字体，类似这样： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 上面这样的效果是我期待的效果，这种不太重要的文字，可能就是备注一下怕之后忘记，可能第二次第三次我再次阅读的时候如果我还记得我就不会再看这段文字了，这样的颜色可以让我在顺序阅读下来的时候很好的忽略掉，省去大脑、眼睛去甄别重要性的时间，让阅读变得更流畅一些，但是跟上面分类文字的显示一样，这也是用 html 的方式来实现的： \u003cfont color=grey\u003e这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。\u003c/font\u003e 感觉还是不太好，但是感觉会比上面的分类文字的显示更能接受一些，因为像这种解释性的文字通常是： 连在一起的，一片 不那么经常出现 所以相比带来的收益跟效果，还是比较能接受的。（在复制文本的场景下，也会多出来一段 html 代码，也是需要考虑的缺点，虽然这样的场景更少） 总结：所以解释性的文字就这么来显示吧！ ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:1:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#文本显示"},{"categories":["Tools-Method"],"content":" 文本显示 关于重点文字如何突出显示首先把内容分一下等级，这里的“内容”范围应该是一个段落，一段文字的范围之内的，而不考虑整篇文章，因为整篇文章的角度来看的话，使用 # 来做结构的切分已经很清晰了。把内容的分级就粗略分成三个等级： 重点 正常 解释说明 整体阅读的时候应该顺着“正常”的内容顺序阅读，“重点”应该能够让自己在视觉上比较好的注意到，“解释说明”作为比较不重要的能容，阅读的时候有时候可以忽略，如果可以偏灰色是最好的 自己在记录的过程中，比较在意的就是怎么让自己在之后回顾的时候比较好的看到重点，首先就是不能太花哨，其次重点需要标记出来，在 Markdown 语法中，我经常用来标记重点的方式就是用反单引号、加粗的方式，但是由于之前写作的软件换过几次，不同的软件、不同的 theme 之间，这两种方式的显示有时候不是那么明显，有时候反单引号看不太出来，有时候加粗看不太出来，所以趁着这次整理，再比较一下这两种方式。 Markdown 语法中，有以下几种方式被设计来强调内容： 粗体 x 渲染情况 obsidian hugo 斜体 x 渲染情况 obsidian hugo 见下方 这是一段包含斜体文字的文本。 删除 x 渲染情况 obsidian hugo 见下方 这是一段包含删除文字的文本。 上面几种方式的组合 删除+粗体：删除的粗体文字 但是除了上面几种方式，我在以往写作的过程中经常会使用到代码的语法（反单引号 ` 的语法）来标注重点，也就是这样的效果。因为在有的主题风格中，代码的显示效果很不错，能够很直观的注意到那段高亮文本，相比上面表现良好的粗体文本，高亮文本可能表现更好，因为在标题比较多、文字段落又比较少的情况下，文本的粗体可能会隐藏在标题的粗体中，肉眼寻找起来也是费力的。 刚好在 DoIt 风格（本博客的风格主题）中，高亮表现不错，就确定代码语法用来突出重点文字吧（虽然在 obsidian 中(我使用的主题风格是 Atom)，反单引号的显示效果并不好，但是考虑到之后阅读多在博客上阅读，就这么决定吧）顺便看一下反单引号+加粗的效果：删除的重点文字 总结：最需要注意的内容，就用反单引号来概括吧！ 关于正常文字的分类显示在一段正常的文本中，可能没有重点，但是可能会有一些不同的类别，比如参杂着一个方法名、文件/文件夹的名称、命令等，之前用来标注这些可能会用上面反单引号的方式，但是在 hugo 中太显眼了，上面已经决定用来显示重点文字了，就得考虑别的方式了。 这类文字应该跟正常文字有相同的显眼程度，感觉比较理想的显示方式应该是类似这样的，就是给文字加一个单纯的、不显眼的背景色，但是 Markdown 本身没有这样的语法，上面效果的实现方式是： 是类似这样的 是使用 html 的方式来实现的，但是感觉这样的书写方式已经有点违背 Markdown 诞生的初衷了，又让写作变得复杂起来，有点得不偿失，感觉目前对于这一类的文字没有比较好的方案来解决，就先暂定吧。 总结：暂定 第三种等级的解释性文字这种等级的文字段落，感觉最好的应该是灰色的字体，类似这样： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 上面这样的效果是我期待的效果，这种不太重要的文字，可能就是备注一下怕之后忘记，可能第二次第三次我再次阅读的时候如果我还记得我就不会再看这段文字了，这样的颜色可以让我在顺序阅读下来的时候很好的忽略掉，省去大脑、眼睛去甄别重要性的时间，让阅读变得更流畅一些，但是跟上面分类文字的显示一样，这也是用 html 的方式来实现的： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 感觉还是不太好，但是感觉会比上面的分类文字的显示更能接受一些，因为像这种解释性的文字通常是： 连在一起的，一片 不那么经常出现 所以相比带来的收益跟效果，还是比较能接受的。（在复制文本的场景下，也会多出来一段 html 代码，也是需要考虑的缺点，虽然这样的场景更少） 总结：所以解释性的文字就这么来显示吧！ ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:1:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#关于重点文字如何突出显示"},{"categories":["Tools-Method"],"content":" 文本显示 关于重点文字如何突出显示首先把内容分一下等级，这里的“内容”范围应该是一个段落，一段文字的范围之内的，而不考虑整篇文章，因为整篇文章的角度来看的话，使用 # 来做结构的切分已经很清晰了。把内容的分级就粗略分成三个等级： 重点 正常 解释说明 整体阅读的时候应该顺着“正常”的内容顺序阅读，“重点”应该能够让自己在视觉上比较好的注意到，“解释说明”作为比较不重要的能容，阅读的时候有时候可以忽略，如果可以偏灰色是最好的 自己在记录的过程中，比较在意的就是怎么让自己在之后回顾的时候比较好的看到重点，首先就是不能太花哨，其次重点需要标记出来，在 Markdown 语法中，我经常用来标记重点的方式就是用反单引号、加粗的方式，但是由于之前写作的软件换过几次，不同的软件、不同的 theme 之间，这两种方式的显示有时候不是那么明显，有时候反单引号看不太出来，有时候加粗看不太出来，所以趁着这次整理，再比较一下这两种方式。 Markdown 语法中，有以下几种方式被设计来强调内容： 粗体 x 渲染情况 obsidian hugo 斜体 x 渲染情况 obsidian hugo 见下方 这是一段包含斜体文字的文本。 删除 x 渲染情况 obsidian hugo 见下方 这是一段包含删除文字的文本。 上面几种方式的组合 删除+粗体：删除的粗体文字 但是除了上面几种方式，我在以往写作的过程中经常会使用到代码的语法（反单引号 ` 的语法）来标注重点，也就是这样的效果。因为在有的主题风格中，代码的显示效果很不错，能够很直观的注意到那段高亮文本，相比上面表现良好的粗体文本，高亮文本可能表现更好，因为在标题比较多、文字段落又比较少的情况下，文本的粗体可能会隐藏在标题的粗体中，肉眼寻找起来也是费力的。 刚好在 DoIt 风格（本博客的风格主题）中，高亮表现不错，就确定代码语法用来突出重点文字吧（虽然在 obsidian 中(我使用的主题风格是 Atom)，反单引号的显示效果并不好，但是考虑到之后阅读多在博客上阅读，就这么决定吧）顺便看一下反单引号+加粗的效果：删除的重点文字 总结：最需要注意的内容，就用反单引号来概括吧！ 关于正常文字的分类显示在一段正常的文本中，可能没有重点，但是可能会有一些不同的类别，比如参杂着一个方法名、文件/文件夹的名称、命令等，之前用来标注这些可能会用上面反单引号的方式，但是在 hugo 中太显眼了，上面已经决定用来显示重点文字了，就得考虑别的方式了。 这类文字应该跟正常文字有相同的显眼程度，感觉比较理想的显示方式应该是类似这样的，就是给文字加一个单纯的、不显眼的背景色，但是 Markdown 本身没有这样的语法，上面效果的实现方式是： 是类似这样的 是使用 html 的方式来实现的，但是感觉这样的书写方式已经有点违背 Markdown 诞生的初衷了，又让写作变得复杂起来，有点得不偿失，感觉目前对于这一类的文字没有比较好的方案来解决，就先暂定吧。 总结：暂定 第三种等级的解释性文字这种等级的文字段落，感觉最好的应该是灰色的字体，类似这样： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 上面这样的效果是我期待的效果，这种不太重要的文字，可能就是备注一下怕之后忘记，可能第二次第三次我再次阅读的时候如果我还记得我就不会再看这段文字了，这样的颜色可以让我在顺序阅读下来的时候很好的忽略掉，省去大脑、眼睛去甄别重要性的时间，让阅读变得更流畅一些，但是跟上面分类文字的显示一样，这也是用 html 的方式来实现的： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 感觉还是不太好，但是感觉会比上面的分类文字的显示更能接受一些，因为像这种解释性的文字通常是： 连在一起的，一片 不那么经常出现 所以相比带来的收益跟效果，还是比较能接受的。（在复制文本的场景下，也会多出来一段 html 代码，也是需要考虑的缺点，虽然这样的场景更少） 总结：所以解释性的文字就这么来显示吧！ ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:1:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#关于正常文字的分类显示"},{"categories":["Tools-Method"],"content":" 文本显示 关于重点文字如何突出显示首先把内容分一下等级，这里的“内容”范围应该是一个段落，一段文字的范围之内的，而不考虑整篇文章，因为整篇文章的角度来看的话，使用 # 来做结构的切分已经很清晰了。把内容的分级就粗略分成三个等级： 重点 正常 解释说明 整体阅读的时候应该顺着“正常”的内容顺序阅读，“重点”应该能够让自己在视觉上比较好的注意到，“解释说明”作为比较不重要的能容，阅读的时候有时候可以忽略，如果可以偏灰色是最好的 自己在记录的过程中，比较在意的就是怎么让自己在之后回顾的时候比较好的看到重点，首先就是不能太花哨，其次重点需要标记出来，在 Markdown 语法中，我经常用来标记重点的方式就是用反单引号、加粗的方式，但是由于之前写作的软件换过几次，不同的软件、不同的 theme 之间，这两种方式的显示有时候不是那么明显，有时候反单引号看不太出来，有时候加粗看不太出来，所以趁着这次整理，再比较一下这两种方式。 Markdown 语法中，有以下几种方式被设计来强调内容： 粗体 x 渲染情况 obsidian hugo 斜体 x 渲染情况 obsidian hugo 见下方 这是一段包含斜体文字的文本。 删除 x 渲染情况 obsidian hugo 见下方 这是一段包含删除文字的文本。 上面几种方式的组合 删除+粗体：删除的粗体文字 但是除了上面几种方式，我在以往写作的过程中经常会使用到代码的语法（反单引号 ` 的语法）来标注重点，也就是这样的效果。因为在有的主题风格中，代码的显示效果很不错，能够很直观的注意到那段高亮文本，相比上面表现良好的粗体文本，高亮文本可能表现更好，因为在标题比较多、文字段落又比较少的情况下，文本的粗体可能会隐藏在标题的粗体中，肉眼寻找起来也是费力的。 刚好在 DoIt 风格（本博客的风格主题）中，高亮表现不错，就确定代码语法用来突出重点文字吧（虽然在 obsidian 中(我使用的主题风格是 Atom)，反单引号的显示效果并不好，但是考虑到之后阅读多在博客上阅读，就这么决定吧）顺便看一下反单引号+加粗的效果：删除的重点文字 总结：最需要注意的内容，就用反单引号来概括吧！ 关于正常文字的分类显示在一段正常的文本中，可能没有重点，但是可能会有一些不同的类别，比如参杂着一个方法名、文件/文件夹的名称、命令等，之前用来标注这些可能会用上面反单引号的方式，但是在 hugo 中太显眼了，上面已经决定用来显示重点文字了，就得考虑别的方式了。 这类文字应该跟正常文字有相同的显眼程度，感觉比较理想的显示方式应该是类似这样的，就是给文字加一个单纯的、不显眼的背景色，但是 Markdown 本身没有这样的语法，上面效果的实现方式是： 是类似这样的 是使用 html 的方式来实现的，但是感觉这样的书写方式已经有点违背 Markdown 诞生的初衷了，又让写作变得复杂起来，有点得不偿失，感觉目前对于这一类的文字没有比较好的方案来解决，就先暂定吧。 总结：暂定 第三种等级的解释性文字这种等级的文字段落，感觉最好的应该是灰色的字体，类似这样： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 上面这样的效果是我期待的效果，这种不太重要的文字，可能就是备注一下怕之后忘记，可能第二次第三次我再次阅读的时候如果我还记得我就不会再看这段文字了，这样的颜色可以让我在顺序阅读下来的时候很好的忽略掉，省去大脑、眼睛去甄别重要性的时间，让阅读变得更流畅一些，但是跟上面分类文字的显示一样，这也是用 html 的方式来实现的： 这段文字解释了上面这段文字，引出了下面这段文字，这是一段发灰的文字。 感觉还是不太好，但是感觉会比上面的分类文字的显示更能接受一些，因为像这种解释性的文字通常是： 连在一起的，一片 不那么经常出现 所以相比带来的收益跟效果，还是比较能接受的。（在复制文本的场景下，也会多出来一段 html 代码，也是需要考虑的缺点，虽然这样的场景更少） 总结：所以解释性的文字就这么来显示吧！ ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:1:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#第三种等级的解释性文字"},{"categories":["Tools-Method"],"content":" 中英文在文本中遇到中英文混杂的情况，我都会在英文的两边各留一个空格，也不知道是什么时候养成的习惯，也不清楚到底带来了什么好处，就是发觉了有这个 habbit，还蛮 good 吧。 我觉得你说得对。 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:1:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#中英文"},{"categories":["Tools-Method"],"content":" 针对 hugo 主题的特性来尝试养成一些新的习惯吧也不要使用过多，还是让 md 文档内容尽量保持原生的语言 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#针对-hugo-主题的特性来尝试养成一些新的习惯吧"},{"categories":["Tools-Method"],"content":" 让文本有趣一些 emoji一些可能用得到的 emoji ： 👍 👈 👉 👏 ✍ 🎼 🎵 🎶 🎧 🎸 📽 🎬📷 📸 📔 📖 ❓ ❗ ❌ ✔ ✅ 更多见：webfx emoji 字符注音/说明效果：SASuffix Array 语法： [简写或其他] ^ (说明性文字) 在代码段内也能显示（但这么做不好）： SASuffix Array 分数效果：60/100 语法： [] / [] 打字机 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#让文本有趣一些"},{"categories":["Tools-Method"],"content":" 让文本有趣一些 emoji一些可能用得到的 emoji ： 👍 👈 👉 👏 ✍ 🎼 🎵 🎶 🎧 🎸 📽 🎬📷 📸 📔 📖 ❓ ❗ ❌ ✔ ✅ 更多见：webfx emoji 字符注音/说明效果：SASuffix Array 语法： [简写或其他] ^ (说明性文字) 在代码段内也能显示（但这么做不好）： SASuffix Array 分数效果：60/100 语法： [] / [] 打字机 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#emoji"},{"categories":["Tools-Method"],"content":" 让文本有趣一些 emoji一些可能用得到的 emoji ： 👍 👈 👉 👏 ✍ 🎼 🎵 🎶 🎧 🎸 📽 🎬📷 📸 📔 📖 ❓ ❗ ❌ ✔ ✅ 更多见：webfx emoji 字符注音/说明效果：SASuffix Array 语法： [简写或其他] ^ (说明性文字) 在代码段内也能显示（但这么做不好）： SASuffix Array 分数效果：60/100 语法： [] / [] 打字机 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#字符注音说明"},{"categories":["Tools-Method"],"content":" 让文本有趣一些 emoji一些可能用得到的 emoji ： 👍 👈 👉 👏 ✍ 🎼 🎵 🎶 🎧 🎸 📽 🎬📷 📸 📔 📖 ❓ ❗ ❌ ✔ ✅ 更多见：webfx emoji 字符注音/说明效果：SASuffix Array 语法： [简写或其他] ^ (说明性文字) 在代码段内也能显示（但这么做不好）： SASuffix Array 分数效果：60/100 语法： [] / [] 打字机 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#分数"},{"categories":["Tools-Method"],"content":" 让文本有趣一些 emoji一些可能用得到的 emoji ： 👍 👈 👉 👏 ✍ 🎼 🎵 🎶 🎧 🎸 📽 🎬📷 📸 📔 📖 ❓ ❗ ❌ ✔ ✅ 更多见：webfx emoji 字符注音/说明效果：SASuffix Array 语法： [简写或其他] ^ (说明性文字) 在代码段内也能显示（但这么做不好）： SASuffix Array 分数效果：60/100 语法： [] / [] 打字机 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:1","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#打字机"},{"categories":["Tools-Method"],"content":" 让文章内容丰富一些 mermaid 画图markdown 能够使用 mermaid 快速的画图，如果是一些比较简单的图，可以用这个来画一画 mermaid 能够画出什么图？ 饼图 流程 时序 状态 甘特 类 可以看：mermaid系列 嵌入视频这是一个在线的 youtube 视频： 语法： {{\u003c 平台 视频id \u003e}} 平台： youtube bilibili 嵌入音频 丰富的警告系统hugo 扩展了一些 shortcode 丰富了警告的类型，不过也不宜使用太多，看起来太花哨了，引入一个 Bug 的警告应该就差不多了 这是个 bug 具体的语法可以看：https://hugodoit.pages.dev/zh-cn/theme-documentation-extended-shortcodes/#admonition ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#让文章内容丰富一些"},{"categories":["Tools-Method"],"content":" 让文章内容丰富一些 mermaid 画图markdown 能够使用 mermaid 快速的画图，如果是一些比较简单的图，可以用这个来画一画 mermaid 能够画出什么图？ 饼图 流程 时序 状态 甘特 类 可以看：mermaid系列 嵌入视频这是一个在线的 youtube 视频： 语法： {{\u003c 平台 视频id \u003e}} 平台： youtube bilibili 嵌入音频 丰富的警告系统hugo 扩展了一些 shortcode 丰富了警告的类型，不过也不宜使用太多，看起来太花哨了，引入一个 Bug 的警告应该就差不多了 这是个 bug 具体的语法可以看：https://hugodoit.pages.dev/zh-cn/theme-documentation-extended-shortcodes/#admonition ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#mermaid-画图"},{"categories":["Tools-Method"],"content":" 让文章内容丰富一些 mermaid 画图markdown 能够使用 mermaid 快速的画图，如果是一些比较简单的图，可以用这个来画一画 mermaid 能够画出什么图？ 饼图 流程 时序 状态 甘特 类 可以看：mermaid系列 嵌入视频这是一个在线的 youtube 视频： 语法： {{\u003c 平台 视频id \u003e}} 平台： youtube bilibili 嵌入音频 丰富的警告系统hugo 扩展了一些 shortcode 丰富了警告的类型，不过也不宜使用太多，看起来太花哨了，引入一个 Bug 的警告应该就差不多了 这是个 bug 具体的语法可以看：https://hugodoit.pages.dev/zh-cn/theme-documentation-extended-shortcodes/#admonition ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#嵌入视频"},{"categories":["Tools-Method"],"content":" 让文章内容丰富一些 mermaid 画图markdown 能够使用 mermaid 快速的画图，如果是一些比较简单的图，可以用这个来画一画 mermaid 能够画出什么图？ 饼图 流程 时序 状态 甘特 类 可以看：mermaid系列 嵌入视频这是一个在线的 youtube 视频： 语法： {{\u003c 平台 视频id \u003e}} 平台： youtube bilibili 嵌入音频 丰富的警告系统hugo 扩展了一些 shortcode 丰富了警告的类型，不过也不宜使用太多，看起来太花哨了，引入一个 Bug 的警告应该就差不多了 这是个 bug 具体的语法可以看：https://hugodoit.pages.dev/zh-cn/theme-documentation-extended-shortcodes/#admonition ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#嵌入音频"},{"categories":["Tools-Method"],"content":" 让文章内容丰富一些 mermaid 画图markdown 能够使用 mermaid 快速的画图，如果是一些比较简单的图，可以用这个来画一画 mermaid 能够画出什么图？ 饼图 流程 时序 状态 甘特 类 可以看：mermaid系列 嵌入视频这是一个在线的 youtube 视频： 语法： {{\u003c 平台 视频id \u003e}} 平台： youtube bilibili 嵌入音频 丰富的警告系统hugo 扩展了一些 shortcode 丰富了警告的类型，不过也不宜使用太多，看起来太花哨了，引入一个 Bug 的警告应该就差不多了 这是个 bug 具体的语法可以看：https://hugodoit.pages.dev/zh-cn/theme-documentation-extended-shortcodes/#admonition ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:2","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#丰富的警告系统"},{"categories":["Tools-Method"],"content":" 让文章结构规整一些","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:3","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#让文章结构规整一些"},{"categories":["Tools-Method"],"content":" 举例子之前自己写例子的时候一直没有一个比较固定的方式，有时候一个例子的篇幅可能比较长，如果跳过这个例子的话还需要定位下一个正文的起点 ❌ 原先： graph TD classDef grey fill:#f0f0ed a[正文1]--\u003eb[例子]--\u003ec[接正文1] class b grey ✅ 期望： graph TD classDef grey fill:#f0f0ed subgraph 顺序阅读 a[正文1]--\u003ec[接正文1] end a[正文1]-.-\u003eb[例子] b[例子]-.-\u003ec[接正文1] class b grey 那么就把例子的内容全部放到一个可折叠的区域里面 这是个例子 - xxxxxxx 例子的内容 这样就能达到上面期望的效果。 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:2:4","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#举例子"},{"categories":["Tools-Method"],"content":" 让博客的内容更规整一些为了让博客整体看起来有序一些，做好分类、系列、标签的规划。虽然说这个提前工程实施之后好像有点跟卡片盒笔记法的想法相违背（卡片盒笔记法提倡不做太多整体的规划，而是让笔记之间自然生长出连接规律），但是为了让已有的一些已经固定分类的文章有家可归，可以做适当的分类。 todo：之后还要好好学习一下卡片盒笔记法，让它真正成为自己的一个写作方式，现在感觉知识用上了点表面的东西。 博客主要有三种划分文档的方式：分类 \u003e 系列 \u003e 标签 算法与数据结构：分成两个系列，偏算法跟偏数据结构的分开 《数据结构》 《算法》 《leetcode》 Golang 本来应该是语言分类，然后往下分 java、go 之类的语言，但是为了让结构层级更浅，把下面一层的内容网上提，把 Golang、Java 等语言单独作为一个分类 《Golang初识》 一些简单使用方式 《Golang为什么》 记录对于Golang的一些疑问，这个“为什么是这样的”以及“这个是什么样的”之类的疑问记录在此 《GolangBug分析》 记录碰到的bug，或者别人碰到的bug 《Golang代码片段》 记录一些工具类、代码妙用等代码碎片 《Golang源码学习》 《Golang性能优化》 Golang框架 《Gin》 《Go-Redis》 《Gorm》 《client-go》 MySQL 《MySQL初识》 《MySQL底层》 容器 想想还是不使用这样的分类方式了，整个 Kubernetes 还是比较庞大的，各自拿出来作为一个分类，再把底下的内容分成系列 《Kubernetes》 《Openshift》 Kubernetes 《Kubernetes初识》 这个东西的简单使用方式 《Kubernetes代码实战》 与 k8s 关联比较大的一些代码开发、demo 之类的东西 《Kubernetes问题定位》 记录实际使用 k8s 的过程中碰到的一些问题以及定位过程 《Kubernetes存储篇》 《Kubernetes网络篇》 《Kubernetes源码分析》 Docker 《Docker命令》 记录一些 docker 常用的操作 项目管理 《Git》 操作系统 计算机网络 Linux 《命令使用》 一些常用命令记录、命令学习等 生活记录 《音乐》 🎶 #听歌月记录 #喜欢的live #博客音乐嵌入样例 《练字》 《影像记录》 #游玩映像 #宠物映像 《画画》 #素描 #水彩 #钢笔画 #树脂 《阅读》 《日规划-记录》 《月规划-记录》 《年度总结》 扩展学习 《扩展学习之ai》：放一些人工智能、深度学习之类的东西 Tools-Method 记录我在写作、学习过程中使用的一些辅助工具、记录方法、写作流等等 #个人记录 《工具》 ：一些好用的工具备忘 如果我现在想写一篇文章，但是不好确定系列，就放到 分类名-box 系列里面，作为这个分类的文章收集箱，如果之后有适合的系列，再整理进去 关于标签如何使用？ 对于一篇文章，还是不要给定太多标签，显得太乱，最好一到两个最重要的标签就好了 hugo Doit 主题中，不能存在标签跟系列一直的情况，否则博客会渲染失败 ","date":"2023-05-09","objectID":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/:3:0","series":["Tools-Method-box"],"tags":["个人记录"],"title":"重新整理一下自己的写作流","uri":"/202305091805-%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%99%E4%BD%9C%E6%B5%81/#让博客的内容更规整一些"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":" 一、KMP 算法用途 在主串 S 中查找模式串 pattern ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#一kmp-算法用途"},{"categories":["数据结构与算法"],"content":" 二、算法流程","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#二算法流程"},{"categories":["数据结构与算法"],"content":" 2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#21-举例说明1"},{"categories":["数据结构与算法"],"content":" 2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step1-首先定义两个下标-i-和-j分别指向-s-和-pattern-中待比较的字符"},{"categories":["数据结构与算法"],"content":" 2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step2-当-si--patternjij-均右移继续往下比较"},{"categories":["数据结构与算法"],"content":" 2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step3-当-si--patternji-不动j-以一定的模式进行转移具体见下面的场景"},{"categories":["数据结构与算法"],"content":" 2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step4-进而继续往下比较"},{"categories":["数据结构与算法"],"content":" 三、具体实现 func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { // 不想等需要根据前面得到的 next，更新 l // 直到相等或者 l == 0 for l \u003e 0 \u0026\u0026 pat[l] != pat[cur] {l = next[l-1]} if pat[cur] == pat[l] { l++ } next[cur] = l } return next } func KMP(s, pat string) int { n, m := len(s), len(pat) next := getNext(pat) i, j := 0, 0 for i \u003c n \u0026\u0026 j \u003c m { for j \u003e 0 \u0026\u0026 pat[j] != s[i] {j = next[j-1]} if s[i] == pat[j] { j++ } i++ } if j == m { return i - m } else { return -1 } } ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:3:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#三具体实现"},{"categories":["数据结构与算法"],"content":" 四、一些习题 https://leetcode.cn/problems/repeated-substring-pattern/ 知乎专栏. 《KMP 算法详解》. 见于 2023年4月26日. https://zhuanlan.zhihu.com/p/83334559. 《KMP算法》. 收入 维基百科，自由的百科全书, 2022年7月8日. https://zh.wikipedia.org/w/index.php?title=KMP%E7%AE%97%E6%B3%95\u0026oldid=72556055. ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:4:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#四一些习题"},{"categories":["数据结构与算法"],"content":"#算法 KMP 算法中 j 的转移是通过一个保存 j 转移信息的数组 next 来实现的，那么如何获得这个数组是 KMP 算法的关键 首先根据 KMP 的工作流程可知，next 中保存的其实是最长公共前后缀的长度，也可以理解为最长公共前后缀中前缀的下一个下标 next[i] 保存了 pattern[0,i] 这个字符串最长公共前后缀的长度 举个例子说明：pattern = “aabaac” 推导过程： 子串 最长公共前后缀 next a 无(长度为1没有前缀与后缀) 0 aa a 1 aab 无 0 aaba a 1 aabaa aa 2 aabaac 无 0 如何在 O(M) 的时间复杂度内获得这个 next 数组？ 使用两个指针，从头开始遍历 pattern： len：记录了最长公共前后缀的长度（初始 0） cur：子串结尾（初始 1） 首先初始化 next[0] = 0，所有的模式串都符合 判断 pattern[cur] == pattern[len]； 说明存在相同前后缀，那么将 len++，next[cur] = len（说明子串 pattern[0, cur] 的最长公共前缀长度为 len） 再将 cur++，继续判断下一个子串 当 pattern[cur] != pattern[len] 说明当前的子串是不存在公共前后缀的，那么将 len 重置 len = next[len-1]（找子串[0, len-1]的最大相同前后缀，直到首字符的位置 或者 pattern[len] == pattern[cur]）， end 继续右移动 这个步骤往往是容易出错的，看下面的一个例子 重复以上过程，直到获取整个 next 数组 一个错误例子： func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { if pat[cur] == pat[l] { l++ } else { // error l = 0 } next[cur] = l } return next } 测试例： pat=“afdabeafdaf” getNext() = [0 0 0 1 0 0 1 2 3 4 0], want [0 0 0 1 0 0 1 2 3 4 2] 正确实现： func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { // 不相等需要根据前面得到的 next，更新 l // 直到相等或者 l == 0 for l \u003e 0 \u0026\u0026 pat[l] != pat[cur] {l = next[l-1]} if pat[cur] == pat[l] { l++ } next[cur] = l } return next } ","date":"2023-05-09","objectID":"/202304262152-kmp-%E7%AE%97%E6%B3%95%E4%B9%8B-%E8%8E%B7%E5%8F%96-next-%E6%95%B0%E7%BB%84/:0:0","series":["算法"],"tags":[],"title":"KMP算法之-获取next数组","uri":"/202304262152-kmp-%E7%AE%97%E6%B3%95%E4%B9%8B-%E8%8E%B7%E5%8F%96-next-%E6%95%B0%E7%BB%84/#"},{"categories":["数据结构与算法"],"content":"#leetcode 希望能有成长，在此记录 ","date":"2023-05-09","objectID":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/:0:0","series":["leetcode"],"tags":["个人记录"],"title":"Leetcode 周赛记录","uri":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/#"},{"categories":["数据结构与算法"],"content":" 第一场周赛 本着就做两题的心态来的，结果也算是完成了两题，不过过程还是不尽人意，第一道简单题就wa了五次，还是有点小紧张 第二道题思考的有点久，其实就是要在一个乱序的二维数组中快速找到一个数在第几行第几列的需求，如果这些数被保证在一个不大的范围内，那么可以直接做num2Idx[数字]=下标 这样的一个映射，就能快速找到对应数字在二维数组中的下标了 不过结果也还算是符合预期了，再接再厉吧 ","date":"2023-05-09","objectID":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/:1:0","series":["leetcode"],"tags":["个人记录"],"title":"Leetcode 周赛记录","uri":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/#第一场周赛"},{"categories":["数据结构与算法"],"content":"一些题目记录一下","date":"2023-05-09","objectID":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","series":["leetcode"],"tags":["个人记录"],"title":"leetcode 做题记录 ","uri":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["数据结构与算法"],"content":"#算法 记录一些比较有意义的题目 题目 备注 2023.04.18 119 滚动数组 121 169 map的使用，数组中元素的计数 219 滑动窗口 283 双指针 303 在初始化方法中做预处理操作，减少频繁调用的方法中所做的工作量 414 使用了前面双指针的思路；也可以使用类似滑动窗口的思路，维护一个大小为3的有序集合 488 dfs 2023.04.19 496-下一个更大元素I 单调栈，（Go本身没有栈的库，但是通过数组很方便实现[[202304201957 栈]]） 2023.04.20 506-相对名次 深拷贝[[202304201947 深浅拷贝]]、go基本元素类型的降序排序 561-数组拆分 在于题目的分析，用贪心的方式来分析 556-重塑矩阵 二维数组的一维表示（m*n矩阵的第x个元素坐标：x/n，x%n） 594-最长和谐子序 错太多次了；移动窗口；数组计数，联想下标计数法 2023.04.21 674-最长连续递增序列 滑动窗口 744-寻找比目标字母大的最小字母 二分查找[[202304212107 二分查找]] 746-爬楼梯 动态规划 747 求数组的第一第二大的数 2023.04.22 1027-最长等差数列 动态规划[todo] 2023.04.23 1105-填充书架 动态规划 942-增减字符串匹配 贪心算法 914-卡牌分组 最大公约数 2023.04.24 1163 按字典序排在最后的子串【难】 后缀数组、sa-is算法（[[202304241453 后缀数组与SA-IS算法]]） 2023.04.25 125-验证回文 168-Excel表名称 26进制 2023.04.26 1031-两个非重叠子数组的最大和 动态规划+滑动窗口 综合题目 392-判断子序列 动态规划 459-重复的子字符串 KMP算法 680-验证回文 贪心 2023.04.29 剑指 Offer II 083. 没有重复元素集合的全排列 字典序 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 总结一些分类出来 数组计数 数组找第几 位运算 ","date":"2023-05-09","objectID":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:0:0","series":["leetcode"],"tags":["个人记录"],"title":"leetcode 做题记录 ","uri":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/#"},{"categories":["扩展学习"],"content":"#ChatGPT ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:0:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#"},{"categories":["扩展学习"],"content":" 一、目前互联网上已经存在的开放的站点 https://openai.com/ 官方网站，但是大部分亚洲 IP 已经被拦截，无法使用。但是可以挂 VPN （直连）到官网申请 api key，再套个 web 的外壳来使用，或者通过 jupyter notebook 来使用也可以 申请 api key 是不需要付费的，但是目前免费使用的额度只有 5 美元，超过需额外充值或者购买 ChatGPT Plus 版本 https://chatgptmirror.com/ 国内的一个镜像站点，需要收费 基于 GPT3.5turbo 和 GPT4 http://chat.gptforlove.com/ 免费 版本：ChatGPT 3.5 支持连续对话 https://chat.jinshutuan.com/ 免费 版本：非 OpenAI GTP 3.5+ 不支持连续对话 https://chatgpt.peterdavehello.org/ 免费 https://jiehan.tech/708 付费 基于 GPT3.5turbo 和 GPT4 更多站点可以参考 chatgpt-sites ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:1:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#一目前互联网上已经存在的开放的站点"},{"categories":["扩展学习"],"content":" 二、关于如何在 openai 官网申请 api key可以参考该篇文章：https://bysocket.com/openai-services-are-not-available-in-your-country/ ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:2:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#二关于如何在-openai-官网申请-api-key"},{"categories":["扩展学习"],"content":" 三、如何更好地使用 ChatGPT 来为自己工作","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:3:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#三如何更好地使用-chatgpt-来为自己工作"},{"categories":["扩展学习"],"content":" 3.1《ChatGPT Prompt Engineering for Developers》课程学习用好提示词是关键 笔记产出：[[202305062133 面向开发者的 ChatGPT 提示工程]] ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:3:1","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#31chatgpt-prompt-engineering-for-developers课程学习"},{"categories":["扩展学习"],"content":" 3.2 ChatGPT 中文调教指南《PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。》. 见于 2023年5月7日. https://github.com/PlexPt/awesome-chatgpt-prompts-zh. ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:3:2","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#32-chatgpt-中文调教指南"},{"categories":["容器"],"content":"#k8s ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#"},{"categories":["容器"],"content":" 一、概述operator 对于 k8s 来说，是一种扩展机制，开发人员可以通过 CRD，来扩展 k8s API operator 通过监视和管理 CRD，来执行一系列被预定的操作，这些操作被编写在 reconcile 逻辑里面，通过 CRD 的增加、删除、更新，可以触发不同的逻辑，在这些逻辑里面也可以对 k8s 原有的资源进行操作，比如 pod、configmap、service 等等 对于运维人员来说，operator 也是相当有用的，operator 可以负责用来做一些更高级的操作，比如扩缩容、集群的备份、恢复等操作，可以减轻运维人员的压力 ","date":"2023-05-09","objectID":"/202305080937-operator/:1:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#一概述"},{"categories":["容器"],"content":" 二、名词解释、Operator 的工作流程","date":"2023-05-09","objectID":"/202305080937-operator/:2:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#二名词解释operator-的工作流程"},{"categories":["容器"],"content":" 2.1 名词解释 GroupVersionKind GVK 是用来描述一个 kubernetes api 对象的标准 将 GroupVersionKind 拆分成三个部分来理解： Group Version Kind 在 Kubernetes 环境中可以通过命令查看： kubectl api-resources kubectl explain [kind] GroupVersionResource GroupVersionResource 和 GroupVersionKind 都是 Kubernetes API 中用于标识资源的数据结构，它们之间有一定的关系。 GroupVersionResource 由三个部分组成：group、version 和 resource。它用于唯一地标识 Kubernetes API 中的一个资源，并指定客户端对该资源执行 CRUD 操作的方式。 GroupVersionKind 也由三个部分组成：group、version 和 kind。它用于描述 Kubernetes API 中的一个对象，其中 kind 表示对象的类型，例如 Pod、Service 或 Deployment。 可以看出，GroupVersionResource 和 GroupVersionKind 的区别在于最后一个部分。GroupVersionResource 的最后一个部分是资源的名称，而 GroupVersionKind 的最后一个部分是对象的类型。但是，它们都包含了相同的前两个部分：group 和 version。这意味着，通过 GroupVersionKind 可以推断出对应的 GroupVersionResource，反之亦然。 因此，GroupVersionResource 和 GroupVersionKind 是紧密相关的概念，它们都是 Kubernetes API 中用于标识资源和对象的重要数据结构。 scheme scheme 提供了 kubernetes api 对象的序列化、反序列化的功能 在 operator 中，scheme 提供了向 kubernetes api 注册自定义对象的功能 所以每个 operator 都需要 scheme，提供了 go type 与 Kind 的映射，operator 才能与kubernetes api 更好的交互 Manager Cache、informer cache负责： 缓存 kubernetes api 对象 版本控制 索引 informer负责： 监听 kubernetes api 中的事件 当 controller 想要访问某个 api 资源，首先查找 cache 中是否存在，如果不存在再往 kuberntes api 中查找，cache 能够减少访问 kuberntes api 的次数，减轻 io 压力 为了保证缓存中的资源与 kuberntes api 中的资源保持一致，informer 需要监听 kubernetes api 中的事件，如果 kuberntes api 中的资源发生改变，cache 中也要同步变化，保证数据一致性 cache 还提供了对象的索引，提高查找效率。由于api 资源对象是具备版本的，因此 cache 也需要提供版本控制的功能，保证与 kuberntes api 中的资源是同一个版本 informer 是基于 cache 完成的一个高级组件，两者相互协作，都是为了让客户端更好的访问api 对象资源，cache主要用来做缓存、版本控制、索引的功能，informer 主要监听 kuberntes api 中的事件，更新缓存中的资源 这边顺便了解一下 ListAndWatch 机制： 与 Informer 类似，ListAndWatch 的作用也是为了让客户端或者控制器更好的获取 k8s 资源，它的大致工作流程如下： 使用 List 操作，从 Kubernetes API 获取全部的资源对象并保存 然后监听 kuberntes api 中的事件，如果对象发生更新，则对自己保存的对象也做相应更新 ","date":"2023-05-09","objectID":"/202305080937-operator/:2:1","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#21-名词解释"},{"categories":["容器"],"content":" 2.2 operator 工作流程例如当一个 CRD 创建，会经过什么样的流程 一个 crd 资源创建，首先 kubernetes api 会监听到这个资源的创建，informer 会从 kuberntes api 收到这个事件，并获取对应的 crd 资源，将这个资源反序列化成对应的 go type，然后触发控制器中的 reconcile 逻辑，完成预定的操作 动画演示[^1] crd 创建请求发送到 API Server API Server 校验请求是否合法，是否有创建这个资源的权限 通过 API Server 后，到达准入控制器（Admission Controller），根据 crd 对应的校验规则进行 crd 资源的校验。此外 Admission Controller 还可能对资源进行修改操作 至此，crd 的创建已经被允许，一个 crd 实例被创建，并保存到 etcd 中 Controller Manager 启动对应的 Controller Controller 执行相应的 reconcile 逻辑，会监听 crd 的变化，并执行相应的逻辑 ","date":"2023-05-09","objectID":"/202305080937-operator/:2:2","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#22-operator-工作流程"},{"categories":["容器"],"content":" 三、实践 创建 operator 项目的两个脚手架： kubebuilder OperatorSDK 该实践使用 kubebuilder 来完成，可参考： kubebuilder quick start 环境信息： go1.17.10 kubelet v1.19.4 docker 20.10.12 kubebuilder 3.4.0 kustomize v4.5.4 初始化项目 kubebuilder init --domain example.com --repo demo.domain/demo-operator kubebuilder create api --group demo --version v1 --kind Demo 修改api/v1/xxx_types.go make manifests 会生成对应的 crd yaml 文件 ./ ├── ... ├── config .. ├── crd ├── bases └── demo.example.com_demoes.yaml 构建 operator 镜像 docker build -t 904566722/kubebuilder-demo-operator:1.0.0 . docker push 904566722/kubebuilder-demo-operator:1.0.0 部署 crd make install # $(KUSTOMIZE) build config/crd | kubectl apply -f - 部署 rbac 相关 yaml kubectl apply -f config/rbac/ 创建 manager controller 修改 image 为上面制作的 operator 镜像 kubectl apply -f config/manager/manager.yaml pod 成功运行之后，创建 cr 实例 apiVersion: demo.example.com/v1 kind: Demo metadata: name: demo-sample spec: size: 19 type: demo config_map_name: demo kubectl apply -f config/samples/demo_v1_demo.yaml operator 监听到 Demo kind 资源的创建，出发 reconcile： ","date":"2023-05-09","objectID":"/202305080937-operator/:3:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#三实践"},{"categories":["容器"],"content":" 参考资料 Kubernetes Operator 开发教程 kustomization管理k8s对象 ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#参考资料"},{"categories":["Golang"],"content":"#Golang 在使用 for-range 遍历 string 中每个字符的时候，取出来的值是什么类型？ ![[Pasted image 20230423173934.png]] func isAlienSorted(words []string, order string) bool { // 首先要将 order 顺序映射成数值，来做比较 orderNums := make(map[rune]int, len(order)) for i, ch := range order { fmt.Println(reflect.TypeOf(order[i])) // uint8 fmt.Printf(\"%c\", order[i]) fmt.Println(reflect.TypeOf(ch)) // int32 fmt.Printf(\"%c\", ch) orderNums[ch] = i } return false } 对比：在遍历字符串的时候，有两种获取值的方式，如上面代码中的 ch、order[id]（索引的方式） ch 实际上的类型是 int32（与 rune 相同，应该是考虑到 string 中如果存储了中文字符，能够直接使用 “%c” 的表达式将这个中文输出） order[i] 实际上的类型是 uint8 （与 byte 相同，也就是一个字符的大小，占一个字节，但没法输出中文字符） ","date":"2023-05-09","objectID":"/202304231751-string-%E9%81%8D%E5%8E%86/:0:0","series":["Golang为什么"],"tags":["string","for range"],"title":"string 遍历","uri":"/202304231751-string-%E9%81%8D%E5%8E%86/#"},{"categories":["Golang"],"content":"#Golang #struct 直接看一个例子，熟悉 struct 的简单使用： // ** struct practice type person struct { name string age int32 } func structPractice() { people := \u0026person{ name: \"索隆不喝酒\", age: 20, } fmt.Println(people) // \u0026{索隆不喝酒 20} fmt.Println(*people) // {索隆不喝酒 20} fmt.Println(\u0026people) // 0x1400000e038 fmt.Printf(\"[value]\\tname:%s\\tage:%d\\n\", people.name, people.age) // [value] name:索隆不喝酒 age:20 fmt.Printf(\"[value]\\tname:%s\\tage:%d\\n\", (*people).name, (*people).age) // [value] name:索隆不喝酒 age:20 fmt.Printf(\"[addr]\\tname:%d\\tage:%d\\n\", \u0026people.name, \u0026people.age) // [addr] name:1374389584016 age:1374389584032 } struct 存在方法集的概念，即所属于一个类型的方法的集合 202304241738 struct 方法集 ","date":"2023-05-09","objectID":"/202304241633-struct/:0:0","series":["Golang初识"],"tags":["struct"],"title":"struct","uri":"/202304241633-struct/#"},{"categories":["Golang"],"content":"#Golang #struct Go 语言中 struct 存在方法集（method set）的概念，看下面一段代码 type T struct { a int } func (t T) M1() { t.a++ } func (t *T) M2() { t.a++ } func structPractice2() { var t1 T var t2 = \u0026T{} fmt.Println(reflect.TypeOf(t1)) // T fmt.Println(reflect.TypeOf(t2)) // *T t1.M1() t1.M2() // (\u0026t1).M2() t2.M1() // (*t2).M1() t2.M2() } 变量 类型 方法集 t1 T {M1} t2 *T {M1,M2} 那么为什么 t1.M2() 不报错？ 可以看到 t1 的方法集只有 M1，M2方法的接收者类型是 *T 但是为什么 t1.M2() 这段代码不报错，这是由于 Go 语言提供的语法糖，Go 的编译器判断 t1 的类型为 T，跟 M2 方法的接收者不一致，自动转化成了 (\u0026t1).M2()；同理可解释 t2.M1() 那么既然存在这样的语法糖，来看看这样调用是不是可行的： T{}.M2() // Cannot call a pointer method on 'T{}' (\u0026T{}).M2()//OK (\u0026T{}).M1()//ok 会直接报错：无法通过 T{} 来调用一个指针方法 原因其实是上面提到的语法糖有一个前提： T 类型的实例，需要是可被取地址的（addressable） 《为什么这个T类型实例无法调用*T类型的方法 | Tony Bai》. 见于 2023年4月24日. https://tonybai.com/2022/02/27/go-addressable/. 鸟窝. 《go addressable 详解》, 2018年2月27日. https://colobu.com/2018/02/27/go-addressable/. 吴润写字的地方. 《Golang 不可寻址的理解》, 2021年11月12日. http://www.wu.run/2021/11/12/not-addressable-in-golang/index.html. ","date":"2023-05-09","objectID":"/202304241738-struct-%E6%96%B9%E6%B3%95%E9%9B%86/:0:0","series":["Golang为什么"],"tags":["struct"],"title":"struct 方法集概念","uri":"/202304241738-struct-%E6%96%B9%E6%B3%95%E9%9B%86/#"},{"categories":["Golang"],"content":"#Golang #unsafe 概念：Pointer 表示一个指针，可以指向任何类型 四个特殊操作： 任何类型的指针值 可转化为 Pointer Pointer 可转化为 任何类型的指针值 uintptr 可转化为 Pointer Pointer 可转化为 uinptr 由于以上四个特性，Pointer 能够实现让程序绕过类型系统，读写任意内存（使用时需格外小心） ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:0:0","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#"},{"categories":["Golang"],"content":" 下面列举 unsafe 包中列举的 unsafe.Pointer 使用的六种场景","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:0","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#下面列举-unsafe-包中列举的-unsafepointer-使用的六种场景"},{"categories":["Golang"],"content":" （1）*T1 –\u003e Pointer –\u003e *T2需要满足要求： T2 不大于 T1 T1、T2 共享相同的内存布局 (202304242150 内存布局) 则这种转换是允许的 例子1. 一个 float64 值转为 uint64 的值 func float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(\u0026f)) } 另外一个例子，将字符串转换为字节切片，首先我们看一下在 64 位系统中两者的尺寸 var s string var bs []byte fmt.Println(unsafe.Sizeof(s)) // 16 fmt.Println(unsafe.Sizeof(bs)) // 24 字符串 16 字节 字节切片 24 字节 字符串与字节切片的内存布局类似，且字节切片的尺寸不小于字符串的尺寸，因此将字节切片转到字符串是安全的，让我们来看实现： func byteSlice2String(bs []byte) string { return *(*string)(unsafe.Pointer(\u0026bs)) } 这种实现的优点是避免了底层对字节序列的一次开辟和复制 而如果要用此方式来实现从 string 到 []byte 则是不安全的： // 这种转换是不安全的 func string2Bytes(s string) []byte { return *(*[]byte)(unsafe.Pointer(\u0026s)) } ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:1","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#1t1----pointer----t2"},{"categories":["Golang"],"content":" （2）Pointer –\u003e uintptr （用途少）从指针转到 uintptr 类型实际上产生了一个没有指针语义的整数（代表指针指向值的内存地址，只是一个整数，不是引用），所以这种情况下，再将 uintptr 转回指针是无效的，通常的用法是将这个 uintptr 打印出来 即使uintptr保存了某个对象的地址，如果对象移动，垃圾收集器也不会更新该uintptr的值，也不会阻止该对象被回收 下面的情况说明了从 uintptr 转到 Pointer 的可能场景 ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:2","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#2pointer----uintptr-用途少"},{"categories":["Golang"],"content":" （3）算数运算 （Pointer –\u003e uintptr –\u003e 运算 –\u003e Pointer）这种操作通常是用来访问： 结构的字段 数组的元素 一个例子： // ** 通过 uintptr 来访问结构中的字段、数组的元素 ** type T struct { a int16 arr [3]int32 } func uintptr2PointerPractice() { // unsafe.Sizeof(T{}.a) // 2 M := unsafe.Offsetof(T{}.arr) // 4 N := unsafe.Sizeof(T{}.arr[0]) // 4 fmt.Println(unsafe.Sizeof(T{}.a)) // 2 fmt.Println(unsafe.Sizeof(T{}.arr)) // 3 * 4 = 12 fmt.Println(unsafe.Sizeof(T{})) // 16 t := \u0026T{ arr: [3]int32{1, 2, 3}, } // 直接访问 t.arr 的最后一个元素 tp := unsafe.Pointer(t) // 先将 t 转为非安全指针 // 将 uintptr 进行算数运算后再转为非安全指针 arrp := unsafe.Pointer(uintptr(tp) + M + N + N) // 将非安全指针转为数组元素类型指针 ans := (*int32)(arrp) // ans := (*int32)(unsafe.Pointer(uintptr(tp) + M + N + N)) fmt.Println(*ans) // output: 3 } 特别注意在这种场景下，可能会发生的很隐秘的 bug： func uintptr2PointerPractice2() { // unsafe.Sizeof(T{}.a) // 2 M := unsafe.Offsetof(T{}.arr) // 4 N := unsafe.Sizeof(T{}.arr[0]) // 4 t := T{ arr: [3]int32{1, 2, 3}, } uptr := uintptr(unsafe.Pointer(\u0026t)) + M + N + N // 中间其他操作 elemP := (*int32)(unsafe.Pointer(uptr)) fmt.Println(*elemP) // output: 3 } 前面提到了，虽然 uintptr 保存了 t 的地址的值，但是并不会阻止垃圾回收机制将 t 回收，所以在中间其他操作的时候，一旦 t 被回收，后面的地址将指向不可预测的内容。 实际上，像 Goland 编码工具在编码的时候就会给出提示： ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:3","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#3算数运算-pointer----uintptr----运算----pointer"},{"categories":["Golang"],"content":" （4）Pointer –\u003e uintptr –\u003e syscall在 syscall 系统调用中，可能会根据调用的具体实现将 uintptr 重新转为指针 注意：转换必须在调用的表达式中出现，在系统调用期间隐式转换为指针之前，uintptr 不能保存在变量中 正确： syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n)) 错误 u := uintptr(unsafe.Pointer(p)) // p 所引用的对象可能在这个时候被垃圾回收，或者 p 的地址发生改变 syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n)) ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:4","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#4pointer----uintptr----syscall"},{"categories":["Golang"],"content":" （5）将 reflect.Value.Pointer 或者 reflect.Value.UnsafeAddr 的结果从 uintptr 转到 Pointer","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:5","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#5将-reflectvaluepointer-或者-reflectvalueunsafeaddr-的结果从-uintptr-转到-pointer"},{"categories":["Golang"],"content":" （6）将一个reflect.SliceHeader或者reflect.StringHeader值的Data字段转换为非类型安全指针，以及其逆转换首先我们来看reflect.SliceHeader 和 reflect.StringHeader 的定义： // StringHeader是字符串的运行时表示形式。 // 它不能安全或可移植地使用，并且它的表示可能在以后的版本中更改。 // 此外，Data字段不足以保证它引用的数据不会被垃圾收集， // 因此程序必须保留一个单独的、类型正确的指向底层数据的指针。 type StringHeader struct { Data uintptr Len int } // SliceHeader是切片的运行时表示。 // 它不能安全或可移植地使用，并且它的表示可能在以后的版本中更改。 // 此外，Data字段不足以保证它引用的数据不会被垃圾收集， // 因此程序必须保留一个单独的、类型正确的指向底层数据的指针。 type SliceHeader struct { Data uintptr Len int Cap int } 一个使用 StringHeader 的例子： func uintptrPractice4() { a := [...]byte{'a', 'b', 'c', 'd', 'e'} b := \"java\" hdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026b)) hdr.Data = uintptr(unsafe.Pointer(\u0026a)) hdr.Len = len(a) // 至此，a 和 b 共享底层的字节序列 a[1], a[2], a[3], a[4] = 'a', 'a', 'a', 'a' fmt.Println(b) // out: aaaaa } 将字符串指针转为*StringHeader，从而可以对字符串的内部进行修改 《非类型安全指针 -Go语言101》. 见于 2023年4月25日. https://gfw.go101.org/article/unsafe.html. ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:6","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#6将一个reflectsliceheader或者reflectstringheader值的data字段转换为非类型安全指针以及其逆转换"},{"categories":["数据结构与算法"],"content":"#算法 递归能够解决的问题的特点： 原问题能够分解成一个更小的与原问题解决思路相同的子问题 递归的步骤： 拆分问题，找使用子问题解决原问题的方法（原问题与子问题的关系） 找子问题的解决方法，当与原问题的解决方法一致，便能够递归 结束的条件 时间复杂度 可以将编码的过程总结为： 1. 定义方法 2. 写明结束条件 3. 根据原问题、子问题之间的逻辑关系写主要的递归逻辑 递归存在的问题： 栈溢出 重复计算 ","date":"2023-05-09","objectID":"/202304300007-%E9%80%92%E5%BD%92/:0:0","series":["算法"],"tags":[],"title":"递归","uri":"/202304300007-%E9%80%92%E5%BD%92/#"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":" 二叉搜索树树概述二叉搜索树：左子树所有节点的值 \u003c 根节点 \u003c 右子树所有节点的值 二叉搜索树的相关操作： 构建 判断 删除节点 增加节点 ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:1:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#二叉搜索树树概述"},{"categories":["数据结构与算法"],"content":" 相关操作","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#相关操作"},{"categories":["数据结构与算法"],"content":" 判断是否是二叉搜索树递归实现 // 递归实现 // 从二叉搜索树当前节点的值可以推出左右节点的取值区间，递归判断每个节点即可 func isValidBST(root *TreeNode) bool { if root == nil { return true } return jud(root, math.MinInt, math.MaxInt) } func jud(root *TreeNode, start, end int) bool { if root == nil { return true } if root.Val \u003c= start || root.Val \u003e= end { return false } return jud(root.Left, start, root.Val) \u0026\u0026 jud(root.Right, root.Val, end) } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:1","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#判断是否是二叉搜索树"},{"categories":["数据结构与算法"],"content":" 插入节点递归实现 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } if val \u003c root.Val { root.Left = insertIntoBST(root.Left, val) } else { root.Right = insertIntoBST(root.Right, val) } return root } 非递归实现 func insertIntoBST2(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } pre := root tmpRoot := root for tmpRoot != nil { if val \u003c tmpRoot.Val { pre = tmpRoot tmpRoot = tmpRoot.Left } else { pre = tmpRoot tmpRoot = tmpRoot.Right } } newNode := \u0026TreeNode{Val: val} if val \u003c pre.Val { pre.Left = newNode } else { pre.Right = newNode } return root } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:2","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#插入节点"},{"categories":["数据结构与算法"],"content":" 删除节点 // 如果找到该节点，有四种情况： // 没有左节点，直接将右子树代替该节点的位置 // 没有右节点，直接将左子树代替该节点的位置 // 均有左右节点，根据中序节点的性质，当前的序列为：左子树、当前节点、右子树的最左节点 // 删除当前节点之后，为了保持中序，需要将左子树嫁接到右子树的最左节点的左节点，然后将右子树的根节点替换当前节点的位置 // 均没有左右节点（叶子节点），直接删除该节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } var curParent *TreeNode = nil cur := root for cur != nil \u0026\u0026 cur.Val != key { curParent = cur if key \u003c cur.Val { cur = cur.Left } else { cur = cur.Right } } // not found if cur == nil { return root } if cur.Left != nil \u0026\u0026 cur.Right != nil { rightMinNode := cur.Right for rightMinNode.Left != nil { rightMinNode = rightMinNode.Left } rightMinNode.Left = cur.Left cur = cur.Right } else if cur.Left != nil { cur = cur.Left } else if cur.Right != nil { cur = cur.Right } else { cur = nil } if curParent == nil { return cur } if curParent.Left != nil \u0026\u0026 curParent.Left.Val == key { curParent.Left = cur } else { curParent.Right = cur } return root } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:3","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#删除节点"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#"},{"categories":["数据结构与算法"],"content":" 归并排序的思想归并排序是一种采用了递归思想的排序，采用递归[[202304300007 递归]]的思想来分析就是： 原问题 \u0026 解决方法 原问题：将 nums 排序 解决办法：将数组 nums 分成两个序列 nums1、nums2，将 nums1、nums2 排序后合并 子问题 \u0026 解决方法 子问题：将 nums1、nums2 排序 解决办法：两个子数组都能够通过原问题的解决办法解决 结束条件：当数组不能再划分（长度=1） 时间复杂度： 合并的平均时间复杂度O(n) x 拆分的深度 logn = O(nlogn) ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#归并排序的思想"},{"categories":["数据结构与算法"],"content":" 实现Golang： // 1. 定义方法：将左右两个已经有序的序列合并成一个序列（原问题得解：原数组有序） // 2. 子问题：左右的数组需要有序，与原问题解决方法相同 // 3. 结束条件：数组的长度为 1 func mergeSort(nums []int) []int { // 结束条件 if len(nums) \u003c= 1 { return nums } // 子问题关系 mid := len(nums) / 2 left := mergeSort(nums[:mid]) right := mergeSort(nums[mid:]) // 方法定义 return merge(left, right) } // 将两个有序数组合并 func merge(nums1, nums2 []int) []int { n1, n2 := len(nums1), len(nums2) nums := make([]int, n1 + n2) i, j, idx := 0, 0, 0 for i \u003c n1 \u0026\u0026 j \u003c n2 { if nums1[i] \u003c nums2[j] { nums[idx] = nums1[i] i++ } else { nums[idx] = nums2[j] j++ } idx++ } for ; i \u003c n1; i++ { nums[idx] = nums1[i] idx++ } for ; j \u003c n2; j++ { nums[idx] = nums2[j] idx++ } return nums } 1.《图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园》. 见于 2023年4月30日. https://www.cnblogs.com/chengxiao/p/6194356.html. ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#实现"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":" 一、后缀数组概念：将 s 的所有后缀排序后的数组 见下面的一个例子： ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#一后缀数组"},{"categories":["数据结构与算法"],"content":" 在 Go 中获得后缀数组的方法 type Index struct { _ []byte sa []int32 } func lastSubstring3(s string) string { index := suffixarray.New([]byte(s)) idx := (*Index)(unsafe.Pointer(index)) fmt.Println(idx.sa) // s=\"aabaaaab\" output:[3 4 5 0 6 1 7 2] return \"\" } 思考： unsafe.Pointer 的使用 (202304241708 unsafe.Pointer 的六种使用场景) 为什么是 (*Index) 这样的写法？ 顺便复习下 struct 结构体（202304241633 struct） ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:1:1","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#在-go-中获得后缀数组的方法"},{"categories":["数据结构与算法"],"content":" 二、SA-IS 算法概念：（Suffix Array Induce Sort；SA-IS） todo 参考资料： 《诱导排序与SA-IS算法 - riteme.site》. 见于 2023年4月24日. https://riteme.site/blog/2016-6-19/sais.html. 第一次接触到后缀数组以及SA-IS算法是在leetcode每日一题（1163.按字典序排在最后的字串）中 ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#二sa-is-算法"},{"categories":["数据结构与算法"],"content":"#算法 复习一下基本的排序算法 有几种基本的排序算法： 冒泡排序 选择排序 插入排序 希尔排序（递减增量的排序；插入排序的改进版本） 归并排序 快速排序 桶排序 堆排序 计数排序 基数排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":" 一、冒泡步骤： 一直往前走，比较相邻两个数，大数往后放 func bubbleSort(nums []int) { if len(nums) \u003c= 1 { return } // nums: 6 10 2 4 7 3 2 1 2 // loop1 j (loop2每进行一轮往前移，直到1) // loop2 i for j := len(nums)-1; j \u003e= 1; j--{ for i := 0; i \u003c j; i++ { if nums[i] \u003e nums[i+1] { swap(\u0026nums[i], \u0026nums[i+1]) } } } } 时间复杂度分析：O(n^2) 第一轮比较 n-1 次 第二轮比较 n-2 次 …. 第n-1轮比较 1 次 1 + 2 + … + (n-1) = n (n-1 + 1) / 2 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#一冒泡"},{"categories":["数据结构与算法"],"content":" 二、选择排序步骤： 每次从未排序找最小 func selectSort(nums []int) { for i := 0; i \u003c len(nums)-1; i++ { minIdx := i for j := i+1; j \u003c len(nums); j++ { if nums[j] \u003c nums[i] { minIdx = j } } swap(\u0026nums[i], \u0026nums[minIdx]) } } 时间复杂度也是 O(n^2) ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#二选择排序"},{"categories":["数据结构与算法"],"content":" 三、插入排序步骤： 从已排序找合适的位置 func insertSort(nums []int) { // nums 1 2 5 3 4 // i (i极其右边为一个 未排序的序列) // j=i-1 (j 负责往前找大于等于cur的值) for i := 1; i \u003c len(nums); i++ { cur := nums[i] j := i-1 for ; j\u003e=0 \u0026\u0026 nums[j]\u003ecur; j-- { nums[j+1] = nums[j] } // 由于 j 当前的位置小于或者等于cur or 越界 // 故把前面一个位置，给到cur（前面的数已经往前前的位置移动） nums[j+1] = cur } } ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#三插入排序"},{"categories":["数据结构与算法"],"content":" 四、归并排序202304300231 归并排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#四归并排序"},{"categories":["数据结构与算法"],"content":" 五、快速排序202304300312 快速排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#五快速排序"},{"categories":["扩展学习"],"content":"#ChatGPT ","date":"2023-05-09","objectID":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/:0:0","series":["ChatGPT"],"tags":["jupyter"],"title":"可以在什么平台上使用 openai","uri":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/#"},{"categories":["扩展学习"],"content":" 一、使用 jupyter notebook前置： 安装 python 安装 jupyter notebook 加载环境、定义方法： import openai import os from dotenv import load_dotenv, find_dotenv _ = load_dotenv(find_dotenv()) openai.api_key = 'sk-xxxxx' def get_completion(prompt, model=\"gpt-3.5-turbo\"): messages = [{\"role\": \"user\", \"content\": prompt}] response = openai.ChatCompletion.create( model=model, messages=messages, temperature=0, # this is the degree of randomness of the model's output ) return response.choices[0].message[\"content\"] 使用时传入 prompt 参数： prompt = f\"\"\" She no went to the market 上面这句英文存在什么样的语法错误 \"\"\" response = get_completion(prompt) print(response) 效果： 在线演示：https://learn.deeplearning.ai/chatgpt-prompt-eng/lesson/2/guidelines ","date":"2023-05-09","objectID":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/:1:0","series":["ChatGPT"],"tags":["jupyter"],"title":"可以在什么平台上使用 openai","uri":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/#一使用-jupyter-notebook"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#"},{"categories":["数据结构与算法"],"content":" 快速排序的思想快速排序采用了分治的思想，可以通过递归来实现 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:1:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的思想"},{"categories":["数据结构与算法"],"content":" 步骤 原问题 \u0026 解决办法 原问题：nums 数组排序 解决办法：选一个元素作为基准，将小于基准的数放到左边，大于基准的数放到右边（分区间） 子问题 \u0026 解决办法 子问题：左右区间的排序 解决办法：同原问题 结束条件：数组只有一个元素 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:2:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#步骤"},{"categories":["数据结构与算法"],"content":" 实现 // nums 数组排序 func quickSort(nums []int, start, end int) { // 结束条件 if start \u003e= end { return } // 子问题关系 pivot := partition(nums, start, end) quickSort(nums, start, pivot) quickSort(nums, pivot+1, end) return } func partition(nums []int, start, end int) int { if start == end { } pivot := start idx := start + 1 for i := start+1; i \u003c= end; i++ { if nums[i] \u003c nums[pivot] { swap(\u0026nums[i], \u0026nums[idx]) idx++ } } swap(\u0026nums[pivot], \u0026nums[idx-1]) return idx-1 } 《1.6 快速排序 | 菜鸟教程》. 见于 2023年4月30日. https://www.runoob.com/w3cnote/quick-sort-2.html. ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:3:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#实现"},{"categories":["扩展学习"],"content":"#ChatGPT 该篇笔记源于课程：https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/ ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:0:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#"},{"categories":["扩展学习"],"content":" 一、包含什么内容？两个产出： 使用大型语言模型（Large Language Model，LLM）快速构建功能强大的应用程序 构建两项能力： 学习创新 创造价值 了解 LLM 的工作原理 提示工程的最佳实践 如何编写有效的提示（两个原则） 如何设计好的提示 如何构建自己的聊天机器人 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:1:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#一包含什么内容"},{"categories":["扩展学习"],"content":" 二、提示词准则","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#二提示词准则"},{"categories":["扩展学习"],"content":" 2.1 指令要清晰 输入清晰 输出清晰 过程清晰 输入要清晰 清楚表明我想要的是什么？以此引导模型产出更符合我们期待的结果，避免跑题。注意清晰 != 简短，如果较长的描述更能准确表达我们的意图，那么这是必要的。 一些帮助符号： “” ``` --- \u003c\u003e … 有时候为了能够更清晰的表明意图，我们可以使用一些符号来辅佐说明。 例子： 你现在作为一名学生，需要对我的提问做出回答，ChatGPT Prompt Engineering for Developers 这门课讲述了什么 “您应该清晰且尽可能具体地表达您希望模型执行的操作，这将引导模型达到所预期的输出，并减少不相关的输出，或者不正确的输出。不要把写一个清晰的提示和写一个简短的提示混为一谈，许多情况下，较长的提示为模型提供了更清晰的背景，这可能会导致更加详细和相关的产出” 将由双引号限定的文字概括成一句话 上面的例子中，我们使用到了双引号来界定应该要总结的内容，引导模型产生我们想要的输出，当然这只是一个简单的例子，实际中可以更灵活地来使用 输出要清晰 上面的提到了如何更清晰地告诉模型应该输入的内容，下面我们应该告诉模型我们想要什么样的结果，我们可以结构化我们的输出，有时候我们可以将输出格式化为 html、json、markdown 等格式 看这样的一个例子 当然，更多时候 json 的 key 应该是英文，我们可以接着告诉 gpt： 有时候我们可能没有办法一次就描述清楚我们想要的，那么我们就可以继续补充，这是一个迭代的过程 过程要清晰 在处理的过程中，我们可以指定模型一些判断条件 看下面的例子 “泡一杯茶很简单！ 首先，你需要让水沸腾。 发生这种情况时， 拿一个杯子，在里面放一个茶包。 一旦水足够热，只需将其倒在茶包上即可。 让它静置一会儿。 再过几分钟，取出茶包。 如果你喜欢，可以加点糖或者牛奶调味。 就是这样！ 你有了自己的美味的一杯茶来享受。” 将上面由双引号限定的文本以下面的格式来重写： 第一步 - ... 第二步 - ... 第三步 - ... 第N步 - ... 如果文本不包含顺序指示，那么只需要写上“没有提供步骤” 上面的文本识别到了顺序指示，因此将文本以分步的形式重新组织了，同样的处理方式，我们来看另外一段文本： 今天阳光明媚，鸟儿们在唱歌。这是一个美丽的日子，可以去公园里散步。树木在微风中轻轻摇曳。 一些人正在野餐，而另一些人正在玩游戏或只是在草地上放松。这是一个 这是一个完美的日子，可以花时间在户外，欣赏自然之美。 将上面由双引号限定的文本以下面的格式来重写： 第一步 - ... 第二步 - ... 第三步 - ... 第N步 - ... 如果文本不包含指令序列，那么只需要写上“没有提供步骤” 可以看到通过判断，达到了我们想要的结果 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:1","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#21-指令要清晰"},{"categories":["扩展学习"],"content":" 2.2 给模型思考的时间 指定步骤来完成任务 看这样一个例子： “在一个迷人的村庄里，兄妹杰克和吉尔出发去山顶的井里取水。他们一边唱着欢快的歌，一边爬山，但不幸的是，杰克绊倒在石头上，从山上滚了下来，吉尔也跟着摔倒。虽然有些受伤，但他们还是回家受到安慰的拥抱。尽管遭遇了不幸，但他们的冒险精神仍然没有消失，他们继续愉快地探索。” 执行下面的动作： 1 - 用一句话总结上面引号括起来的文本 2 - 将第一步得到的总结翻译成韩语 3 - 在韩语总结中列出每个名字 用换行把每一步的答案分开 在这个例子中，我们想要完成的并不只是一种操作，我们对于一段文本可能想做好几件事，那么就可以分成几个步骤，告诉模型分别要做什么 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:2","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#22-给模型思考的时间"},{"categories":["扩展学习"],"content":" * 模型的限制在模型训练的过程中，并不会完美的记住自己接触的每个信息，因此它对自己的知识边界并不是十分了解，这意味着它可能会尝试回答一些晦涩难懂的问题，并且可以编造一些听起来很有道理，但实际上并不真实的事情，如下面的例子 这并不是真实的，但看起来非常真实，这是非常危险的，也是模型已知的一个问题 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:3","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#-模型的限制"},{"categories":["扩展学习"],"content":" 三、提示词的迭代由于某些原因，我们第一次获得的结果可能对于我们来说并不是有效、有用的，但是我们可以通过获得的结果，反复完善我们的提示词，一步步走向我们的想要的结果。 因此迭代的过程可以分为以下几步： 先试试 分析结果，是否符合我们预期 给出清楚的说明（指示），给模型更多时间思考 完善提示语 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:3:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#三提示词的迭代"},{"categories":["扩展学习"],"content":" 四、总结摘要例子1： 把以下产品评论进行总结，总结的字数不超过30个字。 产品评论：\"我为女儿的生日买了这只熊猫毛绒玩具，她非常喜欢，并且随身携带。它摸起来很软，非常可爱，脸上还有友好的表情。但是，相对于价格来说，它有点小了。我认为可能会有其他同样价位但更大的选择。它比预期提前一天到达，所以在把它送给女儿之前，我自己先玩了一下。\" 如果把上面的任务稍微修改一下， 你的任务是对一个电子商务网站的产品评论生成一个简短的摘要，以反馈给航运部门。 把以下产品评论进行总结，总结的字数不超过30个字, 重点放在提到产品运输和交付的任何方面。 产品评论：\"我为女儿的生日买了这只熊猫毛绒玩具，她非常喜欢，并且随身携带。它摸起来很软，非常可爱，脸上还有友好的表情。但是，相对于价格来说，它有点小了。我认为可能会有其他同样价位但更大的选择。它比预期提前一天到达，所以在把它送给女儿之前，我自己先玩了一下。\" 我们可以根据想要总结的方式，要求它提取不同的信息 再来看一个可能实际中更能碰倒的例子： # review for a standing lamp review_1 = \"\"\" Needed a nice lamp for my bedroom, and this one \\ had additional storage and not too high of a price \\ point. Got it fast - arrived in 2 days. The string \\ to the lamp broke during the transit and the company \\ happily sent over a new one. Came within a few days \\ as well. It was easy to put together. Then I had a \\ missing part, so I contacted their support and they \\ very quickly got me the missing piece! Seems to me \\ to be a great company that cares about their customers \\ and products. \"\"\" # review for an electric toothbrush review_2 = \"\"\" My dental hygienist recommended an electric toothbrush, \\ which is why I got this. The battery life seems to be \\ pretty impressive so far. After initial charging and \\ leaving the charger plugged in for the first week to \\ condition the battery, I've unplugged the charger and \\ been using it for twice daily brushing for the last \\ 3 weeks all on the same charge. But the toothbrush head \\ is too small. I’ve seen baby toothbrushes bigger than \\ this one. I wish the head was bigger with different \\ length bristles to get between teeth better because \\ this one doesn’t. Overall if you can get this one \\ around the $50 mark, it's a good deal. The manufactuer's \\ replacements heads are pretty expensive, but you can \\ get generic ones that're more reasonably priced. This \\ toothbrush makes me feel like I've been to the dentist \\ every day. My teeth feel sparkly clean! \"\"\" # review for a blender review_3 = \"\"\" So, they still had the 17 piece system on seasonal \\ sale for around $49 in the month of November, about \\ half off, but for some reason (call it price gouging) \\ around the second week of December the prices all went \\ up to about anywhere from between $70-$89 for the same \\ system. And the 11 piece system went up around $10 or \\ so in price also from the earlier sale price of $29. \\ So it looks okay, but if you look at the base, the part \\ where the blade locks into place doesn’t look as good \\ as in previous editions from a few years ago, but I \\ plan to be very gentle with it (example, I crush \\ very hard items like beans, ice, rice, etc. in the \\ blender first then pulverize them in the serving size \\ I want in the blender then switch to the whipping \\ blade for a finer flour, and use the cross cutting blade \\ first when making smoothies, then use the flat blade \\ if I need them finer/less pulpy). Special tip when making \\ smoothies, finely cut and freeze the fruits and \\ vegetables (if using spinach-lightly stew soften the \\ spinach then freeze until ready for use-and if making \\ sorbet, use a small to medium sized food processor) \\ that you plan to use that way you can avoid adding so \\ much ice if at all-when making your smoothie. \\ After about a year, the motor was making a funny noise. \\ I called customer service but the warranty expired \\ already, so I had to buy another one. FYI: The overall \\ quality has gone done in these types of products, so \\ they are kind of counting on brand recognition and \\ consumer loyalty to maintain sales. Got it in about \\ two days. \"\"\" reviews = [review_1, review_2, review_3, review_4] 你的任务是将上面的每个review分别做总结，总结以下面的格式输出： 1. 2. 将总结翻译成中文 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:4:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#四总结摘要"},{"categories":["扩展学习"],"content":" 五、AI 推理提取情绪信息 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:5:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#五ai-推理"},{"categories":["扩展学习"],"content":" 六、AI 转译 翻译 语法纠正、校对 格式转换（json、html、markdown…） 语气转换 （语气转换）不同的邮件对象可能需要不同的语气或者书面语，看下面的例子 将下面的内容从俚语转换成一封商务信函： “伙计，我是乔，看看这个立灯的规格。” ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:6:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#六ai-转译"},{"categories":["扩展学习"],"content":" 七、扩写（文案生成）扩写是指将一篇较短的文本进行扩写的工作，比如一套指示或者一个主题列表，生成一个较长的文本，如电子邮件或者文章。 例子：通过一名客户对于产品的评论生成一封回复邮件 你是一个客户服务的AI助理，你的任务是给一个有价值的客户发送电子邮件回复。 邮件的内容需要基于用户的评价，如果用户的情绪是积极的或者中性的，感谢他们的评论，如果情绪是负面的，则表示歉意，并建议他们可以联系客服。 确保使用用户评论中的具体细节。 用简明和专业的语气来写。 在邮件中署名：“AI 客户代理” 客户的评论：\"他们在11月份仍在季节性销售中以约49美元的价格销售17件套装，折扣约为一半，但出于某些原因（称其为价格抬高），到了12月的第二周，同样的系统的价格都涨到了约70-89美元左右。 11件套装的价格也比之前的29美元涨了大约10美元左右。 看起来还不错，但如果您看底座，锁定刀片的部分看起来与几年前的先前版本不太一样，但我打算非常小心（例如，我将像豆子，冰，米饭等非常硬的物品先放入搅拌机中压碎，然后把它们粉碎成我想要的食用量，然后切换到搅拌餐的鞭打刀，以获得更细的面粉，并在制作冰沙时先使用交叉切割刀，然后如果需要更细/较少纤维的话，再使用平刀）。制作冰沙的特殊提示：将要使用的水果和蔬菜切碎并冷冻（如果使用菠菜-轻轻煮软菠菜然后冷冻直到使用-如果制作雪泥，请使用小到中型食品处理器），以此来避免添加掉太多冰块。大约一年后，马达发出奇怪的噪音。我打电话给客服，但保修已经过期了，所以我不得不再买一个。 FYI：这些产品的整体质量已经下降，所以他们在品牌认知和消费者忠诚度上进行营销。大约两天后收到了产品。\" ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:7:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#七扩写文案生成"},{"categories":["扩展学习"],"content":" temperaturetemperature 作为模型的一个参数，将影响模型输出的随机性 显然：越低 temperature 意味着越高可靠性，越高 temperature 意味着越高创意性 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:7:1","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#temperature"},{"categories":["扩展学习"],"content":" 八、聊天机器人待补充… 《ChatGPT Prompt Engineering for Developers》. 见于 2023年5月7日. https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/. 二次元的Datawhale. 《【专业翻译，配套代码笔记】01.课程介绍_哔哩哔哩_bilibili》. 见于 2023年5月7日. https://www.bilibili.com/video/BV1Bo4y1A7FU/. ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:8:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#八聊天机器人"},{"categories":["Golang"],"content":"#Golang 问题：两个数据有相同的内存布局，应该满足什么条件？ ","date":"2023-05-09","objectID":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","series":["Golang底层认知"],"tags":["内存布局"],"title":"内存布局","uri":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/#"},{"categories":["Golang"],"content":" 类型对齐保证出于对程序性能的考虑，每个类型都会有对应的对齐保证，根据该类型是否被作为结构字段，对齐保证分为两类： 字段对齐保证 一般对齐保证 说法：如果一个类型的对齐保证为N，那么就说这个类型是 N 字节对齐的 这两类对齐保证对应的获取方式： unsafe.Alignof(t) （编译的时候估值） reflect.TypeOf(t).Align() reflect.TypeOf(t).FieldAlign() type X struct { c int32 d int64 } func getAlignmentGuarantee() { var a int32 // 使用 unsafe.Alignof() fmt.Println(unsafe.Alignof(a)) // 4 （获取 int32 的一般对齐保证） fmt.Println(unsafe.Alignof(X{}.c)) // 4 （获取 int32 的字段对齐保证） fmt.Println(unsafe.Alignof(X{}.d)) // 8 fmt.Println(unsafe.Alignof(X{})) // 8 // 使用 reflect.TypeOf(a).Align() 以及 reflect.TypeOf(a).FieldAlign() fmt.Println(reflect.TypeOf(a).Align()) // 4 fmt.Println(reflect.TypeOf(a).FieldAlign()) // 4 } 注意上面程序的输出并不是固定的，相同的编译器在不同的架构上、不同的编译器在相同的架构上，都有可能产生不同的输出 Go 编译器中，对类型对齐保证要求： unsafe.Alignof(t) \u003e= 1 unsafe.Alignof(结构) = 结构体字段的字段对齐保证的最大值 unsafe.Alignof(数组) = unsafe.Alignof(元素类型) ","date":"2023-05-09","objectID":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","series":["Golang底层认知"],"tags":["内存布局"],"title":"内存布局","uri":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/#类型对齐保证"},{"categories":["Golang"],"content":" 结构体的字节填充为了能够让结构体的尺寸为类型对齐保证的 N 倍，有时候需要对结构进行字节补齐，看下面的一个例子，展示了两个内容： 结构体尺寸的计算 结构体的字节填充 // 假设在 64 位机器上的情况 type T1 struct { a int8 // 为了让 b 能够8字节对齐，这里要填充 7 个字节 b int64 c int16 // 前面一共的尺寸为 1 + 7 + 8 + 2 = 18 个字节 // 为了让 T1 的尺寸为 8 的倍数，这里需要填充 24 - 18 = 6 个字节 } // 因此 T1 类型的尺寸为 24 个字节 type T2 struct { a int8 // 为了让 b 能够 2 字节对齐，这里填充 1 字节 b int16 // 为了让 c 能够 8 字节对齐，这里填充 4 字节 c int64 // 前面一共 1 + 1 + 2 + 4 + 8 = 16 字节，因此这里不需要再填充 } // 因此 T2 类型的尺寸为 16 个字节 从上面这个例子可以看到，尽管 T1 跟 T2 拥有一样的字段类型，但因为排列的不同，导致字节填充的数量不同，因此其尺寸也不同。 问题：[[202304242320 一个零尺寸的类型有没有可能影响到结构体的尺寸]] 《内存布局 -Go语言101》. 见于 2023年4月24日. https://gfw.go101.org/article/memory-layout.html. 《The Go Programming Language Specification - The Go Programming Language》. 见于 2023年4月24日. https://go.dev/ref/spec. The Go Programming Language Specification 中文：https://github.com/saberuster/Go-Language-Specification ","date":"2023-05-09","objectID":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","series":["Golang底层认知"],"tags":["内存布局"],"title":"内存布局","uri":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/#结构体的字节填充"},{"categories":["Golang"],"content":"#Golang ","date":"2023-05-09","objectID":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:0:0","series":["Golang底层认知"],"tags":[],"title":"深浅拷贝","uri":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/#"},{"categories":["Golang"],"content":" 深浅拷贝的区别 深拷贝：两个对象不共享内存，各自分开 值类型的数据都是深拷贝，Int、Float、String、Bool、Struct 浅拷贝：两个对象指向同一个地址 引用类型的都是浅拷贝，Slice、Map ","date":"2023-05-09","objectID":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:1:0","series":["Golang底层认知"],"tags":[],"title":"深浅拷贝","uri":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/#深浅拷贝的区别"},{"categories":["Golang"],"content":" 如果是 Slice 切片类型，想做深拷贝怎么办（使用 copy 方法） score := []int{1,2,3} scoreTmp := make([]int, len(score)) copy(scoreTmp, score) 注意点： 目的切面需要提前申请空间（一般与源切片等长，若更小，只拷贝部分，若更大，剩余空间补齐类型默认值） 若源切片存的是引用，则拷贝过去之后，目的切片保存的是跟源切片一样的引用（二维数组的拷贝），因此想二维数组如果要深拷贝需要二重循环 ","date":"2023-05-09","objectID":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:0","series":["Golang底层认知"],"tags":[],"title":"深浅拷贝","uri":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/#如果是-slice-切片类型想做深拷贝怎么办使用-copy-方法"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":" 一些基本概念树四度： 度 节点的度：节点拥有的子节点数量 树的度：节点的度的最大值 深度：根节点到当前节点的距离 高度：根节点到最低节点的距离 树的实际应用： 帮助分析时间复杂度 搜索 排序 路径查找 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:1:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#一些基本概念"},{"categories":["数据结构与算法"],"content":" 几种常见的树 二叉树 满二叉树 完全二叉树 二叉搜索树 [[202305040442 二叉搜索树]] 平衡二叉搜索树 线段树 平衡树 B 树 红黑树 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:2:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#几种常见的树"},{"categories":["数据结构与算法"],"content":" 树的遍历方式深度：前序（DLR）、中序（LDR）、后序（LRD） 广度：层序遍历 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#树的遍历方式"},{"categories":["数据结构与算法"],"content":" 前序遍历用递归的思想可以将问题看作： 访问跟节点 前序遍历左节点 前序遍历右节点 // 前序遍历: 访问根节点，以前序遍历的方式访问左节点，以前序遍历的方式访问右节点 func pOrder(root *treeNode) { // end if root == nil { return } fmt.Printf(\"%d \", root.val) pOrder(root.left) pOrder(root.right) return } 使用栈实现： 将根节点入栈 出栈，加入右节点跟左节点 重复以上操作，直到栈空 func pOrderStack(root *treeNode) { if root == nil { return } var st []*treeNode st = append(st, root) var pnt []int for len(st) \u003e 0 { // pop cur := st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, cur.val) // judge left\\right if cur.right != nil { st = append(st, cur.right) } if cur.left != nil { st = append(st, cur.left) } } fmt.Println(pnt) } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:1","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#前序遍历"},{"categories":["数据结构与算法"],"content":" 中序遍历递归实现： // 按中序遍历访问左节点，访问节点元素，按中序遍历访问右节点 func ldrOrder(root *treeNode) { if root == nil { return } ldrOrder(root.left) fmt.Printf(\"%d \", root.val) ldrOrder(root.right) return } 栈实现： 从根节点开始入栈，一直往左，直到最左叶子节点 出栈，访问节点 将右节点当作步骤1的根节点（若存在） func ldrOrderStack(root *treeNode) { if root == nil { return } var st []*treeNode cur := root // 找到最左叶子节点 for cur != nil { st = append(st, cur) cur = cur.left } // 出栈，访问元素 // 如果存在右节点，继续入栈，直到最左叶子节点 var pnt []int for len(st) \u003e 0 { cur := st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, cur.val) tmp := cur.right for tmp != nil { st = append(st, tmp) tmp = tmp.left } } return } // 代码优化 func ldrOrderStack2(root *treeNode) { if root == nil { return } var st []*treeNode // 出栈，访问元素 // 如果存在右节点，继续入栈，直到最左叶子节点 var pnt []int tmp := root for len(st) \u003e 0 || tmp != nil { // 入栈直到最左节点 for tmp != nil { st = append(st, tmp) tmp = tmp.left } // 出栈，访问节点元素 tmp = st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, tmp.val) // 继续找右节点的最左叶子节点 tmp = tmp.right } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:2","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#中序遍历"},{"categories":["数据结构与算法"],"content":" 后续遍历递归实现： func lrdOrder(root *treeNode) { if root == nil { return } lrdOrder(root.left) lrdOrder(root.right) fmt.Printf(\"%d \", root.val) return } 栈实现： 从根节点开始入栈，直到最左节点 获取栈顶，判断右节点 右节点不存在：访问该节点，出栈 右节点已经访问过：访问该节点，出栈 右节点未访问，进入步骤3 将该右节点当作步骤1的根节点 func lrdOrderStack(root *treeNode) { var st []*treeNode tmpRoot := root pre := root for len(st) \u003e 0 || tmpRoot != nil { for tmpRoot != nil { st = append(st, tmpRoot) tmpRoot = tmpRoot.left } tmpRoot = st[len(st)-1] // 当节点右节点为空 或者 右子树已经访问过的情况下，访问根节点 if tmpRoot.right == nil || tmpRoot.right == pre { fmt.Printf(\"%d \", tmpRoot.val) pre = tmpRoot tmpRoot = nil // 将当前节点标记为空，避免下一个循环又将该节点入栈 st = st[:len(st)-1] } else { // 右节点还没访问，后序遍历右节点 tmpRoot = tmpRoot.right } } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:3","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#后续遍历"},{"categories":["数据结构与算法"],"content":" 层序遍历层序遍历使用队列实现： func levelOrder(root *treeNode) { if root == nil { return } var queue []*treeNode queue = append(queue, root) for len(queue) \u003e 0 { cur := queue[0] queue = queue[1:] fmt.Printf(\"%d \", cur.val) if cur.left != nil { queue = append(queue, cur.left) } if cur.right != nil { queue = append(queue, cur.right) } } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:4","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#层序遍历"},{"categories":["数据结构与算法"],"content":" 遍历的复杂度 遍历 时间复杂度 空间复杂度 先序 O(n) 递归调用的时间复杂度为O(1)，递归调用的次数为数中节点的数量n 栈实现的空间复杂度为：O(h) h为数的高度 在较差的情况下，h = n；如果是平衡二叉树，h = logn 中序 O(n) 同上 后序 O(n) 同上 层序 O(n) O(w) w 为树的宽度 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:5","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#遍历的复杂度"},{"categories":["数据结构与算法"],"content":" 树的一些常见问题202305021918 树问题-路径求和 202305031652 树问题-判断子树 《02.二叉树的遍历知识》. 见于 2023年4月30日. https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/. https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/ ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:4:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#树的一些常见问题"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:0:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#"},{"categories":["数据结构与算法"],"content":" 方法一、使用广度优先搜索（层次遍历）思路： 二叉树的层次遍历使用一个队列来保存每一层的节点，再增加一个队列，用来保存从根节点到当前节点的路径上的和 ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:1:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#方法一使用广度优先搜索层次遍历"},{"categories":["数据结构与算法"],"content":" 方法二、递归思路： 原问题：是否存在从当前节点（根节点）到叶子节点的路径，和为 sum 子问题：是否存在从当前节点（根节点的子节点）到叶子节点的路径，和为 sum - val（父节点的值） 结束条件：当前节点为叶子节点 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } return havePathToLeaf(root, targetSum) } func havePathToLeaf(root *TreeNode, tgtSum int) bool { // end if root.Left == nil \u0026\u0026 root.Right == nil { return root.Val == tgtSum } have1, have2 := false, false if root.Left != nil { have1 = havePathToLeaf(root.Left, tgtSum - root.Val) } if root.Right != nil { have2 = havePathToLeaf(root.Right, tgtSum - root.Val) } return have1 || have2 } ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:2:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#方法二递归"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:0:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":" 方法1. 递归子问题是：判断左右子树是否会等于预期的子树（判断左右子树是否相等的问题也可以递归来实现） // 判断根节点为起始的树与目标树是否相同 // 如果不相同，递归判断左子树和右子树 func isSubtree(root *TreeNode, subRoot *TreeNode) bool { if root == nil \u0026\u0026 subRoot == nil { return true } if root == nil { return false } if isSameTree(root, subRoot) { return true } return isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot) } func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026\u0026 q == nil { return true } if p == nil || q == nil { return false } if p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026\u0026 isSameTree(p.Right, q.Right) } ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:1:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#方法1-递归"},{"categories":["数据结构与算法"],"content":" 方法2. dfs（先序） + kmp202304262036 KMP 算法 设主树s，子树t，主树的先序序列 ss，子树的先序序列 tt 利用先序序列的性质： 如果A.【 t 是 s 的子树】 那么B.【ss 中 包含 tt】 可以知道 B 是 A 的必要条件，是没有办法从 B 推出 A 的，原因是什么呢，假设主树：[4, 5]，子树：[4, nil, 5]，这种情况下的先序序列都是 4 5，但是两颗树是不一样的 但是我们可以通过补充两个代表空的左右节点来解决这个问题 // 通过树的先序遍历 // 补充树的每个节点，让度为2，输出树的先序遍历 // 判断主树的序列包含子树的序列 func isSubtree2(root *TreeNode, subRoot *TreeNode) bool { nums1 := dlrNums(root) nums2 := dlrNums(subRoot) return kmpSearch(nums1, nums2) } const lrNilVal = -10001 var leftNilNode = TreeNode{ Val: lrNilVal, } var rightNilNode = TreeNode{ Val: lrNilVal, } func dlrNums(root *TreeNode) []int { var nums []int if root == nil { return nums } var st []*TreeNode st = append(st, root) tmpRoot := root for len(st) \u003e 0 { // pop tmpRoot = st[len(st) - 1] st = st[:len(st) - 1] // visit nums = append(nums, tmpRoot.Val) if tmpRoot.Val != lrNilVal \u0026\u0026 tmpRoot.Left == nil { tmpRoot.Left = \u0026leftNilNode } if tmpRoot.Val != lrNilVal \u0026\u0026 tmpRoot.Right == nil { tmpRoot.Right = \u0026rightNilNode } if tmpRoot.Right != nil { st = append(st, tmpRoot.Right) } if tmpRoot.Left != nil { st = append(st, tmpRoot.Left) } } return nums } // i // nums a a b a a b a a c // pat // j func kmpSearch(nums, pat []int) bool { next := getNext(pat) j := 0 for i := 0; j \u003c len(pat) \u0026\u0026 i \u003c len(nums); i++ { for ; j \u003e 0 \u0026\u0026 nums[i] != pat[j]; j = next[j-1]{} if nums[i] == pat[j] { j++ } } return j == len(pat) } func getNext(pat []int) []int { next := make([]int, len(pat)) next[0] = 0 for l, j := 0, 1 ; j \u003c len(pat); j++ { for l \u003e 0 \u0026\u0026 pat[l] != pat[j] {l = next[l-1]} if pat[l] == pat[j] { l++ } next[j] = l } return next } ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:2:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#方法2-dfs先序--kmp"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:0:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#"},{"categories":["数据结构与算法"],"content":" 一、基本概念定义：G = (V, E) 图的分类 边是否有方向： 有向图 无向图 图中是否有环： 有环图 无环图 连通图和非连通图 连通图 非连通图 ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:1:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#一基本概念"},{"categories":["数据结构与算法"],"content":" 二、图的存储 顺序 链式 五种树的存储方式的比较： 操作 邻接矩阵 边集数组 邻接表 链式前向星 哈希表实现邻接表 图的初始化 n^2 m n+m n+m 查某条边是否存在 1 m TD(vi) TD(vi) 遍历某个点的所有边 n m TD(vi) TD(vi) 遍历整张图 n^2 nm n+m n+m 空间复杂度 n m n+m n+m ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#二图的存储"},{"categories":["数据结构与算法"],"content":" 2.1 邻接矩阵（ 二维数组）","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:1","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#21-邻接矩阵-二维数组"},{"categories":["数据结构与算法"],"content":" 2.2 边集数组","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:2","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#22-边集数组"},{"categories":["数据结构与算法"],"content":" 2.3 邻接表（数组+链式结构） // 邻接点 type AdjNode struct { AdjN int // 邻接点标号 Weight int //顶点到该邻接点的权重 Next *AdjNode } // 顶点 type VNode struct { Val int FirstAdjNode *AdjNode } type Graph struct { VNum int ENum int VNodes []VNode } type Edge struct { V1, V2 int Weight int } func InitGraph(VertexNum int) *Graph { g := \u0026Graph{ VNum: VertexNum, ENum: 0, VNodes: make([]VNode, VertexNum), } //for _, vnode := range g.VNodes { //vnode.Val = //} return g } func InsertEdge(graph *Graph, e *Edge) { v1VNode := graph.VNodes[e.V1-1] // 假设 v1 节点存储在下标 0 的位置 // 新建一个 v2 的邻接点 v2Adj := \u0026AdjNode{ AdjN: e.V2, Weight: e.Weight, Next: v1VNode.FirstAdjNode, } v1VNode.FirstAdjNode = v2Adj // 如果是无向图，还需要添加从 v2 到 v1 的连接 v2VNode := graph.VNodes[e.V2-1] v1Adj := \u0026AdjNode{ AdjN: e.V1, Weight: e.Weight, Next: v2VNode.FirstAdjNode, } v2VNode.FirstAdjNode = v1Adj } func BuildGraph(vnum int, v1s, v2s []int, weight []int) *Graph { graph := InitGraph(vnum) for i := 0; i \u003c len(v1s); i++ { e := \u0026Edge{ V1: v1s[i], V2: v2s[i], Weight: weight[i], } InsertEdge(graph, e) } return graph } func test1() { vnum := 4 v1s := []int{1,1,3,1} v2s := []int{2,3,4,4} weights := []int{1,2,3,4} graph := BuildGraph(vnum, v1s, v2s, weights) for i, vnode := range graph.VNodes { adj := vnode.FirstAdjNode for adj != nil { fmt.Printf(\"(%d,%d) 权重 %d \\n\",i+1, adj.AdjN, adj.Weight) adj = adj.Next } } } ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:3","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#23-邻接表数组链式结构"},{"categories":["数据结构与算法"],"content":" 2.4 链式前向星（数组+静态链表）","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:4","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#24-链式前向星数组静态链表"},{"categories":["数据结构与算法"],"content":" 2.5 哈希表实现邻接表","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:5","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#25-哈希表实现邻接表"},{"categories":["数据结构与算法"],"content":" 三、图的遍历","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#三图的遍历"},{"categories":["数据结构与算法"],"content":" 3.1 DFS","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:1","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#31-dfs"},{"categories":["数据结构与算法"],"content":" 3.2 BFS","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:2","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#32-bfs"},{"categories":["容器"],"content":"#k8s #问题定位 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:0:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#"},{"categories":["容器"],"content":" 问题现场 kubectl -n product-ebs get pod -o wide | grep vtype-xxx 扎到了一个状态为 Evicted 的 pod ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:1:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#问题现场"},{"categories":["容器"],"content":" 问题分析通过现场可以看到 pod 原先的节点，所以可以查看一下节点的日志 接着就发现了节点有磁盘压力，kubelet 主动终止 pod 以回收节点上的资源，以此来保证节点的稳定 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:2:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#问题分析"},{"categories":["容器"],"content":" 学习","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:3:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#学习"},{"categories":["容器"],"content":" 可能导致节点压力的因素有什么cpu、内存、磁盘空间… ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:3:1","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#可能导致节点压力的因素有什么"},{"categories":["容器"],"content":" kubelet 是如何做出驱逐的决定的 分析这个问题的步骤： 回答这个问题需要了解 Kubernetes 中 kubelet 组件以及 Eviction API，再结合节点资源使用情况等因素来判断是否要驱逐 Pod。具体的分析步骤如下： 了解 Kubernetes 中 kubelet 组件和 Eviction API 的作用和原理。 确认 kubelet 是否开启了 Eviction 功能。 判断当前节点资源（如内存、CPU、磁盘空间）使用情况是否达到了预定义的阈值，若达到或超出，则根据优先级逻辑对 Pod 进行驱逐操作。 产生这个问题的原因： 在 Kubernetes 下，由于各种原因（如资源紧缺，节点故障等），kubelet 可能会决定驱逐一些 Pod 以保证集群正常运转，因此了解 kubelet 决策的原因和方式对于提高 Kubernetes 集群的稳定性和安全性非常重要。 这个问题的答案： kubelet 驱逐 Pod 是通过以下步骤进行的： kubelet 定期与 kube-apiserver 通信，获取当前 Node 上的 Pod 列表信息。 kubelet 根据容器的 QoS 类别（Guaranteed \u003e Burstable \u003e BestEffort） 和优先级（pod priority/Preemption）进行排序。（Preemption 时过程中，kubelet 不会限制一些特定 Pod 从来不被驱逐。） kubelet 判断当前 Node 是否处于 out of memory 或者 DiskPressure 的状态，如果是的话，则使用相应的 Eviction API 驱逐 Pod。 如果还没有达到阈值，则尝试驱逐优先级最低的 Pod。如果此时节点有足够的资源可供使用，则该操作不会执行。否则，kubelet 将继续驱逐优先级下一个较低的 Pod 直到可以保证目标阈值。 如果使用上述步骤无法满足 Eviction 要求（如Pod 强占资源），kubelet 可能会强制删除其他 Pod 以便为当前占用的 Pod 腾出资源。 需要注意的是，kubelet 是被动的进行驱逐操作的，即只有在当前节点资源使用情况达到或超过了预设的阈值时才会进行驱逐，而这些阈值可以通过修改 Kubernetes 集群中的参数来调整。 容器的 QoS： kubectl describe pod \u003cpod-name\u003e | grep QoS 该命令会列出 Pod 的详细信息，并在结果中搜索 QoS 相关的部分。 Kubernetes 中的 QoS (Quality of Service) 是一个特性，它用来管理节点上运行的 Pod 的资源分配和调度。在 Kubernetes 中，QoS 有三种级别： Guaranteed：这种类型的 Pod 被保证能够获得所请求的 CPU 和内存资源。如果节点上的资源不足，优先级较低的 Pod 将被暂停或驱逐。 Burstable：这种类型的 Pod 具有最小的 CPU 和内存要求，但可以在需要时进行扩展，以获得更多资源。当节点上的资源不足时，Burstable Pod 可能会受到限制，但不会被完全暂停或驱逐。 BestEffort：这种类型的 Pod 不会被保证任何资源。它们将尽力在节点上占用尽可能少的资源，并且在节点资源不足时首先被削减或删除。 QoS 主要的作用是帮助 Kubernetes 管理资源，确保相同级别的 Pod 在节点上得到公平的资源分配，并且在资源不足的情况下，根据其级别的不同，采取适当的措施以保持节点的健康状态。 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:3:2","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#kubelet-是如何做出驱逐的决定的"},{"categories":["容器"],"content":"#k8s ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:0:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#"},{"categories":["容器"],"content":" 一、环境准备 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 关闭 selinux sed -i 's/enforcing/disabled/' /etc/selinux/config 关闭 swap sed -ri 's/.*swap.*/#\u0026/' /etc/fstab 添加 hosts cat \u003e\u003e /etc/hosts \u003c\u003c EOF 192.168.108.132 centos7-master 192.168.108.130 centos7-node1 EOF 设置网桥参数 cat \u003e /etc/sysctl.d/k8s.conf \u003c\u003c EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system # 生效 时间同步 yum install ntpdate -y # 没有的 ntpdate 则安装 ntpdate time.windows.com # 同步时间 ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:1:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#一环境准备"},{"categories":["容器"],"content":" 二、安装 安装 Docker、kubeadm、kubelet、kubectl Docker 安装 wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo # 更新 docker 的 yum 源 yum install docker-ce-19.03.13 -y 配置镜像 mkdir /etc/docker cat \u003c\u003c EOF \u003e /etc/docker/daemon.json { \"registry-mirrors\": [\"https://kfwkfulq.mirror.aliyuncs.com\"] } EOF systemctl enable docker.service 添加 k8s 的yum源 cat \u003e /etc/yum.repos.d/kubernetes.repo \u003c\u003c EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 安装 kubeadm、kubelet、kubectl yum install kubelet-1.19.4 kubeadm-1.19.4 kubectl-1.19.4 -y systemctl enable kubelet.service # 开启服务 重启 centos 部署 master 节点 kubeadm init --apiserver-advertise-address=【master服务器ip地址】 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.19.4 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 添加 node 节点 kubeadm join 192.168.108.132:6443 --token d99d8g.3wr8skktnv3m9e46 \\ --discovery-token-ca-cert-hash sha256:0ba36403007aa7ef77b174a65a8e3de27bcbcac9fbb5b2bb31c337a565d4e16 部署网络插件 wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl apply -f kube-flannel.yml ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:2:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#二安装"},{"categories":["Golang"],"content":"#Golang 栈的相关操作有：入栈（push）、出栈（pop）（出栈的同时删除），获取栈顶元素（top） type myStack struct { Nums []int } func (s *myStack) push(n int) { s.Nums = append(s.Nums, n) } func (s *myStack) pop() int { if s.isEmpty() { return 0 } top := s.Nums[len(s.Nums)-1] s.Nums = s.Nums[:len(s.Nums)-1] // num[n:m] 的下标范围 [n,m) return top } func (s *myStack) top() int { return s.Nums[len(s.Nums)-1] } func (s *myStack) isEmpty() bool { if len(s.Nums) == 0 { return true } return false } ","date":"2023-05-09","objectID":"/202304201957-%E6%A0%88/:0:0","series":["Golang代码片段"],"tags":[],"title":"栈","uri":"/202304201957-%E6%A0%88/#"},{"categories":["数据结构与算法"],"content":"#算法 用途：给定一个数组，返回基于字典序的下一个数组排列 四个步骤： 找上坡 找大于且最小 交换 倒序 Go 实现： func nextDicArr(nums []int) []int { if len(nums) \u003c= 1 { return } pos := -1 for i := len(nums)-2; i \u003e= 0; i-- { if nums[i] \u003c nums[i+1] { pos = i break } } // 没找到上坡（左值小于右值），说明已经是降序排列 if pos == -1 { for i,n := 0,len(nums); i \u003c n/2; i++ { nums[i], nums[n-i-1] = nums[n-i-1], nums[i] } return nums } // 找到 pos，接着找右边大于该值的最小值（也就是第一个大于标记的值） biggerThanPos := -1 for i := len(nums)-1; i \u003e= pos+1; i-- { if nums[i] \u003e nums[pos] { biggerThanPos = i break } } nums[pos], nums[biggerThanPos] = nums[biggerThanPos], nums[pos] // 剩下的倒序 for i,n,cnt := pos+1, len(nums),0; i \u003c (n + pos+1)/2; i++ { nums[i], nums[n-cnt-1] = nums[n-cnt-1], nums[i] cnt++ } return nums } 习题练习： https://leetcode.cn/problems/VvJkup/ 《字典序算法详解_HappyRocking的博客-CSDN博客》. 见于 2023年4月29日. https://blog.csdn.net/HappyRocking/article/details/83619392. ","date":"2023-05-09","objectID":"/202304290644-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"字典序算法","uri":"/202304290644-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/#"}]