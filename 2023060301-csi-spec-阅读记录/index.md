# csi spec 阅读记录

<!--more-->
#

{{< admonition warning "about card" false >}}

这是一个临时性的**卡片文章**，之后可能:
1. `针对该卡片进行扩展，形成文章`
2. `与已有文章关联，组织到其他文章`
3. `删除`

{{< /admonition>}}

## Goals in MVP

容器存储接口（CSI）将

使SP作者能够编写一个符合CSI的插件，该插件在所有实施CSI的CO上都能 "正常工作"。
定义API（RPCs），使其能够：
- 卷的动态配置和取消配置。
- 从一个节点上附加或分离一个卷。
- 从一个节点上挂载/卸载卷。
- 消耗块和可装载的卷。
- 本地存储提供者（例如，设备映射器，lvm）。
- 创建和删除一个快照（快照的来源是一个卷）。
- 从快照提供一个新的卷（恢复快照，即原始卷中的数据被删除并被快照中的数据取代，不在范围内）。
- 定义插件协议 建议。
- 描述监督员配置插件的过程。
  
容器部署注意事项（CAP_SYS_ADMIN、挂载命名空间等）。

## 解决方案概述

本规范定义了一个接口，以及存储提供商（SP）实施CSI兼容插件的最低操作和包装建议。**该接口声明了一个插件必须暴露的RPC：这是CSI规范的主要重点**。任何操作和包装建议都提供了额外的指导，以促进跨CO的兼容性。

### 架构

本规范的主要重点是CO和Plugin之间的协议。它应该可以为各种部署架构运送跨CO兼容的插件。一个CO应该有能力处理集中式和无头式的插件，以及分离式组件和统一式插件。这些可能性中的几个在下面的数字中得到了说明

```text
                             CO "Master" Host
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    | Controller |  |
|  |            +----------->   Plugin   |  |
|  +------------+           +------------+  |
|                                           |
+-------------------------------------------+

                            CO "Node" Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    |    Node    |  |
|  |            +----------->   Plugin   |  |
|  +------------+           +------------+  |
|                                           |
+-------------------------------------------+
```
插件在集群的所有节点上运行：一个集中的
控制器插件在CO主主机上可用，而节点插件在所有CO节点上可用。
插件可在所有的CO节点上使用

```text
                            CO "Node" Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    | Controller |  |
|  |            +--+-------->   Plugin   |  |
|  +------------+  |        +------------+  |
|                  |                        |
|                  |                        |
|                  |        +------------+  |
|                  |        |    Node    |  |
|                  +-------->   Plugin   |  |
|                           +------------+  |
|                                           |
+-------------------------------------------+
```

无头插件的部署，只有CO节点的主机运行
插件。独立的、可拆分的插件分别提供控制器
服务和节点服务

```text
                            CO "Node" Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    | Controller |  |
|  |            +----------->    Node    |  |
|  +------------+           |   Plugin   |  |
|                           +------------+  |
|                                           |
+-------------------------------------------+
```

无头插件的部署，只有CO节点的主机运行
插件。一个统一的Plugin组件同时提供控制器
服务和节点服务

```text
                            CO "Node" Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    |    Node    |  |
|  |            +----------->   Plugin   |  |
|  +------------+           +------------+  |
|                                           |
+-------------------------------------------+
```
无头插件的部署，只有CO节点的主机运行
插件。一个只有节点的插件组件只提供节点服务。
它的GetPluginCapabilities RPC并不报告CONTROLLER_SERVICE
能力。

- 什么是控制级别的能力？

    当涉及到容器编排系统的控制器级别的能力时，可以举一个具体的例子来解释。

    假设你正在使用Kubernetes作为容器编排系统，并且希望在集群中管理存储卷。你可能会安装一个存储插件，该插件负责与底层存储系统进行交互，并在需要时创建、删除和管理存储卷。

    在这种情况下，存储插件可以具备两个级别的能力：

    1. 节点级别的能力：存储插件可以在每个节点上运行，提供与该节点上的存储相关的功能。例如，它可以处理将存储卷附加到节点上的容器，或将容器使用的存储卷与节点上的物理存储设备进行映射。

    2. 控制器级别的能力：存储插件还可以具备控制器级别的能力，使其能够执行集群范围的操作。例如，它可以处理存储卷的动态创建和删除，管理存储卷的访问控制策略，或跨多个节点进行存储资源的调度和平衡。

    在Headless Plugin Deployment中，节点专用插件组件只提供节点级别的服务，因此它们不具备控制器级别的能力。这意味着它们仅限于在各个节点上提供本地的存储服务，而不能执行涉及整个集群的操作，如集中式存储资源管理或全局配置的修改。

### 卷的生命周期

```text
   CreateVolume +------------+ DeleteVolume
 +------------->|  CREATED   +--------------+
 |              +---+----^---+              |
 |       Controller |    | Controller       v
+++         Publish |    | Unpublish       +++
|X|          Volume |    | Volume          | |
+-+             +---v----+---+             +-+
                | NODE_READY |
                +---+----^---+
               Node |    | Node
            Publish |    | Unpublish
             Volume |    | Volume
                +---v----+---+
                | PUBLISHED  |
                +------------+
```
一个动态配置的卷的生命周期，从创建到销毁。
创建到销毁

```text
   CreateVolume +------------+ DeleteVolume
 +------------->|  CREATED   +--------------+
 |              +---+----^---+              |
 |       Controller |    | Controller       v
+++         Publish |    | Unpublish       +++
|X|          Volume |    | Volume          | |
+-+             +---v----+---+             +-+
                | NODE_READY |
                +---+----^---+
               Node |    | Node
              Stage |    | Unstage
             Volume |    | Volume
                +---v----+---+
                |  VOL_READY |
                +---+----^---+
               Node |    | Node
            Publish |    | Unpublish
             Volume |    | Volume
                +---v----+---+
                | PUBLISHED  |
                +------------+
```
动态供应的卷的生命周期，从创建到销毁。
创建到销毁的生命周期，当节点插件公布了
STAGE_UNSTAGE_VOLUME的能力

- 什么是 stage_unstage_volume 能力？

    STAGE_UNSTAGE_VOLUME是容器存储接口（Container Storage Interface，CSI）规范中定义的一个能力（capability）。它指示一个存储插件是否支持在存储卷上执行阶段（Stage）和解阶段（Unstage）操作。

    阶段（Stage）和解阶段（Unstage）是一种存储卷的生命周期管理操作，通常在容器编排系统中使用。这些操作允许在容器启动之前或停止之后，对存储卷进行额外的准备或清理工作。

    当一个存储插件声明具有STAGE_UNSTAGE_VOLUME能力时，它表示该插件能够处理存储卷的阶段和解阶段操作。这意味着它可以在容器启动之前预先准备存储卷，例如将数据复制到适当的位置，以确保容器在启动时能够正常访问存储卷。类似地，解阶段操作允许插件在容器停止后进行清理，例如删除临时数据或释放资源。

    通过支持STAGE_UNSTAGE_VOLUME能力，存储插件可以更灵活地管理存储卷的生命周期，并提供更高级的功能，以适应容器编排系统中的特定需求。

```text
    Controller                  Controller
       Publish                  Unpublish
        Volume  +------------+  Volume
 +------------->+ NODE_READY +--------------+
 |              +---+----^---+              |
 |             Node |    | Node             v
+++         Publish |    | Unpublish       +++
|X| <-+      Volume |    | Volume          | |
+++   |         +---v----+---+             +-+
 |    |         | PUBLISHED  |
 |    |         +------------+
 +----+
   Validate
   Volume
   Capabilities
```

## Container Storage Interface

This section describes the interface between COs and Plugins.

### RPC Interface

A CO interacts with an Plugin through RPCs. Each SP MUST provide:

- Node Plugin: 为CSI RPC提供服务的gRPC端点，该端点必须在将发布SP提供的卷的节点上运行。
- Controller Plugin: 一个为CSI RPC服务的gRPC端点，可以在任何地方运行。
- 在某些情况下，一个单一的gRPC端点可能为所有CSI RPC提供服务（controller-node-plugin）


