# Golang 中的 GC

<!--more-->
#gc

{{< admonition warning "about card" false >}}

这是一个临时性的**卡片文章**，之后可能:
1. `针对该卡片进行扩展，形成文章`
2. `与已有文章关联，组织到其他文章`
3. `删除`

{{< /admonition>}}

## draft



## 关于垃圾回收

1. 垃圾回收的两种形式：
   - 追踪：根据对象之间的引用，扫描确定要保留的对象
   - 计数：对象包含一个计数器，当计数器归零时回收


2. Go 使用的是：**不分代、不整理、并发的三色标记清理**
   - 不分代的原因：分代回收是基于“存活时间短的对象更倾向于被回收”这样的假设，在 Go 中，这样的对象通常被分配在栈上，当 Goroutine 退出的时候自动释放内存，不需要 GC 的参与
   - 不整理的原因：Go 的分配算法 tcmalloc 具有低碎片化的特性

3. 什么是 `stw`

    stop the world: 停止用户程序的执行，直到垃圾回收结束

4. 使用 golang 提供的工具来观察 GC

    hhqtodo


## 三色标记清除

1. 三种颜色：

    ![图 1](images/posts/20230531-011624044.png)  


2. 并发 GC 可能导致的问题

    ![图 2](images/posts/20230531-012648303.png)  

    例子来自:[垃圾回收的认识 | Go 程序员面试笔试宝典](https://golang.design/go-questions/memgc/principal/#4-%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95%e6%98%af%e4%bb%80%e4%b9%88)

3. 垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象

可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性：

   - 条件 1: 赋值器修改对象图 ，导致某一黑色对象引用白色对象；
   - 条件 2: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。

    ![图 3](images/posts/20230531-020020001.png)  

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：

   - 如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
   - 如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

我们不妨将三色不变性所定义的波面根据这两个条件进行削弱：

   - 当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为强三色不变性（strong tricolor invariant）
   - 当赋值器令黑色对象引用白色对象时（满足条件 1 时）的情况称为弱三色不变性（weak tricolor invariant）



---

1. [[Go三关-典藏版]Golang垃圾回收+混合写屏障GC全分析 - 知乎](https://zhuanlan.zhihu.com/p/334999060)
2. [垃圾回收的认识 | Go 程序员面试笔试宝典](https://golang.design/go-questions/memgc/principal/)
