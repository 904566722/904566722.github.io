# channel 通道

<!--more-->
#

## 概览

- 通道的主要作用是用来做**并发同步**
- Rob Pike 对于并发编程的建议：不要让计算通过共享内存来通讯，而应该`通过通讯来共享内存`，channel 就是这么诞生的
- 可以把通道看作是先进先出的队列
	- 当一个协程往一个通道发送某个值，可以看作该协程`释放了一些值的所有权`
	- 当一个协程从一个通道获取某个值，可以看作协程`获得了一些值的所有权`
- 另外几种传统的并发同步技术提供在 `sync` 和 `sync/atomic` 标准库包中

## channel 类型

|声明|说明|
|-|-|
|`chan T`|双向|
|`chan<- T`|只能发送|
|`<-chan T`|只能接收|

- 零值： `nil`
- 容量属性：根据容量是否为 0 分为两种通道：`unbuffered channel` `buffered channel`

## channel 操作

|操作|语法|
|-|-|
|发送|`ch <- v`|
|接收|`<- ch`|
|关闭|`close(ch)`|
|获取长度|`len(ch)`|
|获取容量|`cap(ch)`|

上面的 5 中操作都是经过 `同步` 的，可以在并发协程中安全运行而无需其他操作

## 通道的组成

一个通道可以看作是以下三个部分组成的：
- 等待发送的协程队列
- 等待接受的协程队列
- 保存元素的循环队列
	- 空槽
	- 满槽
![](images/posts/Pasted%20image%2020230519094306.png)

- 通道内部通过一个 `互斥锁` 来防止数据竞争

## 通道的操作详情

先将通道做个简单归类：
- nil 通道
- （非零）已关闭的通道 C
- （非零）未关闭的通道 O

|操作|nil|C（已关闭的通道）|O（未关闭的通道）|
|:-:|:-:|:-:|:-:|
|关闭|panic|panic|[成功关闭]^(3)|
|发送|永久阻塞|panic|[阻塞 or 成功发送]^(1)|
|接受|永久阻塞|[永不阻塞]^(4)|[阻塞 or 成功接受]^(2)|

具体说明以上的几种情况
1. 假设一个协程 `S` 往通道发送数据，S 首先去`获得通道的锁`，然后继续往下执行下面的其中一种情况：

	- `非阻塞`：接收的协程队列 Q2 不为空，那么 Qbuffer 一定是空的，这个时候协程往缓冲队列中写入数据，从接收的协程队列中马上弹出一个协程，接收由 S 发送的数据，然后该协程继续执行
		![](images/posts/channel01%201.gif)

	- `非阻塞`：接收的协程队列 Q2 为空，如果缓冲队列还没满的情况下，把数据放入缓冲队列，S 继续执行
	- `阻塞`：接收队列为空，并且缓冲队列满槽，将 S 放入发送的协程队列 Q1，进入阻塞状态。之后： 可能被一个接收数据的协程唤醒

2. 假设一个协程 `R` 通过通道接收数据，R 首先`获取通道的锁`，然后继续往下执行下面的其中一种情况：

	- `非阻塞`：缓冲队列不为空（接收队列必为空），R 获取一个缓冲队列中的值之后继续运行；如果发送的协程队列不为空（缓冲队列满的情况），从发送队列弹出一个协程 S，将数据放入缓冲队列后，S 继续运行
	- `非阻塞`：缓冲队列为空，发送的协程队列不空，说明通道是一个非缓冲的通道，这个时候，从发送的协程队列弹出一个协程 S，R 接收到 S 发送的数据之后，两个协程均继续运行
	- `阻塞`：缓冲队列为空，发送的协程队列空，将 R 放入接收的协程队列，之后由发送的协程队列唤醒 

3. 一个协程获取到通道的锁，并且将通道关闭之后，依次执行下面的两个步骤：

	- 如果接收队列不为空（说明缓冲队列一定是空的），将接收队列中的协程依次弹出，每个协程获取到一个缓冲队列内置元素的零值
	- 如果发送队列不为空，将发送队列的协程依次弹出，每个协程都将产生一个 `panic` （由于向已关闭的通道发送数据）

4. 从一个非零已关闭的通道接收值是永不阻塞的，可能有下面的情况

|v, ok := <- ch|说明|
|-|-|
|v, true|v 是之前某个协程放入的|
|v,false|v 是通道内置元素的零值|

### 从上面的分析可以得到几个事实

- 如果缓冲队列不为空，那么接收队列一定是空的
- 如果缓冲队列不为满，那么发送队列一定是空的
- 如果通道关闭了，发送、接收队列一定空，但是缓冲队列不一定是空
- 如果通道是缓冲的，那么发送、接收队列至少有一个是空的
- 一个数据在从一个协程传递到另一个协程的过程中，至少被复制一次，如果存在被放入缓冲队列的情况，被复制两次

## for-range 与 channel

用法：
```go
for v := range aChannel {
	// 使用v
}
```
结束条件：`通道关闭` 且 `缓冲队列为空`

## select-case 和 channel

- 所有非阻塞的 case 将有一个被 `随机` 选择执行
- 如果所有的 case 都是阻塞操作，如果 default 分支存在，则 default 必定被执行，如果不存在，协程将被推入发送队列或者接收队列，并进入阻塞状态


---
1. https://gfw.go101.org/article/channel.html
