[{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"一、KMP 算法用途 在主串 S 中查找模式串 pattern ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#一kmp-算法用途"},{"categories":["数据结构与算法"],"content":"二、算法流程","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#二算法流程"},{"categories":["数据结构与算法"],"content":"2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i \u003c N \u0026\u0026 j \u003c M { 字符不同 循环：根据转移模式更新 j 直到字符相同，或者已经是模式串的首字符 if 字符相同 j++ i++ 否则 i++ } 能够找到则 j == len(pattern) return i - M + 1 否则没有找到 return -1 ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#21-举例说明1"},{"categories":["数据结构与算法"],"content":"2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step1-首先定义两个下标-i-和-j分别指向-s-和-pattern-中待比较的字符"},{"categories":["数据结构与算法"],"content":"2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step2-当-si--patternjij-均右移继续往下比较"},{"categories":["数据结构与算法"],"content":"2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step3-当-si--patternji-不动j-以一定的模式进行转移具体见下面的场景"},{"categories":["数据结构与算法"],"content":"2.1 举例说明1S=“aabaabaac”, pattern=“aabaac” 主串中存在模式串，应该返回起始下标 -3 step1 首先定义两个下标 i 和 j，分别指向 S 和 pattern 中待比较的字符 注意点：（后续解释） i 不会回头（时间复杂度O(N)） j 左侧的字符一定是已经经过比较的（j 是会回头的） step2 当 S[i] == pattern[j]，i、j 均右移，继续往下比较 step3 当 S[i] != pattern[j]，i 不动，j 以一定的模式进行转移，具体见下面的场景：（202304262152 KMP 算法之-获取 next 数组） （假设截取模式串 [0, j-1] 为 pattern‘） 当发现当前比较的字符不同时： 模式串找到 pattern’ 中最长的相同前后缀（假设为 comFix），如上图中的 B 和 C 那么主串在下标 i 之前也必定有一个 comFix（由于 j 前面的字符一定的经过比较的），也就是上图中的 A 所以 A = B = C，那么就可以把 j 的位置移动到 C 的下一个位置，这样就能够保证在 i 不回头的情况下，j 左边的字符都是已经经过比较的 step4 进而继续往下比较 那么 KMP 的伪代码就很容易能够写出来： N M 为 S pattern 的长度 for i ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:2:1","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#step4-进而继续往下比较"},{"categories":["数据结构与算法"],"content":"三、具体实现 func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { // 不想等需要根据前面得到的 next，更新 l // 直到相等或者 l == 0 for l \u003e 0 \u0026\u0026 pat[l] != pat[cur] {l = next[l-1]} if pat[cur] == pat[l] { l++ } next[cur] = l } return next } func KMP(s, pat string) int { n, m := len(s), len(pat) next := getNext(pat) i, j := 0, 0 for i \u003c n \u0026\u0026 j \u003c m { for j \u003e 0 \u0026\u0026 pat[j] != s[i] {j = next[j-1]} if s[i] == pat[j] { j++ } i++ } if j == m { return i - m } else { return -1 } } ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:3:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#三具体实现"},{"categories":["数据结构与算法"],"content":"四、一些习题 https://leetcode.cn/problems/repeated-substring-pattern/ 知乎专栏. 《KMP 算法详解》. 见于 2023年4月26日. https://zhuanlan.zhihu.com/p/83334559. 《KMP算法》. 收入 维基百科，自由的百科全书, 2022年7月8日. https://zh.wikipedia.org/w/index.php?title=KMP%E7%AE%97%E6%B3%95\u0026oldid=72556055. ","date":"2023-05-09","objectID":"/202304262036-kmp-%E7%AE%97%E6%B3%95/:4:0","series":["算法"],"tags":[],"title":"KMP算法","uri":"/202304262036-kmp-%E7%AE%97%E6%B3%95/#四一些习题"},{"categories":["数据结构与算法"],"content":"#算法 KMP 算法中 j 的转移是通过一个保存 j 转移信息的数组 next 来实现的，那么如何获得这个数组是 KMP 算法的关键 首先根据 KMP 的工作流程可知，next 中保存的其实是最长公共前后缀的长度，也可以理解为最长公共前后缀中前缀的下一个下标 next[i] 保存了 pattern[0,i] 这个字符串最长公共前后缀的长度 举个例子说明：pattern = “aabaac” 推导过程： 子串 最长公共前后缀 next a 无(长度为1没有前缀与后缀) 0 aa a 1 aab 无 0 aaba a 1 aabaa aa 2 aabaac 无 0 如何在 O(M) 的时间复杂度内获得这个 next 数组？ 使用两个指针，从头开始遍历 pattern： len：记录了最长公共前后缀的长度（初始 0） cur：子串结尾（初始 1） 首先初始化 next[0] = 0，所有的模式串都符合 判断 pattern[cur] == pattern[len]； 说明存在相同前后缀，那么将 len++，next[cur] = len（说明子串 pattern[0, cur] 的最长公共前缀长度为 len） 再将 cur++，继续判断下一个子串 当 pattern[cur] != pattern[len] 说明当前的子串是不存在公共前后缀的，那么将 len 重置 len = next[len-1]（找子串[0, len-1]的最大相同前后缀，直到首字符的位置 或者 pattern[len] == pattern[cur]）， end 继续右移动 这个步骤往往是容易出错的，看下面的一个例子 重复以上过程，直到获取整个 next 数组 一个错误例子： func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { if pat[cur] == pat[l] { l++ } else { // error l = 0 } next[cur] = l } return next } 测试例： pat=“afdabeafdaf” getNext() = [0 0 0 1 0 0 1 2 3 4 0], want [0 0 0 1 0 0 1 2 3 4 2] 正确实现： func getNext(pat string) []int { n := len(pat) next := make([]int, n) for l, cur := 0, 1; cur \u003c n; cur ++ { // 不相等需要根据前面得到的 next，更新 l // 直到相等或者 l == 0 for l \u003e 0 \u0026\u0026 pat[l] != pat[cur] {l = next[l-1]} if pat[cur] == pat[l] { l++ } next[cur] = l } return next } ","date":"2023-05-09","objectID":"/202304262152-kmp-%E7%AE%97%E6%B3%95%E4%B9%8B-%E8%8E%B7%E5%8F%96-next-%E6%95%B0%E7%BB%84/:0:0","series":["算法"],"tags":[],"title":"KMP算法之-获取next数组","uri":"/202304262152-kmp-%E7%AE%97%E6%B3%95%E4%B9%8B-%E8%8E%B7%E5%8F%96-next-%E6%95%B0%E7%BB%84/#"},{"categories":["数据结构与算法"],"content":"一些题目记录一下","date":"2023-05-09","objectID":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","series":[],"tags":["leetcode","个人记录"],"title":"leetcode 做题记录 ","uri":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["数据结构与算法"],"content":"#算法 记录一些比较有意义的题目 题目 备注 2023.04.18 119 滚动数组 121 169 map的使用，数组中元素的计数 219 滑动窗口 283 双指针 303 在初始化方法中做预处理操作，减少频繁调用的方法中所做的工作量 414 使用了前面双指针的思路；也可以使用类似滑动窗口的思路，维护一个大小为3的有序集合 488 dfs 2023.04.19 496-下一个更大元素I 单调栈，（Go本身没有栈的库，但是通过数组很方便实现[[202304201957 栈]]） 2023.04.20 506-相对名次 深拷贝[[202304201947 深浅拷贝]]、go基本元素类型的降序排序 561-数组拆分 在于题目的分析，用贪心的方式来分析 556-重塑矩阵 二维数组的一维表示（m*n矩阵的第x个元素坐标：x/n，x%n） 594-最长和谐子序 错太多次了；移动窗口；数组计数，联想下标计数法 2023.04.21 674-最长连续递增序列 滑动窗口 744-寻找比目标字母大的最小字母 二分查找[[202304212107 二分查找]] 746-爬楼梯 动态规划 747 求数组的第一第二大的数 2023.04.22 1027-最长等差数列 动态规划[todo] 2023.04.23 1105-填充书架 动态规划 942-增减字符串匹配 贪心算法 914-卡牌分组 最大公约数 2023.04.24 1163 按字典序排在最后的子串【难】 后缀数组、sa-is算法（[[202304241453 后缀数组与SA-IS算法]]） 2023.04.25 125-验证回文 168-Excel表名称 26进制 2023.04.26 1031-两个非重叠子数组的最大和 动态规划+滑动窗口 综合题目 392-判断子序列 动态规划 459-重复的子字符串 KMP算法 680-验证回文 贪心 2023.04.29 剑指 Offer II 083. 没有重复元素集合的全排列 字典序 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 2023.04.24 总结一些分类出来 数组计数 数组找第几 位运算 ","date":"2023-05-09","objectID":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:0:0","series":[],"tags":["leetcode","个人记录"],"title":"leetcode 做题记录 ","uri":"/202304201936-leetcode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/#"},{"categories":["数据结构与算法"],"content":"#算法 希望能有成长，在此记录 ","date":"2023-05-09","objectID":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/:0:0","series":["算法"],"tags":["个人记录"],"title":"Leetcode 周赛记录","uri":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/#"},{"categories":["数据结构与算法"],"content":"第一场周赛 本着就做两题的心态来的，结果也算是完成了两题，不过过程还是不尽人意，第一道简单题就wa了五次，还是有点小紧张 第二道题思考的有点久，其实就是要在一个乱序的二维数组中快速找到一个数在第几行第几列的需求，如果这些数被保证在一个不大的范围内，那么可以直接做num2Idx[数字]=下标 这样的一个映射，就能快速找到对应数字在二维数组中的下标了 不过结果也还算是符合预期了，再接再厉吧 ","date":"2023-05-09","objectID":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/:1:0","series":["算法"],"tags":["个人记录"],"title":"Leetcode 周赛记录","uri":"/202304301159-leetcode-%E5%91%A8%E8%B5%9B%E5%8F%82%E5%8A%A0%E8%AE%B0%E5%BD%95/#第一场周赛"},{"categories":["扩展学习"],"content":"#ChatGPT ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:0:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#"},{"categories":["扩展学习"],"content":"一、目前互联网上已经存在的开放的站点 https://openai.com/ 官方网站，但是大部分亚洲 IP 已经被拦截，无法使用。但是可以挂 VPN （直连）到官网申请 api key，再套个 web 的外壳来使用，或者通过 jupyter notebook 来使用也可以 申请 api key 是不需要付费的，但是目前免费使用的额度只有 5 美元，超过需额外充值或者购买 ChatGPT Plus 版本 https://chatgptmirror.com/ 国内的一个镜像站点，需要收费 基于 GPT3.5turbo 和 GPT4 http://chat.gptforlove.com/ 免费 版本：ChatGPT 3.5 支持连续对话 https://chat.jinshutuan.com/ 免费 版本：非 OpenAI GTP 3.5+ 不支持连续对话 https://chatgpt.peterdavehello.org/ 免费 https://jiehan.tech/708 付费 基于 GPT3.5turbo 和 GPT4 更多站点可以参考 chatgpt-sites ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:1:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#一目前互联网上已经存在的开放的站点"},{"categories":["扩展学习"],"content":"二、关于如何在 openai 官网申请 api key可以参考该篇文章：https://bysocket.com/openai-services-are-not-available-in-your-country/ ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:2:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#二关于如何在-openai-官网申请-api-key"},{"categories":["扩展学习"],"content":"三、如何更好地使用 ChatGPT 来为自己工作","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:3:0","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#三如何更好地使用-chatgpt-来为自己工作"},{"categories":["扩展学习"],"content":"3.1《ChatGPT Prompt Engineering for Developers》课程学习用好提示词是关键 笔记产出：[[202305062133 面向开发者的 ChatGPT 提示工程]] ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:3:1","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#31chatgpt-prompt-engineering-for-developers课程学习"},{"categories":["扩展学习"],"content":"3.2 ChatGPT 中文调教指南《PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。》. 见于 2023年5月7日. https://github.com/PlexPt/awesome-chatgpt-prompts-zh. ","date":"2023-05-09","objectID":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/:3:2","series":["ChatGPT"],"tags":[],"title":"openai 使用实践","uri":"/202305070711-openai-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/#32-chatgpt-中文调教指南"},{"categories":["容器"],"content":"#k8s ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#"},{"categories":["容器"],"content":"一、概述operator 对于 k8s 来说，是一种扩展机制，开发人员可以通过 CRD，来扩展 k8s API operator 通过监视和管理 CRD，来执行一系列被预定的操作，这些操作被编写在 reconcile 逻辑里面，通过 CRD 的增加、删除、更新，可以触发不同的逻辑，在这些逻辑里面也可以对 k8s 原有的资源进行操作，比如 pod、configmap、service 等等 对于运维人员来说，operator 也是相当有用的，operator 可以负责用来做一些更高级的操作，比如扩缩容、集群的备份、恢复等操作，可以减轻运维人员的压力 ","date":"2023-05-09","objectID":"/202305080937-operator/:1:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#一概述"},{"categories":["容器"],"content":"二、名词解释、Operator 的工作流程","date":"2023-05-09","objectID":"/202305080937-operator/:2:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#二名词解释operator-的工作流程"},{"categories":["容器"],"content":"2.1 名词解释 GroupVersionKind GVK 是用来描述一个 kubernetes api 对象的标准 将 GroupVersionKind 拆分成三个部分来理解： Group Version Kind 在 Kubernetes 环境中可以通过命令查看： kubectl api-resources kubectl explain [kind] GroupVersionResource GroupVersionResource 和 GroupVersionKind 都是 Kubernetes API 中用于标识资源的数据结构，它们之间有一定的关系。 GroupVersionResource 由三个部分组成：group、version 和 resource。它用于唯一地标识 Kubernetes API 中的一个资源，并指定客户端对该资源执行 CRUD 操作的方式。 GroupVersionKind 也由三个部分组成：group、version 和 kind。它用于描述 Kubernetes API 中的一个对象，其中 kind 表示对象的类型，例如 Pod、Service 或 Deployment。 可以看出，GroupVersionResource 和 GroupVersionKind 的区别在于最后一个部分。GroupVersionResource 的最后一个部分是资源的名称，而 GroupVersionKind 的最后一个部分是对象的类型。但是，它们都包含了相同的前两个部分：group 和 version。这意味着，通过 GroupVersionKind 可以推断出对应的 GroupVersionResource，反之亦然。 因此，GroupVersionResource 和 GroupVersionKind 是紧密相关的概念，它们都是 Kubernetes API 中用于标识资源和对象的重要数据结构。 scheme scheme 提供了 kubernetes api 对象的序列化、反序列化的功能 在 operator 中，scheme 提供了向 kubernetes api 注册自定义对象的功能 所以每个 operator 都需要 scheme，提供了 go type 与 Kind 的映射，operator 才能与kubernetes api 更好的交互 Manager Cache、informer cache负责： 缓存 kubernetes api 对象 版本控制 索引 informer负责： 监听 kubernetes api 中的事件 当 controller 想要访问某个 api 资源，首先查找 cache 中是否存在，如果不存在再往 kuberntes api 中查找，cache 能够减少访问 kuberntes api 的次数，减轻 io 压力 为了保证缓存中的资源与 kuberntes api 中的资源保持一致，informer 需要监听 kubernetes api 中的事件，如果 kuberntes api 中的资源发生改变，cache 中也要同步变化，保证数据一致性 cache 还提供了对象的索引，提高查找效率。由于api 资源对象是具备版本的，因此 cache 也需要提供版本控制的功能，保证与 kuberntes api 中的资源是同一个版本 informer 是基于 cache 完成的一个高级组件，两者相互协作，都是为了让客户端更好的访问api 对象资源，cache主要用来做缓存、版本控制、索引的功能，informer 主要监听 kuberntes api 中的事件，更新缓存中的资源 这边顺便了解一下 ListAndWatch 机制： 与 Informer 类似，ListAndWatch 的作用也是为了让客户端或者控制器更好的获取 k8s 资源，它的大致工作流程如下： 使用 List 操作，从 Kubernetes API 获取全部的资源对象并保存 然后监听 kuberntes api 中的事件，如果对象发生更新，则对自己保存的对象也做相应更新 ","date":"2023-05-09","objectID":"/202305080937-operator/:2:1","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#21-名词解释"},{"categories":["容器"],"content":"2.2 operator 工作流程例如当一个 CRD 创建，会经过什么样的流程 一个 crd 资源创建，首先 kubernetes api 会监听到这个资源的创建，informer 会从 kuberntes api 收到这个事件，并获取对应的 crd 资源，将这个资源反序列化成对应的 go type，然后触发控制器中的 reconcile 逻辑，完成预定的操作 动画演示[^1] crd 创建请求发送到 API Server API Server 校验请求是否合法，是否有创建这个资源的权限 通过 API Server 后，到达准入控制器（Admission Controller），根据 crd 对应的校验规则进行 crd 资源的校验。此外 Admission Controller 还可能对资源进行修改操作 至此，crd 的创建已经被允许，一个 crd 实例被创建，并保存到 etcd 中 Controller Manager 启动对应的 Controller Controller 执行相应的 reconcile 逻辑，会监听 crd 的变化，并执行相应的逻辑 ","date":"2023-05-09","objectID":"/202305080937-operator/:2:2","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#22-operator-工作流程"},{"categories":["容器"],"content":"三、实践 创建 operator 项目的两个脚手架： kubebuilder OperatorSDK 该实践使用 kubebuilder 来完成，可参考： kubebuilder quick start 环境信息： go1.17.10 kubelet v1.19.4 docker 20.10.12 kubebuilder 3.4.0 kustomize v4.5.4 初始化项目 kubebuilder init --domain example.com --repo demo.domain/demo-operator kubebuilder create api --group demo --version v1 --kind Demo 修改api/v1/xxx_types.go make manifests 会生成对应的 crd yaml 文件 ./ ├── ... ├── config .. ├── crd ├── bases └── demo.example.com_demoes.yaml 构建 operator 镜像 docker build -t 904566722/kubebuilder-demo-operator:1.0.0 . docker push 904566722/kubebuilder-demo-operator:1.0.0 部署 crd make install # $(KUSTOMIZE) build config/crd | kubectl apply -f - 部署 rbac 相关 yaml kubectl apply -f config/rbac/ 创建 manager controller 修改 image 为上面制作的 operator 镜像 kubectl apply -f config/manager/manager.yaml pod 成功运行之后，创建 cr 实例 apiVersion:demo.example.com/v1kind:Demometadata:name:demo-samplespec:size:19type:democonfig_map_name:demo kubectl apply -f config/samples/demo_v1_demo.yaml operator 监听到 Demo kind 资源的创建，出发 reconcile： ","date":"2023-05-09","objectID":"/202305080937-operator/:3:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#三实践"},{"categories":["容器"],"content":"参考资料 Kubernetes Operator 开发教程 kustomization管理k8s对象 ","date":"2023-05-09","objectID":"/202305080937-operator/:0:0","series":["kubernetes学习"],"tags":["operator"],"title":"operator","uri":"/202305080937-operator/#参考资料"},{"categories":["Golang"],"content":"#Golang 在使用 for-range 遍历 string 中每个字符的时候，取出来的值是什么类型？ ![[Pasted image 20230423173934.png]] func isAlienSorted(words []string, order string) bool { // 首先要将 order 顺序映射成数值，来做比较 orderNums := make(map[rune]int, len(order)) for i, ch := range order { fmt.Println(reflect.TypeOf(order[i])) // uint8 fmt.Printf(\"%c\", order[i]) fmt.Println(reflect.TypeOf(ch)) // int32 fmt.Printf(\"%c\", ch) orderNums[ch] = i } return false } 对比：在遍历字符串的时候，有两种获取值的方式，如上面代码中的 ch、order[id]（索引的方式） ch 实际上的类型是 int32（与 rune 相同，应该是考虑到 string 中如果存储了中文字符，能够直接使用 “%c” 的表达式将这个中文输出） order[i] 实际上的类型是 uint8 （与 byte 相同，也就是一个字符的大小，占一个字节，但没法输出中文字符） ","date":"2023-05-09","objectID":"/202304231751-string-%E9%81%8D%E5%8E%86/:0:0","series":["Golang小疑问"],"tags":["string","for range"],"title":"string 遍历","uri":"/202304231751-string-%E9%81%8D%E5%8E%86/#"},{"categories":["Golang"],"content":"#Golang #struct 直接看一个例子，熟悉 struct 的简单使用： // ** struct practice type person struct { name string age int32 } func structPractice() { people := \u0026person{ name: \"索隆不喝酒\", age: 20, } fmt.Println(people) // \u0026{索隆不喝酒 20} fmt.Println(*people) // {索隆不喝酒 20} fmt.Println(\u0026people) // 0x1400000e038 fmt.Printf(\"[value]\\tname:%s\\tage:%d\\n\", people.name, people.age) // [value] name:索隆不喝酒 age:20 fmt.Printf(\"[value]\\tname:%s\\tage:%d\\n\", (*people).name, (*people).age) // [value] name:索隆不喝酒 age:20 fmt.Printf(\"[addr]\\tname:%d\\tage:%d\\n\", \u0026people.name, \u0026people.age) // [addr] name:1374389584016 age:1374389584032 } struct 存在方法集的概念，即所属于一个类型的方法的集合 202304241738 struct 方法集 ","date":"2023-05-09","objectID":"/202304241633-struct/:0:0","series":["Golang小疑问"],"tags":["struct"],"title":"struct","uri":"/202304241633-struct/#"},{"categories":["Golang"],"content":"#Golang #struct Go 语言中 struct 存在方法集（method set）的概念，看下面一段代码 type T struct { a int } func (t T) M1() { t.a++ } func (t *T) M2() { t.a++ } func structPractice2() { var t1 T var t2 = \u0026T{} fmt.Println(reflect.TypeOf(t1)) // T fmt.Println(reflect.TypeOf(t2)) // *T t1.M1() t1.M2() // (\u0026t1).M2() t2.M1() // (*t2).M1() t2.M2() } 变量 类型 方法集 t1 T {M1} t2 *T {M1,M2} 那么为什么 t1.M2() 不报错？ 可以看到 t1 的方法集只有 M1，M2方法的接收者类型是 *T 但是为什么 t1.M2() 这段代码不报错，这是由于 Go 语言提供的语法糖，Go 的编译器判断 t1 的类型为 T，跟 M2 方法的接收者不一致，自动转化成了 (\u0026t1).M2()；同理可解释 t2.M1() 那么既然存在这样的语法糖，来看看这样调用是不是可行的： T{}.M2() // Cannot call a pointer method on 'T{}' (\u0026T{}).M2()//OK (\u0026T{}).M1()//ok 会直接报错：无法通过 T{} 来调用一个指针方法 原因其实是上面提到的语法糖有一个前提： T 类型的实例，需要是可被取地址的（addressable） 《为什么这个T类型实例无法调用*T类型的方法 | Tony Bai》. 见于 2023年4月24日. https://tonybai.com/2022/02/27/go-addressable/. 鸟窝. 《go addressable 详解》, 2018年2月27日. https://colobu.com/2018/02/27/go-addressable/. 吴润写字的地方. 《Golang 不可寻址的理解》, 2021年11月12日. http://www.wu.run/2021/11/12/not-addressable-in-golang/index.html. ","date":"2023-05-09","objectID":"/202304241738-struct-%E6%96%B9%E6%B3%95%E9%9B%86/:0:0","series":["Golang小疑问"],"tags":["struct"],"title":"struct 方法集概念","uri":"/202304241738-struct-%E6%96%B9%E6%B3%95%E9%9B%86/#"},{"categories":["Golang"],"content":"#Golang #unsafe 概念：Pointer 表示一个指针，可以指向任何类型 四个特殊操作： 任何类型的指针值 可转化为 Pointer Pointer 可转化为 任何类型的指针值 uintptr 可转化为 Pointer Pointer 可转化为 uinptr 由于以上四个特性，Pointer 能够实现让程序绕过类型系统，读写任意内存（使用时需格外小心） ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:0:0","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#"},{"categories":["Golang"],"content":"下面列举 unsafe 包中列举的 unsafe.Pointer 使用的六种场景","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:0","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#下面列举-unsafe-包中列举的-unsafepointer-使用的六种场景"},{"categories":["Golang"],"content":"（1）*T1 –\u003e Pointer –\u003e *T2需要满足要求： T2 不大于 T1 T1、T2 共享相同的内存布局 (202304242150 内存布局) 则这种转换是允许的 例子1. 一个 float64 值转为 uint64 的值 func float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(\u0026f)) } 另外一个例子，将字符串转换为字节切片，首先我们看一下在 64 位系统中两者的尺寸 var s string var bs []byte fmt.Println(unsafe.Sizeof(s)) // 16 fmt.Println(unsafe.Sizeof(bs)) // 24 字符串 16 字节 字节切片 24 字节 字符串与字节切片的内存布局类似，且字节切片的尺寸不小于字符串的尺寸，因此将字节切片转到字符串是安全的，让我们来看实现： func byteSlice2String(bs []byte) string { return *(*string)(unsafe.Pointer(\u0026bs)) } 这种实现的优点是避免了底层对字节序列的一次开辟和复制 而如果要用此方式来实现从 string 到 []byte 则是不安全的： // 这种转换是不安全的 func string2Bytes(s string) []byte { return *(*[]byte)(unsafe.Pointer(\u0026s)) } ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:1","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#1t1----pointer----t2"},{"categories":["Golang"],"content":"（2）Pointer –\u003e uintptr （用途少）从指针转到 uintptr 类型实际上产生了一个没有指针语义的整数（代表指针指向值的内存地址，只是一个整数，不是引用），所以这种情况下，再将 uintptr 转回指针是无效的，通常的用法是将这个 uintptr 打印出来 即使uintptr保存了某个对象的地址，如果对象移动，垃圾收集器也不会更新该uintptr的值，也不会阻止该对象被回收 下面的情况说明了从 uintptr 转到 Pointer 的可能场景 ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:2","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#2pointer----uintptr-用途少"},{"categories":["Golang"],"content":"（3）算数运算 （Pointer –\u003e uintptr –\u003e 运算 –\u003e Pointer）这种操作通常是用来访问： 结构的字段 数组的元素 一个例子： // ** 通过 uintptr 来访问结构中的字段、数组的元素 ** type T struct { a int16 arr [3]int32 } func uintptr2PointerPractice() { // unsafe.Sizeof(T{}.a) // 2 M := unsafe.Offsetof(T{}.arr) // 4 N := unsafe.Sizeof(T{}.arr[0]) // 4 fmt.Println(unsafe.Sizeof(T{}.a)) // 2 fmt.Println(unsafe.Sizeof(T{}.arr)) // 3 * 4 = 12 fmt.Println(unsafe.Sizeof(T{})) // 16 t := \u0026T{ arr: [3]int32{1, 2, 3}, } // 直接访问 t.arr 的最后一个元素 tp := unsafe.Pointer(t) // 先将 t 转为非安全指针 // 将 uintptr 进行算数运算后再转为非安全指针 arrp := unsafe.Pointer(uintptr(tp) + M + N + N) // 将非安全指针转为数组元素类型指针 ans := (*int32)(arrp) // ans := (*int32)(unsafe.Pointer(uintptr(tp) + M + N + N)) fmt.Println(*ans) // output: 3 } 特别注意在这种场景下，可能会发生的很隐秘的 bug： func uintptr2PointerPractice2() { // unsafe.Sizeof(T{}.a) // 2 M := unsafe.Offsetof(T{}.arr) // 4 N := unsafe.Sizeof(T{}.arr[0]) // 4 t := T{ arr: [3]int32{1, 2, 3}, } uptr := uintptr(unsafe.Pointer(\u0026t)) + M + N + N // 中间其他操作 elemP := (*int32)(unsafe.Pointer(uptr)) fmt.Println(*elemP) // output: 3 } 前面提到了，虽然 uintptr 保存了 t 的地址的值，但是并不会阻止垃圾回收机制将 t 回收，所以在中间其他操作的时候，一旦 t 被回收，后面的地址将指向不可预测的内容。 实际上，像 Goland 编码工具在编码的时候就会给出提示： ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:3","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#3算数运算-pointer----uintptr----运算----pointer"},{"categories":["Golang"],"content":"（4）Pointer –\u003e uintptr –\u003e syscall在 syscall 系统调用中，可能会根据调用的具体实现将 uintptr 重新转为指针 注意：转换必须在调用的表达式中出现，在系统调用期间隐式转换为指针之前，uintptr 不能保存在变量中 正确： syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n)) 错误 u := uintptr(unsafe.Pointer(p)) // p 所引用的对象可能在这个时候被垃圾回收，或者 p 的地址发生改变 syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n)) ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:4","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#4pointer----uintptr----syscall"},{"categories":["Golang"],"content":"（5）将 reflect.Value.Pointer 或者 reflect.Value.UnsafeAddr 的结果从 uintptr 转到 Pointer","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:5","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#5将-reflectvaluepointer-或者-reflectvalueunsafeaddr-的结果从-uintptr-转到-pointer"},{"categories":["Golang"],"content":"（6）将一个reflect.SliceHeader或者reflect.StringHeader值的Data字段转换为非类型安全指针，以及其逆转换首先我们来看reflect.SliceHeader 和 reflect.StringHeader 的定义： // StringHeader是字符串的运行时表示形式。 // 它不能安全或可移植地使用，并且它的表示可能在以后的版本中更改。 // 此外，Data字段不足以保证它引用的数据不会被垃圾收集， // 因此程序必须保留一个单独的、类型正确的指向底层数据的指针。 type StringHeader struct { Data uintptr Len int } // SliceHeader是切片的运行时表示。 // 它不能安全或可移植地使用，并且它的表示可能在以后的版本中更改。 // 此外，Data字段不足以保证它引用的数据不会被垃圾收集， // 因此程序必须保留一个单独的、类型正确的指向底层数据的指针。 type SliceHeader struct { Data uintptr Len int Cap int } 一个使用 StringHeader 的例子： func uintptrPractice4() { a := [...]byte{'a', 'b', 'c', 'd', 'e'} b := \"java\" hdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026b)) hdr.Data = uintptr(unsafe.Pointer(\u0026a)) hdr.Len = len(a) // 至此，a 和 b 共享底层的字节序列 a[1], a[2], a[3], a[4] = 'a', 'a', 'a', 'a' fmt.Println(b) // out: aaaaa } 将字符串指针转为*StringHeader，从而可以对字符串的内部进行修改 《非类型安全指针 -Go语言101》. 见于 2023年4月25日. https://gfw.go101.org/article/unsafe.html. ","date":"2023-05-09","objectID":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/:1:6","series":["Golang源码学习"],"tags":["unsafe包"],"title":"unsafe.Pointer 的六种使用场景","uri":"/202304241708-unsafe.pointer-%E7%9A%84%E5%85%AD%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/#6将一个reflectsliceheader或者reflectstringheader值的data字段转换为非类型安全指针以及其逆转换"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":"二叉搜索树树概述二叉搜索树：左子树所有节点的值 \u003c 根节点 \u003c 右子树所有节点的值 二叉搜索树的相关操作： 构建 判断 删除节点 增加节点 ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:1:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#二叉搜索树树概述"},{"categories":["数据结构与算法"],"content":"相关操作","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:0","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#相关操作"},{"categories":["数据结构与算法"],"content":"判断是否是二叉搜索树递归实现 // 递归实现 // 从二叉搜索树当前节点的值可以推出左右节点的取值区间，递归判断每个节点即可 func isValidBST(root *TreeNode) bool { if root == nil { return true } return jud(root, math.MinInt, math.MaxInt) } func jud(root *TreeNode, start, end int) bool { if root == nil { return true } if root.Val \u003c= start || root.Val \u003e= end { return false } return jud(root.Left, start, root.Val) \u0026\u0026 jud(root.Right, root.Val, end) } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:1","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#判断是否是二叉搜索树"},{"categories":["数据结构与算法"],"content":"插入节点递归实现 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } if val \u003c root.Val { root.Left = insertIntoBST(root.Left, val) } else { root.Right = insertIntoBST(root.Right, val) } return root } 非递归实现 func insertIntoBST2(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026TreeNode{ Val: val, } } pre := root tmpRoot := root for tmpRoot != nil { if val \u003c tmpRoot.Val { pre = tmpRoot tmpRoot = tmpRoot.Left } else { pre = tmpRoot tmpRoot = tmpRoot.Right } } newNode := \u0026TreeNode{Val: val} if val \u003c pre.Val { pre.Left = newNode } else { pre.Right = newNode } return root } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:2","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#插入节点"},{"categories":["数据结构与算法"],"content":"删除节点 // 如果找到该节点，有四种情况： // 没有左节点，直接将右子树代替该节点的位置 // 没有右节点，直接将左子树代替该节点的位置 // 均有左右节点，根据中序节点的性质，当前的序列为：左子树、当前节点、右子树的最左节点 // 删除当前节点之后，为了保持中序，需要将左子树嫁接到右子树的最左节点的左节点，然后将右子树的根节点替换当前节点的位置 // 均没有左右节点（叶子节点），直接删除该节点 func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } var curParent *TreeNode = nil cur := root for cur != nil \u0026\u0026 cur.Val != key { curParent = cur if key \u003c cur.Val { cur = cur.Left } else { cur = cur.Right } } // not found if cur == nil { return root } if cur.Left != nil \u0026\u0026 cur.Right != nil { rightMinNode := cur.Right for rightMinNode.Left != nil { rightMinNode = rightMinNode.Left } rightMinNode.Left = cur.Left cur = cur.Right } else if cur.Left != nil { cur = cur.Left } else if cur.Right != nil { cur = cur.Right } else { cur = nil } if curParent == nil { return cur } if curParent.Left != nil \u0026\u0026 curParent.Left.Val == key { curParent.Left = cur } else { curParent.Right = cur } return root } ","date":"2023-05-09","objectID":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:3","series":["数据结构"],"tags":[],"title":"二叉搜索树","uri":"/202305040442-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#删除节点"},{"categories":["Golang"],"content":"#Golang 问题：两个数据有相同的内存布局，应该满足什么条件？ ","date":"2023-05-09","objectID":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","series":["Golang底层认知"],"tags":["内存布局"],"title":"内存布局","uri":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/#"},{"categories":["Golang"],"content":"类型对齐保证出于对程序性能的考虑，每个类型都会有对应的对齐保证，根据该类型是否被作为结构字段，对齐保证分为两类： 字段对齐保证 一般对齐保证 说法：如果一个类型的对齐保证为N，那么就说这个类型是 N 字节对齐的 这两类对齐保证对应的获取方式： unsafe.Alignof(t) （编译的时候估值） reflect.TypeOf(t).Align() reflect.TypeOf(t).FieldAlign() type X struct { c int32 d int64 } func getAlignmentGuarantee() { var a int32 // 使用 unsafe.Alignof() fmt.Println(unsafe.Alignof(a)) // 4 （获取 int32 的一般对齐保证） fmt.Println(unsafe.Alignof(X{}.c)) // 4 （获取 int32 的字段对齐保证） fmt.Println(unsafe.Alignof(X{}.d)) // 8 fmt.Println(unsafe.Alignof(X{})) // 8 // 使用 reflect.TypeOf(a).Align() 以及 reflect.TypeOf(a).FieldAlign() fmt.Println(reflect.TypeOf(a).Align()) // 4 fmt.Println(reflect.TypeOf(a).FieldAlign()) // 4 } 注意上面程序的输出并不是固定的，相同的编译器在不同的架构上、不同的编译器在相同的架构上，都有可能产生不同的输出 Go 编译器中，对类型对齐保证要求： unsafe.Alignof(t) \u003e= 1 unsafe.Alignof(结构) = 结构体字段的字段对齐保证的最大值 unsafe.Alignof(数组) = unsafe.Alignof(元素类型) ","date":"2023-05-09","objectID":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","series":["Golang底层认知"],"tags":["内存布局"],"title":"内存布局","uri":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/#类型对齐保证"},{"categories":["Golang"],"content":"结构体的字节填充为了能够让结构体的尺寸为类型对齐保证的 N 倍，有时候需要对结构进行字节补齐，看下面的一个例子，展示了两个内容： 结构体尺寸的计算 结构体的字节填充 // 假设在 64 位机器上的情况 type T1 struct { a int8 // 为了让 b 能够8字节对齐，这里要填充 7 个字节 b int64 c int16 // 前面一共的尺寸为 1 + 7 + 8 + 2 = 18 个字节 // 为了让 T1 的尺寸为 8 的倍数，这里需要填充 24 - 18 = 6 个字节 } // 因此 T1 类型的尺寸为 24 个字节 type T2 struct { a int8 // 为了让 b 能够 2 字节对齐，这里填充 1 字节 b int16 // 为了让 c 能够 8 字节对齐，这里填充 4 字节 c int64 // 前面一共 1 + 1 + 2 + 4 + 8 = 16 字节，因此这里不需要再填充 } // 因此 T2 类型的尺寸为 16 个字节 从上面这个例子可以看到，尽管 T1 跟 T2 拥有一样的字段类型，但因为排列的不同，导致字节填充的数量不同，因此其尺寸也不同。 问题：[[202304242320 一个零尺寸的类型有没有可能影响到结构体的尺寸]] 《内存布局 -Go语言101》. 见于 2023年4月24日. https://gfw.go101.org/article/memory-layout.html. 《The Go Programming Language Specification - The Go Programming Language》. 见于 2023年4月24日. https://go.dev/ref/spec. The Go Programming Language Specification 中文：https://github.com/saberuster/Go-Language-Specification ","date":"2023-05-09","objectID":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","series":["Golang底层认知"],"tags":["内存布局"],"title":"内存布局","uri":"/202304242150-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/#结构体的字节填充"},{"categories":["扩展学习"],"content":"#ChatGPT ","date":"2023-05-09","objectID":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/:0:0","series":["ChatGPT"],"tags":["jupyter"],"title":"可以在什么平台上使用 openai","uri":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/#"},{"categories":["扩展学习"],"content":"一、使用 jupyter notebook前置： 安装 python 安装 jupyter notebook 加载环境、定义方法： import openai import os from dotenv import load_dotenv, find_dotenv _ = load_dotenv(find_dotenv()) openai.api_key = 'sk-xxxxx' def get_completion(prompt, model=\"gpt-3.5-turbo\"): messages = [{\"role\": \"user\", \"content\": prompt}] response = openai.ChatCompletion.create( model=model, messages=messages, temperature=0, # this is the degree of randomness of the model's output ) return response.choices[0].message[\"content\"] 使用时传入 prompt 参数： prompt = f\"\"\" She no went to the market 上面这句英文存在什么样的语法错误 \"\"\" response = get_completion(prompt) print(response) 效果： 在线演示：https://learn.deeplearning.ai/chatgpt-prompt-eng/lesson/2/guidelines ","date":"2023-05-09","objectID":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/:1:0","series":["ChatGPT"],"tags":["jupyter"],"title":"可以在什么平台上使用 openai","uri":"/202305070218-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E4%B8%8A%E4%BD%BF%E7%94%A8-openai/#一使用-jupyter-notebook"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"一、后缀数组概念：将 s 的所有后缀排序后的数组 见下面的一个例子： ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#一后缀数组"},{"categories":["数据结构与算法"],"content":"在 Go 中获得后缀数组的方法 type Index struct { _ []byte sa []int32 } func lastSubstring3(s string) string { index := suffixarray.New([]byte(s)) idx := (*Index)(unsafe.Pointer(index)) fmt.Println(idx.sa) // s=\"aabaaaab\" output:[3 4 5 0 6 1 7 2] return \"\" } 思考： unsafe.Pointer 的使用 (202304241708 unsafe.Pointer 的六种使用场景) 为什么是 (*Index) 这样的写法？ 顺便复习下 struct 结构体（202304241633 struct） ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:1:1","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#在-go-中获得后缀数组的方法"},{"categories":["数据结构与算法"],"content":"二、SA-IS 算法概念：（Suffix Array Induce Sort；SA-IS） todo 参考资料： 《诱导排序与SA-IS算法 - riteme.site》. 见于 2023年4月24日. https://riteme.site/blog/2016-6-19/sais.html. 第一次接触到后缀数组以及SA-IS算法是在leetcode每日一题（1163.按字典序排在最后的字串）中 ","date":"2023-05-09","objectID":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"后缀数组与SA-IS算法","uri":"/202304241453-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8Esa-is%E7%AE%97%E6%B3%95/#二sa-is-算法"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:0:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#"},{"categories":["数据结构与算法"],"content":"一、基本概念定义：G = (V, E) 图的分类 边是否有方向： 有向图 无向图 图中是否有环： 有环图 无环图 连通图和非连通图 连通图 非连通图 ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:1:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#一基本概念"},{"categories":["数据结构与算法"],"content":"二、图的存储 顺序 链式 五种树的存储方式的比较： 操作 邻接矩阵 边集数组 邻接表 链式前向星 哈希表实现邻接表 图的初始化 n^2 m n+m n+m 查某条边是否存在 1 m TD(vi) TD(vi) 遍历某个点的所有边 n m TD(vi) TD(vi) 遍历整张图 n^2 nm n+m n+m 空间复杂度 n m n+m n+m ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#二图的存储"},{"categories":["数据结构与算法"],"content":"2.1 邻接矩阵（ 二维数组）","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:1","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#21-邻接矩阵-二维数组"},{"categories":["数据结构与算法"],"content":"2.2 边集数组","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:2","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#22-边集数组"},{"categories":["数据结构与算法"],"content":"2.3 邻接表（数组+链式结构） // 邻接点 type AdjNode struct { AdjN int // 邻接点标号 Weight int //顶点到该邻接点的权重 Next *AdjNode } // 顶点 type VNode struct { Val int FirstAdjNode *AdjNode } type Graph struct { VNum int ENum int VNodes []VNode } type Edge struct { V1, V2 int Weight int } func InitGraph(VertexNum int) *Graph { g := \u0026Graph{ VNum: VertexNum, ENum: 0, VNodes: make([]VNode, VertexNum), } //for _, vnode := range g.VNodes { //vnode.Val = //} return g } func InsertEdge(graph *Graph, e *Edge) { v1VNode := graph.VNodes[e.V1-1] // 假设 v1 节点存储在下标 0 的位置 // 新建一个 v2 的邻接点 v2Adj := \u0026AdjNode{ AdjN: e.V2, Weight: e.Weight, Next: v1VNode.FirstAdjNode, } v1VNode.FirstAdjNode = v2Adj // 如果是无向图，还需要添加从 v2 到 v1 的连接 v2VNode := graph.VNodes[e.V2-1] v1Adj := \u0026AdjNode{ AdjN: e.V1, Weight: e.Weight, Next: v2VNode.FirstAdjNode, } v2VNode.FirstAdjNode = v1Adj } func BuildGraph(vnum int, v1s, v2s []int, weight []int) *Graph { graph := InitGraph(vnum) for i := 0; i \u003c len(v1s); i++ { e := \u0026Edge{ V1: v1s[i], V2: v2s[i], Weight: weight[i], } InsertEdge(graph, e) } return graph } func test1() { vnum := 4 v1s := []int{1,1,3,1} v2s := []int{2,3,4,4} weights := []int{1,2,3,4} graph := BuildGraph(vnum, v1s, v2s, weights) for i, vnode := range graph.VNodes { adj := vnode.FirstAdjNode for adj != nil { fmt.Printf(\"(%d,%d) 权重 %d \\n\",i+1, adj.AdjN, adj.Weight) adj = adj.Next } } } ","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:3","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#23-邻接表数组链式结构"},{"categories":["数据结构与算法"],"content":"2.4 链式前向星（数组+静态链表）","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:4","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#24-链式前向星数组静态链表"},{"categories":["数据结构与算法"],"content":"2.5 哈希表实现邻接表","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:2:5","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#25-哈希表实现邻接表"},{"categories":["数据结构与算法"],"content":"三、图的遍历","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:0","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#三图的遍历"},{"categories":["数据结构与算法"],"content":"3.1 DFS","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:1","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#31-dfs"},{"categories":["数据结构与算法"],"content":"3.2 BFS","date":"2023-05-09","objectID":"/202305040737-%E5%9B%BE/:3:2","series":["数据结构"],"tags":[],"title":"图","uri":"/202305040737-%E5%9B%BE/#32-bfs"},{"categories":["容器"],"content":"#k8s ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:0:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#"},{"categories":["容器"],"content":"一、环境准备 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 关闭 selinux sed -i 's/enforcing/disabled/' /etc/selinux/config 关闭 swap sed -ri 's/.*swap.*/#\u0026/' /etc/fstab 添加 hosts cat \u003e\u003e /etc/hosts \u003c\u003c EOF 192.168.108.132 centos7-master 192.168.108.130 centos7-node1 EOF 设置网桥参数 cat \u003e /etc/sysctl.d/k8s.conf \u003c\u003c EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system # 生效 时间同步 yum install ntpdate -y # 没有的 ntpdate 则安装 ntpdate time.windows.com # 同步时间 ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:1:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#一环境准备"},{"categories":["容器"],"content":"二、安装 安装 Docker、kubeadm、kubelet、kubectl Docker 安装 wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo # 更新 docker 的 yum 源 yum install docker-ce-19.03.13 -y 配置镜像 mkdir /etc/docker cat \u003c\u003c EOF \u003e /etc/docker/daemon.json { \"registry-mirrors\": [\"https://kfwkfulq.mirror.aliyuncs.com\"] } EOF systemctl enable docker.service 添加 k8s 的yum源 cat \u003e /etc/yum.repos.d/kubernetes.repo \u003c\u003c EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 安装 kubeadm、kubelet、kubectl yum install kubelet-1.19.4 kubeadm-1.19.4 kubectl-1.19.4 -y systemctl enable kubelet.service # 开启服务 重启 centos 部署 master 节点 kubeadm init --apiserver-advertise-address=【master服务器ip地址】 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.19.4 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 添加 node 节点 kubeadm join 192.168.108.132:6443 --token d99d8g.3wr8skktnv3m9e46 \\ --discovery-token-ca-cert-hash sha256:0ba36403007aa7ef77b174a65a8e3de27bcbcac9fbb5b2bb31c337a565d4e16 部署网络插件 wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl apply -f kube-flannel.yml ","date":"2023-05-09","objectID":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/:2:0","series":["kubernetes实操"],"tags":["实操"],"title":"在 vmware 上本地搭建 kubernetes 集群","uri":"/202305080545-kubernetes-%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/#二安装"},{"categories":["数据结构与算法"],"content":"#算法 复习一下基本的排序算法 有几种基本的排序算法： 冒泡排序 选择排序 插入排序 希尔排序（递减增量的排序；插入排序的改进版本） 归并排序 快速排序 桶排序 堆排序 计数排序 基数排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"一、冒泡步骤： 一直往前走，比较相邻两个数，大数往后放 func bubbleSort(nums []int) { if len(nums) \u003c= 1 { return } // nums: 6 10 2 4 7 3 2 1 2 // loop1 j (loop2每进行一轮往前移，直到1) // loop2 i for j := len(nums)-1; j \u003e= 1; j--{ for i := 0; i \u003c j; i++ { if nums[i] \u003e nums[i+1] { swap(\u0026nums[i], \u0026nums[i+1]) } } } } 时间复杂度分析：O(n^2) 第一轮比较 n-1 次 第二轮比较 n-2 次 …. 第n-1轮比较 1 次 1 + 2 + … + (n-1) = n (n-1 + 1) / 2 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#一冒泡"},{"categories":["数据结构与算法"],"content":"二、选择排序步骤： 每次从未排序找最小 func selectSort(nums []int) { for i := 0; i \u003c len(nums)-1; i++ { minIdx := i for j := i+1; j \u003c len(nums); j++ { if nums[j] \u003c nums[i] { minIdx = j } } swap(\u0026nums[i], \u0026nums[minIdx]) } } 时间复杂度也是 O(n^2) ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#二选择排序"},{"categories":["数据结构与算法"],"content":"三、插入排序步骤： 从已排序找合适的位置 func insertSort(nums []int) { // nums 1 2 5 3 4 // i (i极其右边为一个 未排序的序列) // j=i-1 (j 负责往前找大于等于cur的值) for i := 1; i \u003c len(nums); i++ { cur := nums[i] j := i-1 for ; j\u003e=0 \u0026\u0026 nums[j]\u003ecur; j-- { nums[j+1] = nums[j] } // 由于 j 当前的位置小于或者等于cur or 越界 // 故把前面一个位置，给到cur（前面的数已经往前前的位置移动） nums[j+1] = cur } } ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#三插入排序"},{"categories":["数据结构与算法"],"content":"四、归并排序202304300231 归并排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#四归并排序"},{"categories":["数据结构与算法"],"content":"五、快速排序202304300312 快速排序 ","date":"2023-05-09","objectID":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","series":["算法"],"tags":[],"title":"基本的排序算法","uri":"/202304291858-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#五快速排序"},{"categories":["数据结构与算法"],"content":"#算法 用途：给定一个数组，返回基于字典序的下一个数组排列 四个步骤： 找上坡 找大于且最小 交换 倒序 Go 实现： func nextDicArr(nums []int) []int { if len(nums) \u003c= 1 { return } pos := -1 for i := len(nums)-2; i \u003e= 0; i-- { if nums[i] \u003c nums[i+1] { pos = i break } } // 没找到上坡（左值小于右值），说明已经是降序排列 if pos == -1 { for i,n := 0,len(nums); i \u003c n/2; i++ { nums[i], nums[n-i-1] = nums[n-i-1], nums[i] } return nums } // 找到 pos，接着找右边大于该值的最小值（也就是第一个大于标记的值） biggerThanPos := -1 for i := len(nums)-1; i \u003e= pos+1; i-- { if nums[i] \u003e nums[pos] { biggerThanPos = i break } } nums[pos], nums[biggerThanPos] = nums[biggerThanPos], nums[pos] // 剩下的倒序 for i,n,cnt := pos+1, len(nums),0; i \u003c (n + pos+1)/2; i++ { nums[i], nums[n-cnt-1] = nums[n-cnt-1], nums[i] cnt++ } return nums } 习题练习： https://leetcode.cn/problems/VvJkup/ 《字典序算法详解_HappyRocking的博客-CSDN博客》. 见于 2023年4月29日. https://blog.csdn.net/HappyRocking/article/details/83619392. ","date":"2023-05-09","objectID":"/202304290644-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","series":["算法"],"tags":[],"title":"字典序算法","uri":"/202304290644-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/#"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#"},{"categories":["数据结构与算法"],"content":"归并排序的思想归并排序是一种采用了递归思想的排序，采用递归[[202304300007 递归]]的思想来分析就是： 原问题 \u0026 解决方法 原问题：将 nums 排序 解决办法：将数组 nums 分成两个序列 nums1、nums2，将 nums1、nums2 排序后合并 子问题 \u0026 解决方法 子问题：将 nums1、nums2 排序 解决办法：两个子数组都能够通过原问题的解决办法解决 结束条件：当数组不能再划分（长度=1） 时间复杂度： 合并的平均时间复杂度O(n) x 拆分的深度 logn = O(nlogn) ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#归并排序的思想"},{"categories":["数据结构与算法"],"content":"实现Golang： // 1. 定义方法：将左右两个已经有序的序列合并成一个序列（原问题得解：原数组有序） // 2. 子问题：左右的数组需要有序，与原问题解决方法相同 // 3. 结束条件：数组的长度为 1 func mergeSort(nums []int) []int { // 结束条件 if len(nums) \u003c= 1 { return nums } // 子问题关系 mid := len(nums) / 2 left := mergeSort(nums[:mid]) right := mergeSort(nums[mid:]) // 方法定义 return merge(left, right) } // 将两个有序数组合并 func merge(nums1, nums2 []int) []int { n1, n2 := len(nums1), len(nums2) nums := make([]int, n1 + n2) i, j, idx := 0, 0, 0 for i \u003c n1 \u0026\u0026 j \u003c n2 { if nums1[i] \u003c nums2[j] { nums[idx] = nums1[i] i++ } else { nums[idx] = nums2[j] j++ } idx++ } for ; i \u003c n1; i++ { nums[idx] = nums1[i] idx++ } for ; j \u003c n2; j++ { nums[idx] = nums2[j] idx++ } return nums } 1.《图解排序算法(四)之归并排序 - dreamcatcher-cx - 博客园》. 见于 2023年4月30日. https://www.cnblogs.com/chengxiao/p/6194356.html. ","date":"2023-05-09","objectID":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:0","series":["算法"],"tags":[],"title":"归并排序","uri":"/202304300231-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#实现"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#"},{"categories":["数据结构与算法"],"content":"快速排序的思想快速排序采用了分治的思想，可以通过递归来实现 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:1:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的思想"},{"categories":["数据结构与算法"],"content":"步骤 原问题 \u0026 解决办法 原问题：nums 数组排序 解决办法：选一个元素作为基准，将小于基准的数放到左边，大于基准的数放到右边（分区间） 子问题 \u0026 解决办法 子问题：左右区间的排序 解决办法：同原问题 结束条件：数组只有一个元素 ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:2:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#步骤"},{"categories":["数据结构与算法"],"content":"实现 // nums 数组排序 func quickSort(nums []int, start, end int) { // 结束条件 if start \u003e= end { return } // 子问题关系 pivot := partition(nums, start, end) quickSort(nums, start, pivot) quickSort(nums, pivot+1, end) return } func partition(nums []int, start, end int) int { if start == end { } pivot := start idx := start + 1 for i := start+1; i \u003c= end; i++ { if nums[i] \u003c nums[pivot] { swap(\u0026nums[i], \u0026nums[idx]) idx++ } } swap(\u0026nums[pivot], \u0026nums[idx-1]) return idx-1 } 《1.6 快速排序 | 菜鸟教程》. 见于 2023年4月30日. https://www.runoob.com/w3cnote/quick-sort-2.html. ","date":"2023-05-09","objectID":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:3:0","series":["算法"],"tags":[],"title":"快速排序","uri":"/202304300312-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#实现"},{"categories":["Golang"],"content":"#Golang 栈的相关操作有：入栈（push）、出栈（pop）（出栈的同时删除），获取栈顶元素（top） type myStack struct { Nums []int } func (s *myStack) push(n int) { s.Nums = append(s.Nums, n) } func (s *myStack) pop() int { if s.isEmpty() { return 0 } top := s.Nums[len(s.Nums)-1] s.Nums = s.Nums[:len(s.Nums)-1] // num[n:m] 的下标范围 [n,m) return top } func (s *myStack) top() int { return s.Nums[len(s.Nums)-1] } func (s *myStack) isEmpty() bool { if len(s.Nums) == 0 { return true } return false } ","date":"2023-05-09","objectID":"/202304201957-%E6%A0%88/:0:0","series":["Golang代码片段"],"tags":[],"title":"栈","uri":"/202304201957-%E6%A0%88/#"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:0:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":"一些基本概念树四度： 度 节点的度：节点拥有的子节点数量 树的度：节点的度的最大值 深度：根节点到当前节点的距离 高度：根节点到最低节点的距离 树的实际应用： 帮助分析时间复杂度 搜索 排序 路径查找 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:1:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#一些基本概念"},{"categories":["数据结构与算法"],"content":"几种常见的树 二叉树 满二叉树 完全二叉树 二叉搜索树 [[202305040442 二叉搜索树]] 平衡二叉搜索树 线段树 平衡树 B 树 红黑树 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:2:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#几种常见的树"},{"categories":["数据结构与算法"],"content":"树的遍历方式深度：前序（DLR）、中序（LDR）、后序（LRD） 广度：层序遍历 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#树的遍历方式"},{"categories":["数据结构与算法"],"content":"前序遍历用递归的思想可以将问题看作： 访问跟节点 前序遍历左节点 前序遍历右节点 // 前序遍历: 访问根节点，以前序遍历的方式访问左节点，以前序遍历的方式访问右节点 func pOrder(root *treeNode) { // end if root == nil { return } fmt.Printf(\"%d \", root.val) pOrder(root.left) pOrder(root.right) return } 使用栈实现： 将根节点入栈 出栈，加入右节点跟左节点 重复以上操作，直到栈空 func pOrderStack(root *treeNode) { if root == nil { return } var st []*treeNode st = append(st, root) var pnt []int for len(st) \u003e 0 { // pop cur := st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, cur.val) // judge left\\right if cur.right != nil { st = append(st, cur.right) } if cur.left != nil { st = append(st, cur.left) } } fmt.Println(pnt) } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:1","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#前序遍历"},{"categories":["数据结构与算法"],"content":"中序遍历递归实现： // 按中序遍历访问左节点，访问节点元素，按中序遍历访问右节点 func ldrOrder(root *treeNode) { if root == nil { return } ldrOrder(root.left) fmt.Printf(\"%d \", root.val) ldrOrder(root.right) return } 栈实现： 从根节点开始入栈，一直往左，直到最左叶子节点 出栈，访问节点 将右节点当作步骤1的根节点（若存在） func ldrOrderStack(root *treeNode) { if root == nil { return } var st []*treeNode cur := root // 找到最左叶子节点 for cur != nil { st = append(st, cur) cur = cur.left } // 出栈，访问元素 // 如果存在右节点，继续入栈，直到最左叶子节点 var pnt []int for len(st) \u003e 0 { cur := st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, cur.val) tmp := cur.right for tmp != nil { st = append(st, tmp) tmp = tmp.left } } return } // 代码优化 func ldrOrderStack2(root *treeNode) { if root == nil { return } var st []*treeNode // 出栈，访问元素 // 如果存在右节点，继续入栈，直到最左叶子节点 var pnt []int tmp := root for len(st) \u003e 0 || tmp != nil { // 入栈直到最左节点 for tmp != nil { st = append(st, tmp) tmp = tmp.left } // 出栈，访问节点元素 tmp = st[len(st)-1] st = st[:len(st)-1] pnt = append(pnt, tmp.val) // 继续找右节点的最左叶子节点 tmp = tmp.right } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:2","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#中序遍历"},{"categories":["数据结构与算法"],"content":"后续遍历递归实现： func lrdOrder(root *treeNode) { if root == nil { return } lrdOrder(root.left) lrdOrder(root.right) fmt.Printf(\"%d \", root.val) return } 栈实现： 从根节点开始入栈，直到最左节点 获取栈顶，判断右节点 右节点不存在：访问该节点，出栈 右节点已经访问过：访问该节点，出栈 右节点未访问，进入步骤3 将该右节点当作步骤1的根节点 func lrdOrderStack(root *treeNode) { var st []*treeNode tmpRoot := root pre := root for len(st) \u003e 0 || tmpRoot != nil { for tmpRoot != nil { st = append(st, tmpRoot) tmpRoot = tmpRoot.left } tmpRoot = st[len(st)-1] // 当节点右节点为空 或者 右子树已经访问过的情况下，访问根节点 if tmpRoot.right == nil || tmpRoot.right == pre { fmt.Printf(\"%d \", tmpRoot.val) pre = tmpRoot tmpRoot = nil // 将当前节点标记为空，避免下一个循环又将该节点入栈 st = st[:len(st)-1] } else { // 右节点还没访问，后序遍历右节点 tmpRoot = tmpRoot.right } } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:3","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#后续遍历"},{"categories":["数据结构与算法"],"content":"层序遍历层序遍历使用队列实现： func levelOrder(root *treeNode) { if root == nil { return } var queue []*treeNode queue = append(queue, root) for len(queue) \u003e 0 { cur := queue[0] queue = queue[1:] fmt.Printf(\"%d \", cur.val) if cur.left != nil { queue = append(queue, cur.left) } if cur.right != nil { queue = append(queue, cur.right) } } return } ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:4","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#层序遍历"},{"categories":["数据结构与算法"],"content":"遍历的复杂度 遍历 时间复杂度 空间复杂度 先序 O(n) 递归调用的时间复杂度为O(1)，递归调用的次数为数中节点的数量n 栈实现的空间复杂度为：O(h) h为数的高度 在较差的情况下，h = n；如果是平衡二叉树，h = logn 中序 O(n) 同上 后序 O(n) 同上 层序 O(n) O(w) w 为树的宽度 ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:3:5","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#遍历的复杂度"},{"categories":["数据结构与算法"],"content":"树的一些常见问题202305021918 树问题-路径求和 202305031652 树问题-判断子树 《02.二叉树的遍历知识》. 见于 2023年4月30日. https://algo.itcharge.cn/07.Tree/01.Binary-Tree/02.Binary-Tree-Traverse/. https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/ ","date":"2023-05-09","objectID":"/202304300709-%E6%A0%91/:4:0","series":["数据结构"],"tags":[],"title":"树","uri":"/202304300709-%E6%A0%91/#树的一些常见问题"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:0:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#"},{"categories":["数据结构与算法"],"content":"方法1. 递归子问题是：判断左右子树是否会等于预期的子树（判断左右子树是否相等的问题也可以递归来实现） // 判断根节点为起始的树与目标树是否相同 // 如果不相同，递归判断左子树和右子树 func isSubtree(root *TreeNode, subRoot *TreeNode) bool { if root == nil \u0026\u0026 subRoot == nil { return true } if root == nil { return false } if isSameTree(root, subRoot) { return true } return isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot) } func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026\u0026 q == nil { return true } if p == nil || q == nil { return false } if p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) \u0026\u0026 isSameTree(p.Right, q.Right) } ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:1:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#方法1-递归"},{"categories":["数据结构与算法"],"content":"方法2. dfs（先序） + kmp202304262036 KMP 算法 设主树s，子树t，主树的先序序列 ss，子树的先序序列 tt 利用先序序列的性质： 如果A.【 t 是 s 的子树】 那么B.【ss 中 包含 tt】 可以知道 B 是 A 的必要条件，是没有办法从 B 推出 A 的，原因是什么呢，假设主树：[4, 5]，子树：[4, nil, 5]，这种情况下的先序序列都是 4 5，但是两颗树是不一样的 但是我们可以通过补充两个代表空的左右节点来解决这个问题 // 通过树的先序遍历 // 补充树的每个节点，让度为2，输出树的先序遍历 // 判断主树的序列包含子树的序列 func isSubtree2(root *TreeNode, subRoot *TreeNode) bool { nums1 := dlrNums(root) nums2 := dlrNums(subRoot) return kmpSearch(nums1, nums2) } const lrNilVal = -10001 var leftNilNode = TreeNode{ Val: lrNilVal, } var rightNilNode = TreeNode{ Val: lrNilVal, } func dlrNums(root *TreeNode) []int { var nums []int if root == nil { return nums } var st []*TreeNode st = append(st, root) tmpRoot := root for len(st) \u003e 0 { // pop tmpRoot = st[len(st) - 1] st = st[:len(st) - 1] // visit nums = append(nums, tmpRoot.Val) if tmpRoot.Val != lrNilVal \u0026\u0026 tmpRoot.Left == nil { tmpRoot.Left = \u0026leftNilNode } if tmpRoot.Val != lrNilVal \u0026\u0026 tmpRoot.Right == nil { tmpRoot.Right = \u0026rightNilNode } if tmpRoot.Right != nil { st = append(st, tmpRoot.Right) } if tmpRoot.Left != nil { st = append(st, tmpRoot.Left) } } return nums } // i // nums a a b a a b a a c // pat // j func kmpSearch(nums, pat []int) bool { next := getNext(pat) j := 0 for i := 0; j \u003c len(pat) \u0026\u0026 i \u003c len(nums); i++ { for ; j \u003e 0 \u0026\u0026 nums[i] != pat[j]; j = next[j-1]{} if nums[i] == pat[j] { j++ } } return j == len(pat) } func getNext(pat []int) []int { next := make([]int, len(pat)) next[0] = 0 for l, j := 0, 1 ; j \u003c len(pat); j++ { for l \u003e 0 \u0026\u0026 pat[l] != pat[j] {l = next[l-1]} if pat[l] == pat[j] { l++ } next[j] = l } return next } ","date":"2023-05-09","objectID":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/:2:0","series":["算法"],"tags":[],"title":"树问题-判断子树","uri":"/202305031652-%E6%A0%91%E9%97%AE%E9%A2%98-%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91/#方法2-dfs先序--kmp"},{"categories":["数据结构与算法"],"content":"#算法 ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:0:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#"},{"categories":["数据结构与算法"],"content":"方法一、使用广度优先搜索（层次遍历）思路： 二叉树的层次遍历使用一个队列来保存每一层的节点，再增加一个队列，用来保存从根节点到当前节点的路径上的和 ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:1:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#方法一使用广度优先搜索层次遍历"},{"categories":["数据结构与算法"],"content":"方法二、递归思路： 原问题：是否存在从当前节点（根节点）到叶子节点的路径，和为 sum 子问题：是否存在从当前节点（根节点的子节点）到叶子节点的路径，和为 sum - val（父节点的值） 结束条件：当前节点为叶子节点 func hasPathSum(root *TreeNode, targetSum int) bool { if root == nil { return false } return havePathToLeaf(root, targetSum) } func havePathToLeaf(root *TreeNode, tgtSum int) bool { // end if root.Left == nil \u0026\u0026 root.Right == nil { return root.Val == tgtSum } have1, have2 := false, false if root.Left != nil { have1 = havePathToLeaf(root.Left, tgtSum - root.Val) } if root.Right != nil { have2 = havePathToLeaf(root.Right, tgtSum - root.Val) } return have1 || have2 } ","date":"2023-05-09","objectID":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/:2:0","series":["算法"],"tags":[],"title":"树问题-路径求和","uri":"/202305021918-%E6%A0%91%E9%97%AE%E9%A2%98-%E8%B7%AF%E5%BE%84%E6%B1%82%E5%92%8C/#方法二递归"},{"categories":["Golang"],"content":"#Golang ","date":"2023-05-09","objectID":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:0:0","series":["Golang底层认知"],"tags":[],"title":"深浅拷贝","uri":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/#"},{"categories":["Golang"],"content":"深浅拷贝的区别 深拷贝：两个对象不共享内存，各自分开 值类型的数据都是深拷贝，Int、Float、String、Bool、Struct 浅拷贝：两个对象指向同一个地址 引用类型的都是浅拷贝，Slice、Map ","date":"2023-05-09","objectID":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:1:0","series":["Golang底层认知"],"tags":[],"title":"深浅拷贝","uri":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/#深浅拷贝的区别"},{"categories":["Golang"],"content":"如果是 Slice 切片类型，想做深拷贝怎么办（使用 copy 方法） score := []int{1,2,3} scoreTmp := make([]int, len(score)) copy(scoreTmp, score) 注意点： 目的切面需要提前申请空间（一般与源切片等长，若更小，只拷贝部分，若更大，剩余空间补齐类型默认值） 若源切片存的是引用，则拷贝过去之后，目的切片保存的是跟源切片一样的引用（二维数组的拷贝），因此想二维数组如果要深拷贝需要二重循环 ","date":"2023-05-09","objectID":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/:2:0","series":["Golang底层认知"],"tags":[],"title":"深浅拷贝","uri":"/202304201947-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/#如果是-slice-切片类型想做深拷贝怎么办使用-copy-方法"},{"categories":["数据结构与算法"],"content":"#算法 递归能够解决的问题的特点： 原问题能够分解成一个更小的与原问题解决思路相同的子问题 递归的步骤： 拆分问题，找使用子问题解决原问题的方法（原问题与子问题的关系） 找子问题的解决方法，当与原问题的解决方法一致，便能够递归 结束的条件 时间复杂度 可以将编码的过程总结为： 1. 定义方法 2. 写明结束条件 3. 根据原问题、子问题之间的逻辑关系写主要的递归逻辑 递归存在的问题： 栈溢出 重复计算 ","date":"2023-05-09","objectID":"/202304300007-%E9%80%92%E5%BD%92/:0:0","series":["算法"],"tags":[],"title":"递归","uri":"/202304300007-%E9%80%92%E5%BD%92/#"},{"categories":["容器"],"content":"#k8s #问题定位 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:0:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#"},{"categories":["容器"],"content":"问题现场 kubectl -n product-ebs get pod -o wide | grep vtype-xxx 扎到了一个状态为 Evicted 的 pod ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:1:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#问题现场"},{"categories":["容器"],"content":"问题分析通过现场可以看到 pod 原先的节点，所以可以查看一下节点的日志 接着就发现了节点有磁盘压力，kubelet 主动终止 pod 以回收节点上的资源，以此来保证节点的稳定 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:2:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#问题分析"},{"categories":["容器"],"content":"学习","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:3:0","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#学习"},{"categories":["容器"],"content":"可能导致节点压力的因素有什么cpu、内存、磁盘空间… ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:3:1","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#可能导致节点压力的因素有什么"},{"categories":["容器"],"content":"kubelet 是如何做出驱逐的决定的 分析这个问题的步骤： 回答这个问题需要了解 Kubernetes 中 kubelet 组件以及 Eviction API，再结合节点资源使用情况等因素来判断是否要驱逐 Pod。具体的分析步骤如下： 了解 Kubernetes 中 kubelet 组件和 Eviction API 的作用和原理。 确认 kubelet 是否开启了 Eviction 功能。 判断当前节点资源（如内存、CPU、磁盘空间）使用情况是否达到了预定义的阈值，若达到或超出，则根据优先级逻辑对 Pod 进行驱逐操作。 产生这个问题的原因： 在 Kubernetes 下，由于各种原因（如资源紧缺，节点故障等），kubelet 可能会决定驱逐一些 Pod 以保证集群正常运转，因此了解 kubelet 决策的原因和方式对于提高 Kubernetes 集群的稳定性和安全性非常重要。 这个问题的答案： kubelet 驱逐 Pod 是通过以下步骤进行的： kubelet 定期与 kube-apiserver 通信，获取当前 Node 上的 Pod 列表信息。 kubelet 根据容器的 QoS 类别（Guaranteed \u003e Burstable \u003e BestEffort） 和优先级（pod priority/Preemption）进行排序。（Preemption 时过程中，kubelet 不会限制一些特定 Pod 从来不被驱逐。） kubelet 判断当前 Node 是否处于 out of memory 或者 DiskPressure 的状态，如果是的话，则使用相应的 Eviction API 驱逐 Pod。 如果还没有达到阈值，则尝试驱逐优先级最低的 Pod。如果此时节点有足够的资源可供使用，则该操作不会执行。否则，kubelet 将继续驱逐优先级下一个较低的 Pod 直到可以保证目标阈值。 如果使用上述步骤无法满足 Eviction 要求（如Pod 强占资源），kubelet 可能会强制删除其他 Pod 以便为当前占用的 Pod 腾出资源。 需要注意的是，kubelet 是被动的进行驱逐操作的，即只有在当前节点资源使用情况达到或超过了预设的阈值时才会进行驱逐，而这些阈值可以通过修改 Kubernetes 集群中的参数来调整。 容器的 QoS： kubectl describe pod \u003cpod-name\u003e | grep QoS 该命令会列出 Pod 的详细信息，并在结果中搜索 QoS 相关的部分。 Kubernetes 中的 QoS (Quality of Service) 是一个特性，它用来管理节点上运行的 Pod 的资源分配和调度。在 Kubernetes 中，QoS 有三种级别： Guaranteed：这种类型的 Pod 被保证能够获得所请求的 CPU 和内存资源。如果节点上的资源不足，优先级较低的 Pod 将被暂停或驱逐。 Burstable：这种类型的 Pod 具有最小的 CPU 和内存要求，但可以在需要时进行扩展，以获得更多资源。当节点上的资源不足时，Burstable Pod 可能会受到限制，但不会被完全暂停或驱逐。 BestEffort：这种类型的 Pod 不会被保证任何资源。它们将尽力在节点上占用尽可能少的资源，并且在节点资源不足时首先被削减或删除。 QoS 主要的作用是帮助 Kubernetes 管理资源，确保相同级别的 Pod 在节点上得到公平的资源分配，并且在资源不足的情况下，根据其级别的不同，采取适当的措施以保持节点的健康状态。 ","date":"2023-05-09","objectID":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/:3:2","series":["kubernetes实操"],"tags":["问题定位"],"title":"问题定位：Evicted","uri":"/202305080553-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8Devicted/#kubelet-是如何做出驱逐的决定的"},{"categories":["扩展学习"],"content":"#ChatGPT 该篇笔记源于课程：https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/ ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:0:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#"},{"categories":["扩展学习"],"content":"一、包含什么内容？两个产出： 使用大型语言模型（Large Language Model，LLM）快速构建功能强大的应用程序 构建两项能力： 学习创新 创造价值 了解 LLM 的工作原理 提示工程的最佳实践 如何编写有效的提示（两个原则） 如何设计好的提示 如何构建自己的聊天机器人 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:1:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#一包含什么内容"},{"categories":["扩展学习"],"content":"二、提示词准则","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#二提示词准则"},{"categories":["扩展学习"],"content":"2.1 指令要清晰 输入清晰 输出清晰 过程清晰 输入要清晰 清楚表明我想要的是什么？以此引导模型产出更符合我们期待的结果，避免跑题。注意清晰 != 简短，如果较长的描述更能准确表达我们的意图，那么这是必要的。 一些帮助符号： “” ``` --- \u003c\u003e … 有时候为了能够更清晰的表明意图，我们可以使用一些符号来辅佐说明。 例子： 你现在作为一名学生，需要对我的提问做出回答，ChatGPT Prompt Engineering for Developers 这门课讲述了什么 “您应该清晰且尽可能具体地表达您希望模型执行的操作，这将引导模型达到所预期的输出，并减少不相关的输出，或者不正确的输出。不要把写一个清晰的提示和写一个简短的提示混为一谈，许多情况下，较长的提示为模型提供了更清晰的背景，这可能会导致更加详细和相关的产出” 将由双引号限定的文字概括成一句话 上面的例子中，我们使用到了双引号来界定应该要总结的内容，引导模型产生我们想要的输出，当然这只是一个简单的例子，实际中可以更灵活地来使用 输出要清晰 上面的提到了如何更清晰地告诉模型应该输入的内容，下面我们应该告诉模型我们想要什么样的结果，我们可以结构化我们的输出，有时候我们可以将输出格式化为 html、json、markdown 等格式 看这样的一个例子 当然，更多时候 json 的 key 应该是英文，我们可以接着告诉 gpt： 有时候我们可能没有办法一次就描述清楚我们想要的，那么我们就可以继续补充，这是一个迭代的过程 过程要清晰 在处理的过程中，我们可以指定模型一些判断条件 看下面的例子 “泡一杯茶很简单！ 首先，你需要让水沸腾。 发生这种情况时， 拿一个杯子，在里面放一个茶包。 一旦水足够热，只需将其倒在茶包上即可。 让它静置一会儿。 再过几分钟，取出茶包。 如果你喜欢，可以加点糖或者牛奶调味。 就是这样！ 你有了自己的美味的一杯茶来享受。” 将上面由双引号限定的文本以下面的格式来重写： 第一步 - ... 第二步 - ... 第三步 - ... 第N步 - ... 如果文本不包含顺序指示，那么只需要写上“没有提供步骤” 上面的文本识别到了顺序指示，因此将文本以分步的形式重新组织了，同样的处理方式，我们来看另外一段文本： 今天阳光明媚，鸟儿们在唱歌。这是一个美丽的日子，可以去公园里散步。树木在微风中轻轻摇曳。 一些人正在野餐，而另一些人正在玩游戏或只是在草地上放松。这是一个 这是一个完美的日子，可以花时间在户外，欣赏自然之美。 将上面由双引号限定的文本以下面的格式来重写： 第一步 - ... 第二步 - ... 第三步 - ... 第N步 - ... 如果文本不包含指令序列，那么只需要写上“没有提供步骤” 可以看到通过判断，达到了我们想要的结果 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:1","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#21-指令要清晰"},{"categories":["扩展学习"],"content":"2.2 给模型思考的时间 指定步骤来完成任务 看这样一个例子： “在一个迷人的村庄里，兄妹杰克和吉尔出发去山顶的井里取水。他们一边唱着欢快的歌，一边爬山，但不幸的是，杰克绊倒在石头上，从山上滚了下来，吉尔也跟着摔倒。虽然有些受伤，但他们还是回家受到安慰的拥抱。尽管遭遇了不幸，但他们的冒险精神仍然没有消失，他们继续愉快地探索。” 执行下面的动作： 1 - 用一句话总结上面引号括起来的文本 2 - 将第一步得到的总结翻译成韩语 3 - 在韩语总结中列出每个名字 用换行把每一步的答案分开 在这个例子中，我们想要完成的并不只是一种操作，我们对于一段文本可能想做好几件事，那么就可以分成几个步骤，告诉模型分别要做什么 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:2","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#22-给模型思考的时间"},{"categories":["扩展学习"],"content":"* 模型的限制在模型训练的过程中，并不会完美的记住自己接触的每个信息，因此它对自己的知识边界并不是十分了解，这意味着它可能会尝试回答一些晦涩难懂的问题，并且可以编造一些听起来很有道理，但实际上并不真实的事情，如下面的例子 这并不是真实的，但看起来非常真实，这是非常危险的，也是模型已知的一个问题 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:2:3","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#-模型的限制"},{"categories":["扩展学习"],"content":"三、提示词的迭代由于某些原因，我们第一次获得的结果可能对于我们来说并不是有效、有用的，但是我们可以通过获得的结果，反复完善我们的提示词，一步步走向我们的想要的结果。 因此迭代的过程可以分为以下几步： 先试试 分析结果，是否符合我们预期 给出清楚的说明（指示），给模型更多时间思考 完善提示语 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:3:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#三提示词的迭代"},{"categories":["扩展学习"],"content":"四、总结摘要例子1： 把以下产品评论进行总结，总结的字数不超过30个字。 产品评论：\"我为女儿的生日买了这只熊猫毛绒玩具，她非常喜欢，并且随身携带。它摸起来很软，非常可爱，脸上还有友好的表情。但是，相对于价格来说，它有点小了。我认为可能会有其他同样价位但更大的选择。它比预期提前一天到达，所以在把它送给女儿之前，我自己先玩了一下。\" 如果把上面的任务稍微修改一下， 你的任务是对一个电子商务网站的产品评论生成一个简短的摘要，以反馈给航运部门。 把以下产品评论进行总结，总结的字数不超过30个字, 重点放在提到产品运输和交付的任何方面。 产品评论：\"我为女儿的生日买了这只熊猫毛绒玩具，她非常喜欢，并且随身携带。它摸起来很软，非常可爱，脸上还有友好的表情。但是，相对于价格来说，它有点小了。我认为可能会有其他同样价位但更大的选择。它比预期提前一天到达，所以在把它送给女儿之前，我自己先玩了一下。\" 我们可以根据想要总结的方式，要求它提取不同的信息 再来看一个可能实际中更能碰倒的例子： # review for a standing lamp review_1 = \"\"\" Needed a nice lamp for my bedroom, and this one \\ had additional storage and not too high of a price \\ point. Got it fast - arrived in 2 days. The string \\ to the lamp broke during the transit and the company \\ happily sent over a new one. Came within a few days \\ as well. It was easy to put together. Then I had a \\ missing part, so I contacted their support and they \\ very quickly got me the missing piece! Seems to me \\ to be a great company that cares about their customers \\ and products. \"\"\" # review for an electric toothbrush review_2 = \"\"\" My dental hygienist recommended an electric toothbrush, \\ which is why I got this. The battery life seems to be \\ pretty impressive so far. After initial charging and \\ leaving the charger plugged in for the first week to \\ condition the battery, I've unplugged the charger and \\ been using it for twice daily brushing for the last \\ 3 weeks all on the same charge. But the toothbrush head \\ is too small. I’ve seen baby toothbrushes bigger than \\ this one. I wish the head was bigger with different \\ length bristles to get between teeth better because \\ this one doesn’t. Overall if you can get this one \\ around the $50 mark, it's a good deal. The manufactuer's \\ replacements heads are pretty expensive, but you can \\ get generic ones that're more reasonably priced. This \\ toothbrush makes me feel like I've been to the dentist \\ every day. My teeth feel sparkly clean! \"\"\" # review for a blender review_3 = \"\"\" So, they still had the 17 piece system on seasonal \\ sale for around $49 in the month of November, about \\ half off, but for some reason (call it price gouging) \\ around the second week of December the prices all went \\ up to about anywhere from between $70-$89 for the same \\ system. And the 11 piece system went up around $10 or \\ so in price also from the earlier sale price of $29. \\ So it looks okay, but if you look at the base, the part \\ where the blade locks into place doesn’t look as good \\ as in previous editions from a few years ago, but I \\ plan to be very gentle with it (example, I crush \\ very hard items like beans, ice, rice, etc. in the \\ blender first then pulverize them in the serving size \\ I want in the blender then switch to the whipping \\ blade for a finer flour, and use the cross cutting blade \\ first when making smoothies, then use the flat blade \\ if I need them finer/less pulpy). Special tip when making \\ smoothies, finely cut and freeze the fruits and \\ vegetables (if using spinach-lightly stew soften the \\ spinach then freeze until ready for use-and if making \\ sorbet, use a small to medium sized food processor) \\ that you plan to use that way you can avoid adding so \\ much ice if at all-when making your smoothie. \\ After about a year, the motor was making a funny noise. \\ I called customer service but the warranty expired \\ already, so I had to buy another one. FYI: The overall \\ quality has gone done in these types of products, so \\ they are kind of counting on brand recognition and \\ consumer loyalty to maintain sales. Got it in about \\ two days. \"\"\" reviews = [review_1, review_2, review_3, review_4] 你的任务是将上面的每个review分别做总结，总结以下面的格式输出： 1. 2. 将总结翻译成中文 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:4:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#四总结摘要"},{"categories":["扩展学习"],"content":"五、AI 推理提取情绪信息 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:5:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#五ai-推理"},{"categories":["扩展学习"],"content":"六、AI 转译 翻译 语法纠正、校对 格式转换（json、html、markdown…） 语气转换 （语气转换）不同的邮件对象可能需要不同的语气或者书面语，看下面的例子 将下面的内容从俚语转换成一封商务信函： “伙计，我是乔，看看这个立灯的规格。” ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:6:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#六ai-转译"},{"categories":["扩展学习"],"content":"七、扩写（文案生成）扩写是指将一篇较短的文本进行扩写的工作，比如一套指示或者一个主题列表，生成一个较长的文本，如电子邮件或者文章。 例子：通过一名客户对于产品的评论生成一封回复邮件 你是一个客户服务的AI助理，你的任务是给一个有价值的客户发送电子邮件回复。 邮件的内容需要基于用户的评价，如果用户的情绪是积极的或者中性的，感谢他们的评论，如果情绪是负面的，则表示歉意，并建议他们可以联系客服。 确保使用用户评论中的具体细节。 用简明和专业的语气来写。 在邮件中署名：“AI 客户代理” 客户的评论：\"他们在11月份仍在季节性销售中以约49美元的价格销售17件套装，折扣约为一半，但出于某些原因（称其为价格抬高），到了12月的第二周，同样的系统的价格都涨到了约70-89美元左右。 11件套装的价格也比之前的29美元涨了大约10美元左右。 看起来还不错，但如果您看底座，锁定刀片的部分看起来与几年前的先前版本不太一样，但我打算非常小心（例如，我将像豆子，冰，米饭等非常硬的物品先放入搅拌机中压碎，然后把它们粉碎成我想要的食用量，然后切换到搅拌餐的鞭打刀，以获得更细的面粉，并在制作冰沙时先使用交叉切割刀，然后如果需要更细/较少纤维的话，再使用平刀）。制作冰沙的特殊提示：将要使用的水果和蔬菜切碎并冷冻（如果使用菠菜-轻轻煮软菠菜然后冷冻直到使用-如果制作雪泥，请使用小到中型食品处理器），以此来避免添加掉太多冰块。大约一年后，马达发出奇怪的噪音。我打电话给客服，但保修已经过期了，所以我不得不再买一个。 FYI：这些产品的整体质量已经下降，所以他们在品牌认知和消费者忠诚度上进行营销。大约两天后收到了产品。\" ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:7:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#七扩写文案生成"},{"categories":["扩展学习"],"content":"temperaturetemperature 作为模型的一个参数，将影响模型输出的随机性 显然：越低 temperature 意味着越高可靠性，越高 temperature 意味着越高创意性 ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:7:1","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#temperature"},{"categories":["扩展学习"],"content":"八、聊天机器人待补充… 《ChatGPT Prompt Engineering for Developers》. 见于 2023年5月7日. https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/. 二次元的Datawhale. 《【专业翻译，配套代码笔记】01.课程介绍_哔哩哔哩_bilibili》. 见于 2023年5月7日. https://www.bilibili.com/video/BV1Bo4y1A7FU/. ","date":"2023-05-09","objectID":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/:8:0","series":["ChatGPT"],"tags":["提示词"],"title":"面向开发者的 ChatGPT 提示工程","uri":"/202305062133-%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/#八聊天机器人"}]